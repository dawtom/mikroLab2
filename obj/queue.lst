   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.prvCopyDataToQueue,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	prvCopyDataToQueue:
  25              	.LFB123:
  26              		.file 1 "FreeRTOS/Source/queue.c"
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****     FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:FreeRTOS/Source/queue.c ****     All rights reserved
   4:FreeRTOS/Source/queue.c **** 
   5:FreeRTOS/Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:FreeRTOS/Source/queue.c **** 
   7:FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
   8:FreeRTOS/Source/queue.c **** 
   9:FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:FreeRTOS/Source/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:FreeRTOS/Source/queue.c **** 
  13:FreeRTOS/Source/queue.c ****     ***************************************************************************
  14:FreeRTOS/Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:FreeRTOS/Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:FreeRTOS/Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:FreeRTOS/Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:FreeRTOS/Source/queue.c ****     ***************************************************************************
  19:FreeRTOS/Source/queue.c **** 
  20:FreeRTOS/Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:FreeRTOS/Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:FreeRTOS/Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:FreeRTOS/Source/queue.c ****     link: http://www.freertos.org/a00114.html
  24:FreeRTOS/Source/queue.c **** 
  25:FreeRTOS/Source/queue.c ****     ***************************************************************************
  26:FreeRTOS/Source/queue.c ****      *                                                                       *
  27:FreeRTOS/Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:FreeRTOS/Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:FreeRTOS/Source/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:FreeRTOS/Source/queue.c ****      *    is the industry's de facto standard.                               *
  31:FreeRTOS/Source/queue.c ****      *                                                                       *
  32:FreeRTOS/Source/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:FreeRTOS/Source/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:FreeRTOS/Source/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:FreeRTOS/Source/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:FreeRTOS/Source/queue.c ****      *                                                                       *
  37:FreeRTOS/Source/queue.c ****     ***************************************************************************
  38:FreeRTOS/Source/queue.c **** 
  39:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:FreeRTOS/Source/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:FreeRTOS/Source/queue.c ****     defined configASSERT()?
  42:FreeRTOS/Source/queue.c **** 
  43:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:FreeRTOS/Source/queue.c ****     embedded software for free we request you assist our global community by
  45:FreeRTOS/Source/queue.c ****     participating in the support forum.
  46:FreeRTOS/Source/queue.c **** 
  47:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:FreeRTOS/Source/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:FreeRTOS/Source/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:FreeRTOS/Source/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:FreeRTOS/Source/queue.c **** 
  52:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:FreeRTOS/Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:FreeRTOS/Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:FreeRTOS/Source/queue.c **** 
  56:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:FreeRTOS/Source/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:FreeRTOS/Source/queue.c **** 
  59:FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:FreeRTOS/Source/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:FreeRTOS/Source/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:FreeRTOS/Source/queue.c **** 
  63:FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:FreeRTOS/Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:FreeRTOS/Source/queue.c ****     mission critical applications that require provable dependability.
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  68:FreeRTOS/Source/queue.c **** */
  69:FreeRTOS/Source/queue.c **** 
  70:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  71:FreeRTOS/Source/queue.c **** #include <string.h>
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  76:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:FreeRTOS/Source/queue.c **** 
  78:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  79:FreeRTOS/Source/queue.c **** #include "task.h"
  80:FreeRTOS/Source/queue.c **** #include "queue.h"
  81:FreeRTOS/Source/queue.c **** 
  82:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  84:FreeRTOS/Source/queue.c **** #endif
  85:FreeRTOS/Source/queue.c **** 
  86:FreeRTOS/Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:FreeRTOS/Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:FreeRTOS/Source/queue.c **** header files above, but not in this file, in order to generate the correct
  89:FreeRTOS/Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** 
  93:FreeRTOS/Source/queue.c **** /* Constants used with the xRxLock and xTxLock structure members. */
  94:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( BaseType_t ) -1 )
  95:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
  96:FreeRTOS/Source/queue.c **** 
  97:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:FreeRTOS/Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:FreeRTOS/Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:FreeRTOS/Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:FreeRTOS/Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:FreeRTOS/Source/queue.c **** against the coding standard (although an exception to the standard has been
 106:FreeRTOS/Source/queue.c **** permitted where the dual use also significantly changes the type of the
 107:FreeRTOS/Source/queue.c **** structure member). */
 108:FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
 109:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
 110:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:FreeRTOS/Source/queue.c **** 
 112:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:FreeRTOS/Source/queue.c **** zero. */
 114:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:FreeRTOS/Source/queue.c **** 
 117:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
 120:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:FreeRTOS/Source/queue.c **** #else
 122:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:FreeRTOS/Source/queue.c **** #endif
 124:FreeRTOS/Source/queue.c **** 
 125:FreeRTOS/Source/queue.c **** /*
 126:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
 127:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:FreeRTOS/Source/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:FreeRTOS/Source/queue.c ****  */
 130:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 131:FreeRTOS/Source/queue.c **** {
 132:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:FreeRTOS/Source/queue.c **** 
 136:FreeRTOS/Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:FreeRTOS/Source/queue.c **** 	{
 138:FreeRTOS/Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:FreeRTOS/Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:FreeRTOS/Source/queue.c **** 	} u;
 141:FreeRTOS/Source/queue.c **** 
 142:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:FreeRTOS/Source/queue.c **** 
 149:FreeRTOS/Source/queue.c **** 	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from 
 150:FreeRTOS/Source/queue.c **** 	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the
 151:FreeRTOS/Source/queue.c **** 
 152:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 153:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 154:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 155:FreeRTOS/Source/queue.c **** 	#endif
 156:FreeRTOS/Source/queue.c **** 
 157:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 158:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 159:FreeRTOS/Source/queue.c **** 	#endif
 160:FreeRTOS/Source/queue.c **** 
 161:FreeRTOS/Source/queue.c **** } xQUEUE;
 162:FreeRTOS/Source/queue.c **** 
 163:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 164:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 165:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 166:FreeRTOS/Source/queue.c **** 
 167:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 168:FreeRTOS/Source/queue.c **** 
 169:FreeRTOS/Source/queue.c **** /*
 170:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 171:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 172:FreeRTOS/Source/queue.c ****  */
 173:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 174:FreeRTOS/Source/queue.c **** 
 175:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 176:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 177:FreeRTOS/Source/queue.c **** 	more user friendly. */
 178:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 179:FreeRTOS/Source/queue.c **** 	{
 180:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 181:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 182:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 183:FreeRTOS/Source/queue.c **** 
 184:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 185:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 186:FreeRTOS/Source/queue.c **** 	debuggers. */
 187:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 188:FreeRTOS/Source/queue.c **** 
 189:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 190:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 191:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 192:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 193:FreeRTOS/Source/queue.c **** 
 194:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 198:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 199:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 200:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 201:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 202:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 203:FreeRTOS/Source/queue.c ****  */
 204:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 205:FreeRTOS/Source/queue.c **** 
 206:FreeRTOS/Source/queue.c **** /*
 207:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 208:FreeRTOS/Source/queue.c ****  *
 209:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 210:FreeRTOS/Source/queue.c ****  */
 211:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 212:FreeRTOS/Source/queue.c **** 
 213:FreeRTOS/Source/queue.c **** /*
 214:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 215:FreeRTOS/Source/queue.c ****  *
 216:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 217:FreeRTOS/Source/queue.c ****  */
 218:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 219:FreeRTOS/Source/queue.c **** 
 220:FreeRTOS/Source/queue.c **** /*
 221:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 222:FreeRTOS/Source/queue.c ****  * back of the queue.
 223:FreeRTOS/Source/queue.c ****  */
 224:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 225:FreeRTOS/Source/queue.c **** 
 226:FreeRTOS/Source/queue.c **** /*
 227:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 228:FreeRTOS/Source/queue.c ****  */
 229:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 230:FreeRTOS/Source/queue.c **** 
 231:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 232:FreeRTOS/Source/queue.c **** 	/*
 233:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 234:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
 235:FreeRTOS/Source/queue.c **** 	 */
 236:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 237:FreeRTOS/Source/queue.c **** #endif
 238:FreeRTOS/Source/queue.c **** 
 239:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 240:FreeRTOS/Source/queue.c **** 
 241:FreeRTOS/Source/queue.c **** /*
 242:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 243:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 244:FreeRTOS/Source/queue.c ****  */
 245:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 246:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 247:FreeRTOS/Source/queue.c **** 	{														\
 248:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 249:FreeRTOS/Source/queue.c **** 		{													\
 250:FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 251:FreeRTOS/Source/queue.c **** 		}													\
 252:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 253:FreeRTOS/Source/queue.c **** 		{													\
 254:FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 255:FreeRTOS/Source/queue.c **** 		}													\
 256:FreeRTOS/Source/queue.c **** 	}														\
 257:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 258:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 259:FreeRTOS/Source/queue.c **** 
 260:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 261:FreeRTOS/Source/queue.c **** {
 262:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 263:FreeRTOS/Source/queue.c **** 
 264:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 265:FreeRTOS/Source/queue.c **** 
 266:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 267:FreeRTOS/Source/queue.c **** 	{
 268:FreeRTOS/Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 269:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 270:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 271:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 272:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 273:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 274:FreeRTOS/Source/queue.c **** 
 275:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
 276:FreeRTOS/Source/queue.c **** 		{
 277:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 278:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 279:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 280:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 281:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 282:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 283:FreeRTOS/Source/queue.c **** 			{
 284:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 285:FreeRTOS/Source/queue.c **** 				{
 286:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 287:FreeRTOS/Source/queue.c **** 				}
 288:FreeRTOS/Source/queue.c **** 				else
 289:FreeRTOS/Source/queue.c **** 				{
 290:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 				}
 292:FreeRTOS/Source/queue.c **** 			}
 293:FreeRTOS/Source/queue.c **** 			else
 294:FreeRTOS/Source/queue.c **** 			{
 295:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 296:FreeRTOS/Source/queue.c **** 			}
 297:FreeRTOS/Source/queue.c **** 		}
 298:FreeRTOS/Source/queue.c **** 		else
 299:FreeRTOS/Source/queue.c **** 		{
 300:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 301:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 302:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 303:FreeRTOS/Source/queue.c **** 		}
 304:FreeRTOS/Source/queue.c **** 	}
 305:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 306:FreeRTOS/Source/queue.c **** 
 307:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 308:FreeRTOS/Source/queue.c **** 	versions. */
 309:FreeRTOS/Source/queue.c **** 	return pdPASS;
 310:FreeRTOS/Source/queue.c **** }
 311:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 312:FreeRTOS/Source/queue.c **** 
 313:FreeRTOS/Source/queue.c **** QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, c
 314:FreeRTOS/Source/queue.c **** {
 315:FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 316:FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 317:FreeRTOS/Source/queue.c **** QueueHandle_t xReturn = NULL;
 318:FreeRTOS/Source/queue.c **** 
 319:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 320:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 321:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 322:FreeRTOS/Source/queue.c **** 
 323:FreeRTOS/Source/queue.c **** 	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 324:FreeRTOS/Source/queue.c **** 
 325:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 326:FreeRTOS/Source/queue.c **** 	{
 327:FreeRTOS/Source/queue.c **** 		/* There is not going to be a queue storage area. */
 328:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) 0;
 329:FreeRTOS/Source/queue.c **** 	}
 330:FreeRTOS/Source/queue.c **** 	else
 331:FreeRTOS/Source/queue.c **** 	{
 332:FreeRTOS/Source/queue.c **** 		/* The queue is one byte longer than asked for to make wrap checking
 333:FreeRTOS/Source/queue.c **** 		easier/faster. */
 334:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA 
 335:FreeRTOS/Source/queue.c **** 	}
 336:FreeRTOS/Source/queue.c **** 
 337:FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure and storage area. */
 338:FreeRTOS/Source/queue.c **** 	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 339:FreeRTOS/Source/queue.c **** 
 340:FreeRTOS/Source/queue.c **** 	if( pxNewQueue != NULL )
 341:FreeRTOS/Source/queue.c **** 	{
 342:FreeRTOS/Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 343:FreeRTOS/Source/queue.c **** 		{
 344:FreeRTOS/Source/queue.c **** 			/* No RAM was allocated for the queue storage area, but PC head
 345:FreeRTOS/Source/queue.c **** 			cannot be set to NULL because NULL is used as a key to say the queue
 346:FreeRTOS/Source/queue.c **** 			is used as a mutex.  Therefore just set pcHead to point to the queue
 347:FreeRTOS/Source/queue.c **** 			as a benign value that is known to be within the memory map. */
 348:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 349:FreeRTOS/Source/queue.c **** 		}
 350:FreeRTOS/Source/queue.c **** 		else
 351:FreeRTOS/Source/queue.c **** 		{
 352:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 353:FreeRTOS/Source/queue.c **** 			storage area. */
 354:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
 355:FreeRTOS/Source/queue.c **** 		}
 356:FreeRTOS/Source/queue.c **** 
 357:FreeRTOS/Source/queue.c **** 		/* Initialise the queue members as described above where the queue type
 358:FreeRTOS/Source/queue.c **** 		is defined. */
 359:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxLength = uxQueueLength;
 360:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxItemSize = uxItemSize;
 361:FreeRTOS/Source/queue.c **** 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 362:FreeRTOS/Source/queue.c **** 
 363:FreeRTOS/Source/queue.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
 364:FreeRTOS/Source/queue.c **** 		{
 365:FreeRTOS/Source/queue.c **** 			pxNewQueue->ucQueueType = ucQueueType;
 366:FreeRTOS/Source/queue.c **** 		}
 367:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_TRACE_FACILITY */
 368:FreeRTOS/Source/queue.c **** 
 369:FreeRTOS/Source/queue.c **** 		#if( configUSE_QUEUE_SETS == 1 )
 370:FreeRTOS/Source/queue.c **** 		{
 371:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxQueueSetContainer = NULL;
 372:FreeRTOS/Source/queue.c **** 		}
 373:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_QUEUE_SETS */
 374:FreeRTOS/Source/queue.c **** 
 375:FreeRTOS/Source/queue.c **** 		traceQUEUE_CREATE( pxNewQueue );
 376:FreeRTOS/Source/queue.c **** 		xReturn = pxNewQueue;
 377:FreeRTOS/Source/queue.c **** 	}
 378:FreeRTOS/Source/queue.c **** 	else
 379:FreeRTOS/Source/queue.c **** 	{
 380:FreeRTOS/Source/queue.c **** 		mtCOVERAGE_TEST_MARKER();
 381:FreeRTOS/Source/queue.c **** 	}
 382:FreeRTOS/Source/queue.c **** 
 383:FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 384:FreeRTOS/Source/queue.c **** 
 385:FreeRTOS/Source/queue.c **** 	return xReturn;
 386:FreeRTOS/Source/queue.c **** }
 387:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 388:FreeRTOS/Source/queue.c **** 
 389:FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 390:FreeRTOS/Source/queue.c **** 
 391:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 392:FreeRTOS/Source/queue.c **** 	{
 393:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 394:FreeRTOS/Source/queue.c **** 
 395:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 396:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 397:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 398:FreeRTOS/Source/queue.c **** 
 399:FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 400:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
 401:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 402:FreeRTOS/Source/queue.c **** 		{
 403:FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 404:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 405:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 406:FreeRTOS/Source/queue.c **** 
 407:FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 408:FreeRTOS/Source/queue.c **** 			of the queue. */
 409:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 410:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 411:FreeRTOS/Source/queue.c **** 
 412:FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 413:FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 414:FreeRTOS/Source/queue.c **** 			of the mutex. */
 415:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 416:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 417:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 418:FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 419:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 420:FreeRTOS/Source/queue.c **** 
 421:FreeRTOS/Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 422:FreeRTOS/Source/queue.c **** 			{
 423:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 424:FreeRTOS/Source/queue.c **** 			}
 425:FreeRTOS/Source/queue.c **** 			#endif
 426:FreeRTOS/Source/queue.c **** 
 427:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 428:FreeRTOS/Source/queue.c **** 			{
 429:FreeRTOS/Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 430:FreeRTOS/Source/queue.c **** 			}
 431:FreeRTOS/Source/queue.c **** 			#endif
 432:FreeRTOS/Source/queue.c **** 
 433:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 434:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 435:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 436:FreeRTOS/Source/queue.c **** 
 437:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 438:FreeRTOS/Source/queue.c **** 
 439:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 440:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 441:FreeRTOS/Source/queue.c **** 		}
 442:FreeRTOS/Source/queue.c **** 		else
 443:FreeRTOS/Source/queue.c **** 		{
 444:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 445:FreeRTOS/Source/queue.c **** 		}
 446:FreeRTOS/Source/queue.c **** 
 447:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 448:FreeRTOS/Source/queue.c **** 	}
 449:FreeRTOS/Source/queue.c **** 
 450:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 451:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 452:FreeRTOS/Source/queue.c **** 
 453:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 454:FreeRTOS/Source/queue.c **** 
 455:FreeRTOS/Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 456:FreeRTOS/Source/queue.c **** 	{
 457:FreeRTOS/Source/queue.c **** 	void *pxReturn;
 458:FreeRTOS/Source/queue.c **** 
 459:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 460:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 461:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 462:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 463:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 464:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 465:FreeRTOS/Source/queue.c **** 		{
 466:FreeRTOS/Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 467:FreeRTOS/Source/queue.c **** 			{
 468:FreeRTOS/Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 469:FreeRTOS/Source/queue.c **** 			}
 470:FreeRTOS/Source/queue.c **** 			else
 471:FreeRTOS/Source/queue.c **** 			{
 472:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 473:FreeRTOS/Source/queue.c **** 			}
 474:FreeRTOS/Source/queue.c **** 		}
 475:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 476:FreeRTOS/Source/queue.c **** 
 477:FreeRTOS/Source/queue.c **** 		return pxReturn;
 478:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 479:FreeRTOS/Source/queue.c **** 
 480:FreeRTOS/Source/queue.c **** #endif
 481:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 482:FreeRTOS/Source/queue.c **** 
 483:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 484:FreeRTOS/Source/queue.c **** 
 485:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 486:FreeRTOS/Source/queue.c **** 	{
 487:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 488:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 489:FreeRTOS/Source/queue.c **** 
 490:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 491:FreeRTOS/Source/queue.c **** 
 492:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 493:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 494:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 495:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 496:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 497:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 498:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 499:FreeRTOS/Source/queue.c **** 		{
 500:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 501:FreeRTOS/Source/queue.c **** 
 502:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 503:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 504:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 505:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 506:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 507:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 508:FreeRTOS/Source/queue.c **** 
 509:FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 510:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 511:FreeRTOS/Source/queue.c **** 			{
 512:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 513:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 514:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 515:FreeRTOS/Source/queue.c **** 			}
 516:FreeRTOS/Source/queue.c **** 			else
 517:FreeRTOS/Source/queue.c **** 			{
 518:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 519:FreeRTOS/Source/queue.c **** 			}
 520:FreeRTOS/Source/queue.c **** 
 521:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 522:FreeRTOS/Source/queue.c **** 		}
 523:FreeRTOS/Source/queue.c **** 		else
 524:FreeRTOS/Source/queue.c **** 		{
 525:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 526:FreeRTOS/Source/queue.c **** 			holder. */
 527:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 528:FreeRTOS/Source/queue.c **** 
 529:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 530:FreeRTOS/Source/queue.c **** 		}
 531:FreeRTOS/Source/queue.c **** 
 532:FreeRTOS/Source/queue.c **** 		return xReturn;
 533:FreeRTOS/Source/queue.c **** 	}
 534:FreeRTOS/Source/queue.c **** 
 535:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 536:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 537:FreeRTOS/Source/queue.c **** 
 538:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 539:FreeRTOS/Source/queue.c **** 
 540:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 541:FreeRTOS/Source/queue.c **** 	{
 542:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 543:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 544:FreeRTOS/Source/queue.c **** 
 545:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 546:FreeRTOS/Source/queue.c **** 
 547:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 548:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 549:FreeRTOS/Source/queue.c **** 
 550:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 551:FreeRTOS/Source/queue.c **** 
 552:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 553:FreeRTOS/Source/queue.c **** 		{
 554:FreeRTOS/Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 555:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 556:FreeRTOS/Source/queue.c **** 		}
 557:FreeRTOS/Source/queue.c **** 		else
 558:FreeRTOS/Source/queue.c **** 		{
 559:FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 560:FreeRTOS/Source/queue.c **** 
 561:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 562:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 563:FreeRTOS/Source/queue.c **** 			before reaching here. */
 564:FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 565:FreeRTOS/Source/queue.c **** 			{
 566:FreeRTOS/Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 567:FreeRTOS/Source/queue.c **** 			}
 568:FreeRTOS/Source/queue.c **** 			else
 569:FreeRTOS/Source/queue.c **** 			{
 570:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 571:FreeRTOS/Source/queue.c **** 			}
 572:FreeRTOS/Source/queue.c **** 		}
 573:FreeRTOS/Source/queue.c **** 
 574:FreeRTOS/Source/queue.c **** 		return xReturn;
 575:FreeRTOS/Source/queue.c **** 	}
 576:FreeRTOS/Source/queue.c **** 
 577:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 578:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 579:FreeRTOS/Source/queue.c **** 
 580:FreeRTOS/Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 581:FreeRTOS/Source/queue.c **** 
 582:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 583:FreeRTOS/Source/queue.c **** 	{
 584:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 585:FreeRTOS/Source/queue.c **** 
 586:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 587:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 588:FreeRTOS/Source/queue.c **** 
 589:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 590:FreeRTOS/Source/queue.c **** 
 591:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 592:FreeRTOS/Source/queue.c **** 		{
 593:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 594:FreeRTOS/Source/queue.c **** 
 595:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 596:FreeRTOS/Source/queue.c **** 		}
 597:FreeRTOS/Source/queue.c **** 		else
 598:FreeRTOS/Source/queue.c **** 		{
 599:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 600:FreeRTOS/Source/queue.c **** 		}
 601:FreeRTOS/Source/queue.c **** 
 602:FreeRTOS/Source/queue.c **** 		configASSERT( xHandle );
 603:FreeRTOS/Source/queue.c **** 		return xHandle;
 604:FreeRTOS/Source/queue.c **** 	}
 605:FreeRTOS/Source/queue.c **** 
 606:FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 607:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 608:FreeRTOS/Source/queue.c **** 
 609:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 610:FreeRTOS/Source/queue.c **** {
 611:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 612:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 613:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 614:FreeRTOS/Source/queue.c **** 
 615:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 616:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 617:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 618:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 619:FreeRTOS/Source/queue.c **** 	{
 620:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 621:FreeRTOS/Source/queue.c **** 	}
 622:FreeRTOS/Source/queue.c **** 	#endif
 623:FreeRTOS/Source/queue.c **** 
 624:FreeRTOS/Source/queue.c **** 
 625:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 626:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 627:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 628:FreeRTOS/Source/queue.c **** 	for( ;; )
 629:FreeRTOS/Source/queue.c **** 	{
 630:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 631:FreeRTOS/Source/queue.c **** 		{
 632:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 633:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 634:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 635:FreeRTOS/Source/queue.c **** 			queue is full. */
 636:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 637:FreeRTOS/Source/queue.c **** 			{
 638:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 639:FreeRTOS/Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 640:FreeRTOS/Source/queue.c **** 
 641:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 642:FreeRTOS/Source/queue.c **** 				{
 643:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 644:FreeRTOS/Source/queue.c **** 					{
 645:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 646:FreeRTOS/Source/queue.c **** 						{
 647:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 648:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 649:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 650:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 651:FreeRTOS/Source/queue.c **** 						}
 652:FreeRTOS/Source/queue.c **** 						else
 653:FreeRTOS/Source/queue.c **** 						{
 654:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 655:FreeRTOS/Source/queue.c **** 						}
 656:FreeRTOS/Source/queue.c **** 					}
 657:FreeRTOS/Source/queue.c **** 					else
 658:FreeRTOS/Source/queue.c **** 					{
 659:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 660:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 661:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 662:FreeRTOS/Source/queue.c **** 						{
 663:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 664:FreeRTOS/Source/queue.c **** 							{
 665:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 666:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 667:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 668:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 669:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 670:FreeRTOS/Source/queue.c **** 							}
 671:FreeRTOS/Source/queue.c **** 							else
 672:FreeRTOS/Source/queue.c **** 							{
 673:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 674:FreeRTOS/Source/queue.c **** 							}
 675:FreeRTOS/Source/queue.c **** 						}
 676:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 677:FreeRTOS/Source/queue.c **** 						{
 678:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 679:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 680:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 681:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 682:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 683:FreeRTOS/Source/queue.c **** 						}
 684:FreeRTOS/Source/queue.c **** 						else
 685:FreeRTOS/Source/queue.c **** 						{
 686:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 687:FreeRTOS/Source/queue.c **** 						}
 688:FreeRTOS/Source/queue.c **** 					}
 689:FreeRTOS/Source/queue.c **** 				}
 690:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 691:FreeRTOS/Source/queue.c **** 				{
 692:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 693:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 694:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 695:FreeRTOS/Source/queue.c **** 					{
 696:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 697:FreeRTOS/Source/queue.c **** 						{
 698:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 699:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 700:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 701:FreeRTOS/Source/queue.c **** 							takes care of that. */
 702:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 703:FreeRTOS/Source/queue.c **** 						}
 704:FreeRTOS/Source/queue.c **** 						else
 705:FreeRTOS/Source/queue.c **** 						{
 706:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 707:FreeRTOS/Source/queue.c **** 						}
 708:FreeRTOS/Source/queue.c **** 					}
 709:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 710:FreeRTOS/Source/queue.c **** 					{
 711:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 712:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 713:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 714:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 715:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 716:FreeRTOS/Source/queue.c **** 					}
 717:FreeRTOS/Source/queue.c **** 					else
 718:FreeRTOS/Source/queue.c **** 					{
 719:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 720:FreeRTOS/Source/queue.c **** 					}
 721:FreeRTOS/Source/queue.c **** 				}
 722:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 723:FreeRTOS/Source/queue.c **** 
 724:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 725:FreeRTOS/Source/queue.c **** 				return pdPASS;
 726:FreeRTOS/Source/queue.c **** 			}
 727:FreeRTOS/Source/queue.c **** 			else
 728:FreeRTOS/Source/queue.c **** 			{
 729:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 730:FreeRTOS/Source/queue.c **** 				{
 731:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 732:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 733:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 734:FreeRTOS/Source/queue.c **** 
 735:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 736:FreeRTOS/Source/queue.c **** 					the function. */
 737:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 738:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 739:FreeRTOS/Source/queue.c **** 				}
 740:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 741:FreeRTOS/Source/queue.c **** 				{
 742:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 743:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 744:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 745:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 746:FreeRTOS/Source/queue.c **** 				}
 747:FreeRTOS/Source/queue.c **** 				else
 748:FreeRTOS/Source/queue.c **** 				{
 749:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 750:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 751:FreeRTOS/Source/queue.c **** 				}
 752:FreeRTOS/Source/queue.c **** 			}
 753:FreeRTOS/Source/queue.c **** 		}
 754:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 755:FreeRTOS/Source/queue.c **** 
 756:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 757:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 758:FreeRTOS/Source/queue.c **** 
 759:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 760:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 761:FreeRTOS/Source/queue.c **** 
 762:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 763:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 764:FreeRTOS/Source/queue.c **** 		{
 765:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 766:FreeRTOS/Source/queue.c **** 			{
 767:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 768:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 769:FreeRTOS/Source/queue.c **** 
 770:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 771:FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 772:FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 773:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 774:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 775:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 776:FreeRTOS/Source/queue.c **** 
 777:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 778:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 779:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 780:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 781:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 782:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 783:FreeRTOS/Source/queue.c **** 				{
 784:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 785:FreeRTOS/Source/queue.c **** 				}
 786:FreeRTOS/Source/queue.c **** 			}
 787:FreeRTOS/Source/queue.c **** 			else
 788:FreeRTOS/Source/queue.c **** 			{
 789:FreeRTOS/Source/queue.c **** 				/* Try again. */
 790:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 791:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 792:FreeRTOS/Source/queue.c **** 			}
 793:FreeRTOS/Source/queue.c **** 		}
 794:FreeRTOS/Source/queue.c **** 		else
 795:FreeRTOS/Source/queue.c **** 		{
 796:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 797:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 798:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 799:FreeRTOS/Source/queue.c **** 
 800:FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 801:FreeRTOS/Source/queue.c **** 			function. */
 802:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 803:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 804:FreeRTOS/Source/queue.c **** 		}
 805:FreeRTOS/Source/queue.c **** 	}
 806:FreeRTOS/Source/queue.c **** }
 807:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 808:FreeRTOS/Source/queue.c **** 
 809:FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 810:FreeRTOS/Source/queue.c **** 
 811:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_
 812:FreeRTOS/Source/queue.c **** 	{
 813:FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 814:FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 815:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 816:FreeRTOS/Source/queue.c **** 
 817:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 818:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 819:FreeRTOS/Source/queue.c **** 
 820:FreeRTOS/Source/queue.c **** 		for( ;; )
 821:FreeRTOS/Source/queue.c **** 		{
 822:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 823:FreeRTOS/Source/queue.c **** 			{
 824:FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 825:FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 826:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 827:FreeRTOS/Source/queue.c **** 				{
 828:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 829:FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 830:FreeRTOS/Source/queue.c **** 
 831:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 832:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 833:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 834:FreeRTOS/Source/queue.c **** 					{
 835:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 836:FreeRTOS/Source/queue.c **** 						{
 837:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 838:FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 839:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 840:FreeRTOS/Source/queue.c **** 						}
 841:FreeRTOS/Source/queue.c **** 						else
 842:FreeRTOS/Source/queue.c **** 						{
 843:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 844:FreeRTOS/Source/queue.c **** 						}
 845:FreeRTOS/Source/queue.c **** 					}
 846:FreeRTOS/Source/queue.c **** 					else
 847:FreeRTOS/Source/queue.c **** 					{
 848:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 849:FreeRTOS/Source/queue.c **** 					}
 850:FreeRTOS/Source/queue.c **** 
 851:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 852:FreeRTOS/Source/queue.c **** 					return pdPASS;
 853:FreeRTOS/Source/queue.c **** 				}
 854:FreeRTOS/Source/queue.c **** 				else
 855:FreeRTOS/Source/queue.c **** 				{
 856:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 857:FreeRTOS/Source/queue.c **** 					{
 858:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 859:FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 860:FreeRTOS/Source/queue.c **** 					}
 861:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 862:FreeRTOS/Source/queue.c **** 					{
 863:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 864:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 865:FreeRTOS/Source/queue.c **** 					}
 866:FreeRTOS/Source/queue.c **** 				}
 867:FreeRTOS/Source/queue.c **** 			}
 868:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 869:FreeRTOS/Source/queue.c **** 
 870:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 871:FreeRTOS/Source/queue.c **** 			{
 872:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 873:FreeRTOS/Source/queue.c **** 				{
 874:FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 875:FreeRTOS/Source/queue.c **** 					{
 876:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 877:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 878:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 879:FreeRTOS/Source/queue.c **** 					}
 880:FreeRTOS/Source/queue.c **** 					else
 881:FreeRTOS/Source/queue.c **** 					{
 882:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 883:FreeRTOS/Source/queue.c **** 					}
 884:FreeRTOS/Source/queue.c **** 				}
 885:FreeRTOS/Source/queue.c **** 				else
 886:FreeRTOS/Source/queue.c **** 				{
 887:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 888:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 889:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 890:FreeRTOS/Source/queue.c **** 				}
 891:FreeRTOS/Source/queue.c **** 			}
 892:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 893:FreeRTOS/Source/queue.c **** 		}
 894:FreeRTOS/Source/queue.c **** 	}
 895:FreeRTOS/Source/queue.c **** 
 896:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 897:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 898:FreeRTOS/Source/queue.c **** 
 899:FreeRTOS/Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 900:FreeRTOS/Source/queue.c **** 
 901:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicks
 902:FreeRTOS/Source/queue.c **** 	{
 903:FreeRTOS/Source/queue.c **** 	BaseType_t xEntryTimeSet = pdFALSE;
 904:FreeRTOS/Source/queue.c **** 	TimeOut_t xTimeOut;
 905:FreeRTOS/Source/queue.c **** 	int8_t *pcOriginalReadPosition;
 906:FreeRTOS/Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 907:FreeRTOS/Source/queue.c **** 
 908:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 909:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 910:FreeRTOS/Source/queue.c **** 
 911:FreeRTOS/Source/queue.c **** 		for( ;; )
 912:FreeRTOS/Source/queue.c **** 		{
 913:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 914:FreeRTOS/Source/queue.c **** 			{
 915:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 916:FreeRTOS/Source/queue.c **** 				{
 917:FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 918:FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 919:FreeRTOS/Source/queue.c **** 
 920:FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 921:FreeRTOS/Source/queue.c **** 
 922:FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 923:FreeRTOS/Source/queue.c **** 					{
 924:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 925:FreeRTOS/Source/queue.c **** 
 926:FreeRTOS/Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 927:FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 928:FreeRTOS/Source/queue.c **** 
 929:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 930:FreeRTOS/Source/queue.c **** 						{
 931:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 932:FreeRTOS/Source/queue.c **** 							{
 933:FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 934:FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 935:FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
 936:FreeRTOS/Source/queue.c **** 							}
 937:FreeRTOS/Source/queue.c **** 							else
 938:FreeRTOS/Source/queue.c **** 							{
 939:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 940:FreeRTOS/Source/queue.c **** 							}
 941:FreeRTOS/Source/queue.c **** 						}
 942:FreeRTOS/Source/queue.c **** 						#endif
 943:FreeRTOS/Source/queue.c **** 
 944:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 945:FreeRTOS/Source/queue.c **** 						{
 946:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 947:FreeRTOS/Source/queue.c **** 							{
 948:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 949:FreeRTOS/Source/queue.c **** 							}
 950:FreeRTOS/Source/queue.c **** 							else
 951:FreeRTOS/Source/queue.c **** 							{
 952:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 953:FreeRTOS/Source/queue.c **** 							}
 954:FreeRTOS/Source/queue.c **** 						}
 955:FreeRTOS/Source/queue.c **** 					}
 956:FreeRTOS/Source/queue.c **** 					else
 957:FreeRTOS/Source/queue.c **** 					{
 958:FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 959:FreeRTOS/Source/queue.c **** 
 960:FreeRTOS/Source/queue.c **** 						/* The data is not being removed, so reset our read
 961:FreeRTOS/Source/queue.c **** 						pointer. */
 962:FreeRTOS/Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 963:FreeRTOS/Source/queue.c **** 
 964:FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 965:FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 966:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 967:FreeRTOS/Source/queue.c **** 						{
 968:FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 969:FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 970:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 971:FreeRTOS/Source/queue.c **** 							{
 972:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 973:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 974:FreeRTOS/Source/queue.c **** 							}
 975:FreeRTOS/Source/queue.c **** 							else
 976:FreeRTOS/Source/queue.c **** 							{
 977:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 978:FreeRTOS/Source/queue.c **** 							}
 979:FreeRTOS/Source/queue.c **** 						}
 980:FreeRTOS/Source/queue.c **** 						else
 981:FreeRTOS/Source/queue.c **** 						{
 982:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 983:FreeRTOS/Source/queue.c **** 						}
 984:FreeRTOS/Source/queue.c **** 					}
 985:FreeRTOS/Source/queue.c **** 
 986:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 987:FreeRTOS/Source/queue.c **** 					return pdPASS;
 988:FreeRTOS/Source/queue.c **** 				}
 989:FreeRTOS/Source/queue.c **** 				else
 990:FreeRTOS/Source/queue.c **** 				{
 991:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( TickType_t ) 0 )
 992:FreeRTOS/Source/queue.c **** 					{
 993:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 994:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 995:FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 996:FreeRTOS/Source/queue.c **** 					}
 997:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 998:FreeRTOS/Source/queue.c **** 					{
 999:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
1000:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
1001:FreeRTOS/Source/queue.c **** 					}
1002:FreeRTOS/Source/queue.c **** 				}
1003:FreeRTOS/Source/queue.c **** 			}
1004:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1005:FreeRTOS/Source/queue.c **** 
1006:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
1007:FreeRTOS/Source/queue.c **** 			{
1008:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1009:FreeRTOS/Source/queue.c **** 				{
1010:FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1011:FreeRTOS/Source/queue.c **** 					{
1012:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1013:FreeRTOS/Source/queue.c **** 
1014:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
1015:FreeRTOS/Source/queue.c **** 						{
1016:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1017:FreeRTOS/Source/queue.c **** 							{
1018:FreeRTOS/Source/queue.c **** 								taskENTER_CRITICAL();
1019:FreeRTOS/Source/queue.c **** 								{
1020:FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1021:FreeRTOS/Source/queue.c **** 								}
1022:FreeRTOS/Source/queue.c **** 								taskEXIT_CRITICAL();
1023:FreeRTOS/Source/queue.c **** 							}
1024:FreeRTOS/Source/queue.c **** 							else
1025:FreeRTOS/Source/queue.c **** 							{
1026:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1027:FreeRTOS/Source/queue.c **** 							}
1028:FreeRTOS/Source/queue.c **** 						}
1029:FreeRTOS/Source/queue.c **** 						#endif
1030:FreeRTOS/Source/queue.c **** 
1031:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1032:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
1033:FreeRTOS/Source/queue.c **** 					}
1034:FreeRTOS/Source/queue.c **** 					else
1035:FreeRTOS/Source/queue.c **** 					{
1036:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1037:FreeRTOS/Source/queue.c **** 					}
1038:FreeRTOS/Source/queue.c **** 				}
1039:FreeRTOS/Source/queue.c **** 				else
1040:FreeRTOS/Source/queue.c **** 				{
1041:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1042:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1043:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1044:FreeRTOS/Source/queue.c **** 				}
1045:FreeRTOS/Source/queue.c **** 			}
1046:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
1047:FreeRTOS/Source/queue.c **** 		}
1048:FreeRTOS/Source/queue.c **** 	}
1049:FreeRTOS/Source/queue.c **** 
1050:FreeRTOS/Source/queue.c **** 
1051:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
1052:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1053:FreeRTOS/Source/queue.c **** 
1054:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
1055:FreeRTOS/Source/queue.c **** {
1056:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1057:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1058:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1059:FreeRTOS/Source/queue.c **** 
1060:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1061:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1062:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1063:FreeRTOS/Source/queue.c **** 
1064:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1065:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1066:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1067:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1068:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1069:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1070:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1071:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1072:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1073:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1074:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1075:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1076:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1077:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1078:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1079:FreeRTOS/Source/queue.c **** 
1080:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
1081:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
1082:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1083:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1084:FreeRTOS/Source/queue.c **** 	post). */
1085:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1086:FreeRTOS/Source/queue.c **** 	{
1087:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
1088:FreeRTOS/Source/queue.c **** 		{
1089:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1090:FreeRTOS/Source/queue.c **** 
1091:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1092:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1093:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
1094:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
1095:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
1096:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1097:FreeRTOS/Source/queue.c **** 
1098:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1099:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1100:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
1101:FreeRTOS/Source/queue.c **** 			{
1102:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1103:FreeRTOS/Source/queue.c **** 				{
1104:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1105:FreeRTOS/Source/queue.c **** 					{
1106:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1107:FreeRTOS/Source/queue.c **** 						{
1108:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1109:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1110:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1111:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1112:FreeRTOS/Source/queue.c **** 							{
1113:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1114:FreeRTOS/Source/queue.c **** 							}
1115:FreeRTOS/Source/queue.c **** 							else
1116:FreeRTOS/Source/queue.c **** 							{
1117:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1118:FreeRTOS/Source/queue.c **** 							}
1119:FreeRTOS/Source/queue.c **** 						}
1120:FreeRTOS/Source/queue.c **** 						else
1121:FreeRTOS/Source/queue.c **** 						{
1122:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1123:FreeRTOS/Source/queue.c **** 						}
1124:FreeRTOS/Source/queue.c **** 					}
1125:FreeRTOS/Source/queue.c **** 					else
1126:FreeRTOS/Source/queue.c **** 					{
1127:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1128:FreeRTOS/Source/queue.c **** 						{
1129:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1130:FreeRTOS/Source/queue.c **** 							{
1131:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1132:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1133:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1134:FreeRTOS/Source/queue.c **** 								{
1135:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1136:FreeRTOS/Source/queue.c **** 								}
1137:FreeRTOS/Source/queue.c **** 								else
1138:FreeRTOS/Source/queue.c **** 								{
1139:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1140:FreeRTOS/Source/queue.c **** 								}
1141:FreeRTOS/Source/queue.c **** 							}
1142:FreeRTOS/Source/queue.c **** 							else
1143:FreeRTOS/Source/queue.c **** 							{
1144:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1145:FreeRTOS/Source/queue.c **** 							}
1146:FreeRTOS/Source/queue.c **** 						}
1147:FreeRTOS/Source/queue.c **** 						else
1148:FreeRTOS/Source/queue.c **** 						{
1149:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1150:FreeRTOS/Source/queue.c **** 						}
1151:FreeRTOS/Source/queue.c **** 					}
1152:FreeRTOS/Source/queue.c **** 				}
1153:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1154:FreeRTOS/Source/queue.c **** 				{
1155:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1156:FreeRTOS/Source/queue.c **** 					{
1157:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1158:FreeRTOS/Source/queue.c **** 						{
1159:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1160:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1161:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1162:FreeRTOS/Source/queue.c **** 							{
1163:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1164:FreeRTOS/Source/queue.c **** 							}
1165:FreeRTOS/Source/queue.c **** 							else
1166:FreeRTOS/Source/queue.c **** 							{
1167:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1168:FreeRTOS/Source/queue.c **** 							}
1169:FreeRTOS/Source/queue.c **** 						}
1170:FreeRTOS/Source/queue.c **** 						else
1171:FreeRTOS/Source/queue.c **** 						{
1172:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1173:FreeRTOS/Source/queue.c **** 						}
1174:FreeRTOS/Source/queue.c **** 					}
1175:FreeRTOS/Source/queue.c **** 					else
1176:FreeRTOS/Source/queue.c **** 					{
1177:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1178:FreeRTOS/Source/queue.c **** 					}
1179:FreeRTOS/Source/queue.c **** 				}
1180:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1181:FreeRTOS/Source/queue.c **** 			}
1182:FreeRTOS/Source/queue.c **** 			else
1183:FreeRTOS/Source/queue.c **** 			{
1184:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1185:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1186:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
1187:FreeRTOS/Source/queue.c **** 			}
1188:FreeRTOS/Source/queue.c **** 
1189:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1190:FreeRTOS/Source/queue.c **** 		}
1191:FreeRTOS/Source/queue.c **** 		else
1192:FreeRTOS/Source/queue.c **** 		{
1193:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1194:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1195:FreeRTOS/Source/queue.c **** 		}
1196:FreeRTOS/Source/queue.c **** 	}
1197:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1198:FreeRTOS/Source/queue.c **** 
1199:FreeRTOS/Source/queue.c **** 	return xReturn;
1200:FreeRTOS/Source/queue.c **** }
1201:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1202:FreeRTOS/Source/queue.c **** 
1203:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1204:FreeRTOS/Source/queue.c **** {
1205:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1206:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1207:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1208:FreeRTOS/Source/queue.c **** 
1209:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1210:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1211:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1212:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1213:FreeRTOS/Source/queue.c **** 	post). */
1214:FreeRTOS/Source/queue.c **** 
1215:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1216:FreeRTOS/Source/queue.c **** 
1217:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1218:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1219:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1220:FreeRTOS/Source/queue.c **** 
1221:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1222:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1223:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1224:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
1225:FreeRTOS/Source/queue.c **** 
1226:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1227:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1228:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1229:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1230:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1231:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1232:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1233:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1234:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1235:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1236:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1237:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1238:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1239:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1240:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1241:FreeRTOS/Source/queue.c **** 
1242:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1243:FreeRTOS/Source/queue.c **** 	{
1244:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1245:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1246:FreeRTOS/Source/queue.c **** 		space'. */
1247:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1248:FreeRTOS/Source/queue.c **** 		{
1249:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1250:FreeRTOS/Source/queue.c **** 
1251:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1252:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1253:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1254:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1255:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1256:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1257:FreeRTOS/Source/queue.c **** 			++( pxQueue->uxMessagesWaiting );
1258:FreeRTOS/Source/queue.c **** 
1259:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1260:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1261:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
1262:FreeRTOS/Source/queue.c **** 			{
1263:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1264:FreeRTOS/Source/queue.c **** 				{
1265:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1266:FreeRTOS/Source/queue.c **** 					{
1267:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1268:FreeRTOS/Source/queue.c **** 						{
1269:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1270:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1271:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1272:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1273:FreeRTOS/Source/queue.c **** 							{
1274:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1275:FreeRTOS/Source/queue.c **** 							}
1276:FreeRTOS/Source/queue.c **** 							else
1277:FreeRTOS/Source/queue.c **** 							{
1278:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1279:FreeRTOS/Source/queue.c **** 							}
1280:FreeRTOS/Source/queue.c **** 						}
1281:FreeRTOS/Source/queue.c **** 						else
1282:FreeRTOS/Source/queue.c **** 						{
1283:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1284:FreeRTOS/Source/queue.c **** 						}
1285:FreeRTOS/Source/queue.c **** 					}
1286:FreeRTOS/Source/queue.c **** 					else
1287:FreeRTOS/Source/queue.c **** 					{
1288:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1289:FreeRTOS/Source/queue.c **** 						{
1290:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1291:FreeRTOS/Source/queue.c **** 							{
1292:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1293:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1294:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1295:FreeRTOS/Source/queue.c **** 								{
1296:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1297:FreeRTOS/Source/queue.c **** 								}
1298:FreeRTOS/Source/queue.c **** 								else
1299:FreeRTOS/Source/queue.c **** 								{
1300:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1301:FreeRTOS/Source/queue.c **** 								}
1302:FreeRTOS/Source/queue.c **** 							}
1303:FreeRTOS/Source/queue.c **** 							else
1304:FreeRTOS/Source/queue.c **** 							{
1305:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1306:FreeRTOS/Source/queue.c **** 							}
1307:FreeRTOS/Source/queue.c **** 						}
1308:FreeRTOS/Source/queue.c **** 						else
1309:FreeRTOS/Source/queue.c **** 						{
1310:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1311:FreeRTOS/Source/queue.c **** 						}
1312:FreeRTOS/Source/queue.c **** 					}
1313:FreeRTOS/Source/queue.c **** 				}
1314:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1315:FreeRTOS/Source/queue.c **** 				{
1316:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1317:FreeRTOS/Source/queue.c **** 					{
1318:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1319:FreeRTOS/Source/queue.c **** 						{
1320:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1321:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1322:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1323:FreeRTOS/Source/queue.c **** 							{
1324:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1325:FreeRTOS/Source/queue.c **** 							}
1326:FreeRTOS/Source/queue.c **** 							else
1327:FreeRTOS/Source/queue.c **** 							{
1328:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1329:FreeRTOS/Source/queue.c **** 							}
1330:FreeRTOS/Source/queue.c **** 						}
1331:FreeRTOS/Source/queue.c **** 						else
1332:FreeRTOS/Source/queue.c **** 						{
1333:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1334:FreeRTOS/Source/queue.c **** 						}
1335:FreeRTOS/Source/queue.c **** 					}
1336:FreeRTOS/Source/queue.c **** 					else
1337:FreeRTOS/Source/queue.c **** 					{
1338:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1339:FreeRTOS/Source/queue.c **** 					}
1340:FreeRTOS/Source/queue.c **** 				}
1341:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1342:FreeRTOS/Source/queue.c **** 			}
1343:FreeRTOS/Source/queue.c **** 			else
1344:FreeRTOS/Source/queue.c **** 			{
1345:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1346:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1347:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
1348:FreeRTOS/Source/queue.c **** 			}
1349:FreeRTOS/Source/queue.c **** 
1350:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1351:FreeRTOS/Source/queue.c **** 		}
1352:FreeRTOS/Source/queue.c **** 		else
1353:FreeRTOS/Source/queue.c **** 		{
1354:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1355:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
1356:FreeRTOS/Source/queue.c **** 		}
1357:FreeRTOS/Source/queue.c **** 	}
1358:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1359:FreeRTOS/Source/queue.c **** 
1360:FreeRTOS/Source/queue.c **** 	return xReturn;
1361:FreeRTOS/Source/queue.c **** }
1362:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1363:FreeRTOS/Source/queue.c **** 
1364:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1365:FreeRTOS/Source/queue.c **** {
1366:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
1367:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1368:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1369:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1370:FreeRTOS/Source/queue.c **** 
1371:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1372:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1373:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1374:FreeRTOS/Source/queue.c **** 	{
1375:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1376:FreeRTOS/Source/queue.c **** 	}
1377:FreeRTOS/Source/queue.c **** 	#endif
1378:FreeRTOS/Source/queue.c **** 
1379:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1380:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1381:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1382:FreeRTOS/Source/queue.c **** 
1383:FreeRTOS/Source/queue.c **** 	for( ;; )
1384:FreeRTOS/Source/queue.c **** 	{
1385:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
1386:FreeRTOS/Source/queue.c **** 		{
1387:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1388:FreeRTOS/Source/queue.c **** 			must be	the highest priority task wanting to access the queue. */
1389:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1390:FreeRTOS/Source/queue.c **** 			{
1391:FreeRTOS/Source/queue.c **** 				/* Remember the read position in case the queue is only being
1392:FreeRTOS/Source/queue.c **** 				peeked. */
1393:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1394:FreeRTOS/Source/queue.c **** 
1395:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1396:FreeRTOS/Source/queue.c **** 
1397:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
1398:FreeRTOS/Source/queue.c **** 				{
1399:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1400:FreeRTOS/Source/queue.c **** 
1401:FreeRTOS/Source/queue.c **** 					/* Actually removing data, not just peeking. */
1402:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1403:FreeRTOS/Source/queue.c **** 
1404:FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1405:FreeRTOS/Source/queue.c **** 					{
1406:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1407:FreeRTOS/Source/queue.c **** 						{
1408:FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
1409:FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
1410:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
1411:FreeRTOS/Source/queue.c **** 						}
1412:FreeRTOS/Source/queue.c **** 						else
1413:FreeRTOS/Source/queue.c **** 						{
1414:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1415:FreeRTOS/Source/queue.c **** 						}
1416:FreeRTOS/Source/queue.c **** 					}
1417:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1418:FreeRTOS/Source/queue.c **** 
1419:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1420:FreeRTOS/Source/queue.c **** 					{
1421:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1422:FreeRTOS/Source/queue.c **** 						{
1423:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1424:FreeRTOS/Source/queue.c **** 						}
1425:FreeRTOS/Source/queue.c **** 						else
1426:FreeRTOS/Source/queue.c **** 						{
1427:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1428:FreeRTOS/Source/queue.c **** 						}
1429:FreeRTOS/Source/queue.c **** 					}
1430:FreeRTOS/Source/queue.c **** 					else
1431:FreeRTOS/Source/queue.c **** 					{
1432:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1433:FreeRTOS/Source/queue.c **** 					}
1434:FreeRTOS/Source/queue.c **** 				}
1435:FreeRTOS/Source/queue.c **** 				else
1436:FreeRTOS/Source/queue.c **** 				{
1437:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1438:FreeRTOS/Source/queue.c **** 
1439:FreeRTOS/Source/queue.c **** 					/* The data is not being removed, so reset the read
1440:FreeRTOS/Source/queue.c **** 					pointer. */
1441:FreeRTOS/Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1442:FreeRTOS/Source/queue.c **** 
1443:FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1444:FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
1445:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1446:FreeRTOS/Source/queue.c **** 					{
1447:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1448:FreeRTOS/Source/queue.c **** 						{
1449:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1450:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
1451:FreeRTOS/Source/queue.c **** 						}
1452:FreeRTOS/Source/queue.c **** 						else
1453:FreeRTOS/Source/queue.c **** 						{
1454:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1455:FreeRTOS/Source/queue.c **** 						}
1456:FreeRTOS/Source/queue.c **** 					}
1457:FreeRTOS/Source/queue.c **** 					else
1458:FreeRTOS/Source/queue.c **** 					{
1459:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1460:FreeRTOS/Source/queue.c **** 					}
1461:FreeRTOS/Source/queue.c **** 				}
1462:FreeRTOS/Source/queue.c **** 
1463:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
1464:FreeRTOS/Source/queue.c **** 				return pdPASS;
1465:FreeRTOS/Source/queue.c **** 			}
1466:FreeRTOS/Source/queue.c **** 			else
1467:FreeRTOS/Source/queue.c **** 			{
1468:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
1469:FreeRTOS/Source/queue.c **** 				{
1470:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1471:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1472:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
1473:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1474:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
1475:FreeRTOS/Source/queue.c **** 				}
1476:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1477:FreeRTOS/Source/queue.c **** 				{
1478:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1479:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1480:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1481:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1482:FreeRTOS/Source/queue.c **** 				}
1483:FreeRTOS/Source/queue.c **** 				else
1484:FreeRTOS/Source/queue.c **** 				{
1485:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1486:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1487:FreeRTOS/Source/queue.c **** 				}
1488:FreeRTOS/Source/queue.c **** 			}
1489:FreeRTOS/Source/queue.c **** 		}
1490:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
1491:FreeRTOS/Source/queue.c **** 
1492:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1493:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1494:FreeRTOS/Source/queue.c **** 
1495:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
1496:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
1497:FreeRTOS/Source/queue.c **** 
1498:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1499:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1500:FreeRTOS/Source/queue.c **** 		{
1501:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1502:FreeRTOS/Source/queue.c **** 			{
1503:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1504:FreeRTOS/Source/queue.c **** 
1505:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1506:FreeRTOS/Source/queue.c **** 				{
1507:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1508:FreeRTOS/Source/queue.c **** 					{
1509:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1510:FreeRTOS/Source/queue.c **** 						{
1511:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1512:FreeRTOS/Source/queue.c **** 						}
1513:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1514:FreeRTOS/Source/queue.c **** 					}
1515:FreeRTOS/Source/queue.c **** 					else
1516:FreeRTOS/Source/queue.c **** 					{
1517:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1518:FreeRTOS/Source/queue.c **** 					}
1519:FreeRTOS/Source/queue.c **** 				}
1520:FreeRTOS/Source/queue.c **** 				#endif
1521:FreeRTOS/Source/queue.c **** 
1522:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1523:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1524:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1525:FreeRTOS/Source/queue.c **** 				{
1526:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
1527:FreeRTOS/Source/queue.c **** 				}
1528:FreeRTOS/Source/queue.c **** 				else
1529:FreeRTOS/Source/queue.c **** 				{
1530:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1531:FreeRTOS/Source/queue.c **** 				}
1532:FreeRTOS/Source/queue.c **** 			}
1533:FreeRTOS/Source/queue.c **** 			else
1534:FreeRTOS/Source/queue.c **** 			{
1535:FreeRTOS/Source/queue.c **** 				/* Try again. */
1536:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
1537:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
1538:FreeRTOS/Source/queue.c **** 			}
1539:FreeRTOS/Source/queue.c **** 		}
1540:FreeRTOS/Source/queue.c **** 		else
1541:FreeRTOS/Source/queue.c **** 		{
1542:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
1543:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
1544:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1545:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
1546:FreeRTOS/Source/queue.c **** 		}
1547:FreeRTOS/Source/queue.c **** 	}
1548:FreeRTOS/Source/queue.c **** }
1549:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1550:FreeRTOS/Source/queue.c **** 
1551:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1552:FreeRTOS/Source/queue.c **** {
1553:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1554:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1555:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1556:FreeRTOS/Source/queue.c **** 
1557:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1558:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1559:FreeRTOS/Source/queue.c **** 
1560:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1561:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1562:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1563:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1564:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1565:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1566:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1567:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1568:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1569:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1570:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1571:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1572:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1573:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1574:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1575:FreeRTOS/Source/queue.c **** 
1576:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1577:FreeRTOS/Source/queue.c **** 	{
1578:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1579:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1580:FreeRTOS/Source/queue.c **** 		{
1581:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1582:FreeRTOS/Source/queue.c **** 
1583:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1584:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1585:FreeRTOS/Source/queue.c **** 
1586:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1587:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1588:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1589:FreeRTOS/Source/queue.c **** 			locked. */
1590:FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
1591:FreeRTOS/Source/queue.c **** 			{
1592:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1593:FreeRTOS/Source/queue.c **** 				{
1594:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1595:FreeRTOS/Source/queue.c **** 					{
1596:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1597:FreeRTOS/Source/queue.c **** 						force a context switch. */
1598:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
1599:FreeRTOS/Source/queue.c **** 						{
1600:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
1601:FreeRTOS/Source/queue.c **** 						}
1602:FreeRTOS/Source/queue.c **** 						else
1603:FreeRTOS/Source/queue.c **** 						{
1604:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1605:FreeRTOS/Source/queue.c **** 						}
1606:FreeRTOS/Source/queue.c **** 					}
1607:FreeRTOS/Source/queue.c **** 					else
1608:FreeRTOS/Source/queue.c **** 					{
1609:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1610:FreeRTOS/Source/queue.c **** 					}
1611:FreeRTOS/Source/queue.c **** 				}
1612:FreeRTOS/Source/queue.c **** 				else
1613:FreeRTOS/Source/queue.c **** 				{
1614:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1615:FreeRTOS/Source/queue.c **** 				}
1616:FreeRTOS/Source/queue.c **** 			}
1617:FreeRTOS/Source/queue.c **** 			else
1618:FreeRTOS/Source/queue.c **** 			{
1619:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1620:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1621:FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
1622:FreeRTOS/Source/queue.c **** 			}
1623:FreeRTOS/Source/queue.c **** 
1624:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1625:FreeRTOS/Source/queue.c **** 		}
1626:FreeRTOS/Source/queue.c **** 		else
1627:FreeRTOS/Source/queue.c **** 		{
1628:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1629:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1630:FreeRTOS/Source/queue.c **** 		}
1631:FreeRTOS/Source/queue.c **** 	}
1632:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1633:FreeRTOS/Source/queue.c **** 
1634:FreeRTOS/Source/queue.c **** 	return xReturn;
1635:FreeRTOS/Source/queue.c **** }
1636:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1637:FreeRTOS/Source/queue.c **** 
1638:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1639:FreeRTOS/Source/queue.c **** {
1640:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1641:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1642:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1643:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1644:FreeRTOS/Source/queue.c **** 
1645:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1646:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1647:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1648:FreeRTOS/Source/queue.c **** 
1649:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1650:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1651:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1652:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1653:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1654:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1655:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1656:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1657:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1658:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1659:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1660:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1661:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1662:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1663:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1664:FreeRTOS/Source/queue.c **** 
1665:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1666:FreeRTOS/Source/queue.c **** 	{
1667:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1668:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1669:FreeRTOS/Source/queue.c **** 		{
1670:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1671:FreeRTOS/Source/queue.c **** 
1672:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1673:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1674:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1675:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
1676:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1677:FreeRTOS/Source/queue.c **** 
1678:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
1679:FreeRTOS/Source/queue.c **** 		}
1680:FreeRTOS/Source/queue.c **** 		else
1681:FreeRTOS/Source/queue.c **** 		{
1682:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
1683:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1684:FreeRTOS/Source/queue.c **** 		}
1685:FreeRTOS/Source/queue.c **** 	}
1686:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1687:FreeRTOS/Source/queue.c **** 
1688:FreeRTOS/Source/queue.c **** 	return xReturn;
1689:FreeRTOS/Source/queue.c **** }
1690:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1691:FreeRTOS/Source/queue.c **** 
1692:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1693:FreeRTOS/Source/queue.c **** {
1694:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1695:FreeRTOS/Source/queue.c **** 
1696:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1697:FreeRTOS/Source/queue.c **** 
1698:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1699:FreeRTOS/Source/queue.c **** 	{
1700:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1701:FreeRTOS/Source/queue.c **** 	}
1702:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1703:FreeRTOS/Source/queue.c **** 
1704:FreeRTOS/Source/queue.c **** 	return uxReturn;
1705:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1706:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1707:FreeRTOS/Source/queue.c **** 
1708:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1709:FreeRTOS/Source/queue.c **** {
1710:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1711:FreeRTOS/Source/queue.c **** Queue_t *pxQueue;
1712:FreeRTOS/Source/queue.c **** 
1713:FreeRTOS/Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
1714:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1715:FreeRTOS/Source/queue.c **** 
1716:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1717:FreeRTOS/Source/queue.c **** 	{
1718:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
1719:FreeRTOS/Source/queue.c **** 	}
1720:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1721:FreeRTOS/Source/queue.c **** 
1722:FreeRTOS/Source/queue.c **** 	return uxReturn;
1723:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1724:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1725:FreeRTOS/Source/queue.c **** 
1726:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1727:FreeRTOS/Source/queue.c **** {
1728:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1729:FreeRTOS/Source/queue.c **** 
1730:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1731:FreeRTOS/Source/queue.c **** 
1732:FreeRTOS/Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
1733:FreeRTOS/Source/queue.c **** 
1734:FreeRTOS/Source/queue.c **** 	return uxReturn;
1735:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
1736:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1737:FreeRTOS/Source/queue.c **** 
1738:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1739:FreeRTOS/Source/queue.c **** {
1740:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1741:FreeRTOS/Source/queue.c **** 
1742:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1743:FreeRTOS/Source/queue.c **** 
1744:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1745:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1746:FreeRTOS/Source/queue.c **** 	{
1747:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1748:FreeRTOS/Source/queue.c **** 	}
1749:FreeRTOS/Source/queue.c **** 	#endif
1750:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
1751:FreeRTOS/Source/queue.c **** }
1752:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1753:FreeRTOS/Source/queue.c **** 
1754:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1755:FreeRTOS/Source/queue.c **** 
1756:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1757:FreeRTOS/Source/queue.c **** 	{
1758:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1759:FreeRTOS/Source/queue.c **** 	}
1760:FreeRTOS/Source/queue.c **** 
1761:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1762:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1763:FreeRTOS/Source/queue.c **** 
1764:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1765:FreeRTOS/Source/queue.c **** 
1766:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1767:FreeRTOS/Source/queue.c **** 	{
1768:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1769:FreeRTOS/Source/queue.c **** 	}
1770:FreeRTOS/Source/queue.c **** 
1771:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1772:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1773:FreeRTOS/Source/queue.c **** 
1774:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1775:FreeRTOS/Source/queue.c **** 
1776:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1777:FreeRTOS/Source/queue.c **** 	{
1778:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1779:FreeRTOS/Source/queue.c **** 	}
1780:FreeRTOS/Source/queue.c **** 
1781:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1782:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1783:FreeRTOS/Source/queue.c **** 
1784:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1785:FreeRTOS/Source/queue.c **** {
  27              		.loc 1 1785 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 38B5     		push	{r3, r4, r5, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 3, -16
  36              		.cfi_offset 4, -12
  37              		.cfi_offset 5, -8
  38              		.cfi_offset 14, -4
  39              		.loc 1 1785 0
  40 0002 1546     		mov	r5, r2
1786:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
1787:FreeRTOS/Source/queue.c **** 
1788:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  41              		.loc 1 1788 0
  42 0004 026C     		ldr	r2, [r0, #64]
  43              	.LVL1:
1785:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
  44              		.loc 1 1785 0
  45 0006 0446     		mov	r4, r0
  46              		.loc 1 1788 0
  47 0008 3AB9     		cbnz	r2, .L2
1789:FreeRTOS/Source/queue.c **** 	{
1790:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1791:FreeRTOS/Source/queue.c **** 		{
1792:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  48              		.loc 1 1792 0
  49 000a 0568     		ldr	r5, [r0]
  50              	.LVL2:
  51 000c 002D     		cmp	r5, #0
  52 000e 2DD0     		beq	.L14
  53              	.LVL3:
  54              	.L12:
1786:FreeRTOS/Source/queue.c **** 
  55              		.loc 1 1786 0
  56 0010 0020     		movs	r0, #0
  57              	.LVL4:
  58              	.L4:
1793:FreeRTOS/Source/queue.c **** 			{
1794:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1795:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
1796:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
1797:FreeRTOS/Source/queue.c **** 			}
1798:FreeRTOS/Source/queue.c **** 			else
1799:FreeRTOS/Source/queue.c **** 			{
1800:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1801:FreeRTOS/Source/queue.c **** 			}
1802:FreeRTOS/Source/queue.c **** 		}
1803:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1804:FreeRTOS/Source/queue.c **** 	}
1805:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
1806:FreeRTOS/Source/queue.c **** 	{
1807:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
1808:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
1809:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
1810:FreeRTOS/Source/queue.c **** 		{
1811:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
1812:FreeRTOS/Source/queue.c **** 		}
1813:FreeRTOS/Source/queue.c **** 		else
1814:FreeRTOS/Source/queue.c **** 		{
1815:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1816:FreeRTOS/Source/queue.c **** 		}
1817:FreeRTOS/Source/queue.c **** 	}
1818:FreeRTOS/Source/queue.c **** 	else
1819:FreeRTOS/Source/queue.c **** 	{
1820:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
1821:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
1822:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
1823:FreeRTOS/Source/queue.c **** 		{
1824:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
1825:FreeRTOS/Source/queue.c **** 		}
1826:FreeRTOS/Source/queue.c **** 		else
1827:FreeRTOS/Source/queue.c **** 		{
1828:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1829:FreeRTOS/Source/queue.c **** 		}
1830:FreeRTOS/Source/queue.c **** 
1831:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
1832:FreeRTOS/Source/queue.c **** 		{
1833:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1834:FreeRTOS/Source/queue.c **** 			{
1835:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1836:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
1837:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
1838:FreeRTOS/Source/queue.c **** 				correct. */
1839:FreeRTOS/Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
1840:FreeRTOS/Source/queue.c **** 			}
1841:FreeRTOS/Source/queue.c **** 			else
1842:FreeRTOS/Source/queue.c **** 			{
1843:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1844:FreeRTOS/Source/queue.c **** 			}
1845:FreeRTOS/Source/queue.c **** 		}
1846:FreeRTOS/Source/queue.c **** 		else
1847:FreeRTOS/Source/queue.c **** 		{
1848:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1849:FreeRTOS/Source/queue.c **** 		}
1850:FreeRTOS/Source/queue.c **** 	}
1851:FreeRTOS/Source/queue.c **** 
1852:FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
  59              		.loc 1 1852 0
  60 0012 A36B     		ldr	r3, [r4, #56]
  61 0014 0133     		adds	r3, r3, #1
  62 0016 A363     		str	r3, [r4, #56]
1853:FreeRTOS/Source/queue.c **** 
1854:FreeRTOS/Source/queue.c **** 	return xReturn;
1855:FreeRTOS/Source/queue.c **** }
  63              		.loc 1 1855 0
  64 0018 38BD     		pop	{r3, r4, r5, pc}
  65              	.LVL5:
  66              	.L2:
1805:FreeRTOS/Source/queue.c **** 	{
  67              		.loc 1 1805 0
  68 001a 85B9     		cbnz	r5, .L5
1807:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  69              		.loc 1 1807 0
  70 001c 8068     		ldr	r0, [r0, #8]
  71              	.LVL6:
  72 001e FFF7FEFF 		bl	memcpy
  73              	.LVL7:
1808:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
  74              		.loc 1 1808 0
  75 0022 A168     		ldr	r1, [r4, #8]
  76 0024 236C     		ldr	r3, [r4, #64]
1809:FreeRTOS/Source/queue.c **** 		{
  77              		.loc 1 1809 0
  78 0026 6268     		ldr	r2, [r4, #4]
1808:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
  79              		.loc 1 1808 0
  80 0028 0B44     		add	r3, r3, r1
1809:FreeRTOS/Source/queue.c **** 		{
  81              		.loc 1 1809 0
  82 002a 9342     		cmp	r3, r2
1808:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
  83              		.loc 1 1808 0
  84 002c A360     		str	r3, [r4, #8]
1809:FreeRTOS/Source/queue.c **** 		{
  85              		.loc 1 1809 0
  86 002e EFD3     		bcc	.L12
1811:FreeRTOS/Source/queue.c **** 		}
  87              		.loc 1 1811 0
  88 0030 2368     		ldr	r3, [r4]
  89 0032 A360     		str	r3, [r4, #8]
1852:FreeRTOS/Source/queue.c **** 
  90              		.loc 1 1852 0
  91 0034 A36B     		ldr	r3, [r4, #56]
  92 0036 0133     		adds	r3, r3, #1
1786:FreeRTOS/Source/queue.c **** 
  93              		.loc 1 1786 0
  94 0038 2846     		mov	r0, r5
  95              	.LVL8:
1852:FreeRTOS/Source/queue.c **** 
  96              		.loc 1 1852 0
  97 003a A363     		str	r3, [r4, #56]
  98              		.loc 1 1855 0
  99 003c 38BD     		pop	{r3, r4, r5, pc}
 100              	.LVL9:
 101              	.L5:
1820:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 102              		.loc 1 1820 0
 103 003e C068     		ldr	r0, [r0, #12]
 104              	.LVL10:
 105 0040 FFF7FEFF 		bl	memcpy
 106              	.LVL11:
1821:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 107              		.loc 1 1821 0
 108 0044 236C     		ldr	r3, [r4, #64]
 109 0046 E268     		ldr	r2, [r4, #12]
1822:FreeRTOS/Source/queue.c **** 		{
 110              		.loc 1 1822 0
 111 0048 2168     		ldr	r1, [r4]
1821:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 112              		.loc 1 1821 0
 113 004a 5B42     		negs	r3, r3
 114 004c 1A44     		add	r2, r2, r3
1822:FreeRTOS/Source/queue.c **** 		{
 115              		.loc 1 1822 0
 116 004e 8A42     		cmp	r2, r1
1821:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 117              		.loc 1 1821 0
 118 0050 E260     		str	r2, [r4, #12]
1822:FreeRTOS/Source/queue.c **** 		{
 119              		.loc 1 1822 0
 120 0052 02D2     		bcs	.L7
1824:FreeRTOS/Source/queue.c **** 		}
 121              		.loc 1 1824 0
 122 0054 6268     		ldr	r2, [r4, #4]
 123 0056 1344     		add	r3, r3, r2
 124 0058 E360     		str	r3, [r4, #12]
 125              	.L7:
1831:FreeRTOS/Source/queue.c **** 		{
 126              		.loc 1 1831 0
 127 005a 022D     		cmp	r5, #2
 128 005c D8D1     		bne	.L12
1833:FreeRTOS/Source/queue.c **** 			{
 129              		.loc 1 1833 0
 130 005e A36B     		ldr	r3, [r4, #56]
 131 0060 002B     		cmp	r3, #0
 132 0062 D5D0     		beq	.L12
1839:FreeRTOS/Source/queue.c **** 			}
 133              		.loc 1 1839 0
 134 0064 A36B     		ldr	r3, [r4, #56]
 135 0066 013B     		subs	r3, r3, #1
 136 0068 A363     		str	r3, [r4, #56]
 137 006a D1E7     		b	.L12
 138              	.LVL12:
 139              	.L14:
1795:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 140              		.loc 1 1795 0
 141 006c 4068     		ldr	r0, [r0, #4]
 142              	.LVL13:
 143 006e FFF7FEFF 		bl	xTaskPriorityDisinherit
 144              	.LVL14:
1796:FreeRTOS/Source/queue.c **** 			}
 145              		.loc 1 1796 0
 146 0072 6560     		str	r5, [r4, #4]
 147 0074 CDE7     		b	.L4
 148              		.cfi_endproc
 149              	.LFE123:
 151 0076 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 152              		.align	2
 153              		.thumb
 154              		.thumb_func
 156              	prvCopyDataFromQueue:
 157              	.LFB124:
1856:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/Source/queue.c **** 
1858:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1859:FreeRTOS/Source/queue.c **** {
 158              		.loc 1 1859 0
 159              		.cfi_startproc
 160              		@ args = 0, pretend = 0, frame = 0
 161              		@ frame_needed = 0, uses_anonymous_args = 0
 162              		@ link register save eliminated.
 163              	.LVL15:
1860:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 164              		.loc 1 1860 0
 165 0000 026C     		ldr	r2, [r0, #64]
 166 0002 72B1     		cbz	r2, .L19
1859:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 167              		.loc 1 1859 0
 168 0004 10B4     		push	{r4}
 169              	.LCFI1:
 170              		.cfi_def_cfa_offset 4
 171              		.cfi_offset 4, -4
1861:FreeRTOS/Source/queue.c **** 	{
1862:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 172              		.loc 1 1862 0
 173 0006 C368     		ldr	r3, [r0, #12]
1863:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 174              		.loc 1 1863 0
 175 0008 4468     		ldr	r4, [r0, #4]
1862:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 176              		.loc 1 1862 0
 177 000a 1344     		add	r3, r3, r2
 178              		.loc 1 1863 0
 179 000c A342     		cmp	r3, r4
1862:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 180              		.loc 1 1862 0
 181 000e C360     		str	r3, [r0, #12]
1864:FreeRTOS/Source/queue.c **** 		{
1865:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 182              		.loc 1 1865 0
 183 0010 24BF     		itt	cs
 184 0012 0368     		ldrcs	r3, [r0]
 185 0014 C360     		strcs	r3, [r0, #12]
1866:FreeRTOS/Source/queue.c **** 		}
1867:FreeRTOS/Source/queue.c **** 		else
1868:FreeRTOS/Source/queue.c **** 		{
1869:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1870:FreeRTOS/Source/queue.c **** 		}
1871:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
1872:FreeRTOS/Source/queue.c **** 	}
1873:FreeRTOS/Source/queue.c **** }
 186              		.loc 1 1873 0
 187 0016 5DF8044B 		ldr	r4, [sp], #4
 188              	.LCFI2:
 189              		.cfi_restore 4
 190              		.cfi_def_cfa_offset 0
1871:FreeRTOS/Source/queue.c **** 	}
 191              		.loc 1 1871 0
 192 001a 0846     		mov	r0, r1
 193              	.LVL16:
 194 001c 1946     		mov	r1, r3
 195              	.LVL17:
 196 001e FFF7FEBF 		b	memcpy
 197              	.LVL18:
 198              	.L19:
 199 0022 7047     		bx	lr
 200              		.cfi_endproc
 201              	.LFE124:
 203              		.section	.text.prvUnlockQueue,"ax",%progbits
 204              		.align	2
 205              		.thumb
 206              		.thumb_func
 208              	prvUnlockQueue:
 209              	.LFB125:
1874:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1875:FreeRTOS/Source/queue.c **** 
1876:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1877:FreeRTOS/Source/queue.c **** {
 210              		.loc 1 1877 0
 211              		.cfi_startproc
 212              		@ args = 0, pretend = 0, frame = 0
 213              		@ frame_needed = 0, uses_anonymous_args = 0
 214              	.LVL19:
 215 0000 38B5     		push	{r3, r4, r5, lr}
 216              	.LCFI3:
 217              		.cfi_def_cfa_offset 16
 218              		.cfi_offset 3, -16
 219              		.cfi_offset 4, -12
 220              		.cfi_offset 5, -8
 221              		.cfi_offset 14, -4
 222              		.loc 1 1877 0
 223 0002 0446     		mov	r4, r0
1878:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1879:FreeRTOS/Source/queue.c **** 
1880:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1881:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1882:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1883:FreeRTOS/Source/queue.c **** 	updated. */
1884:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 224              		.loc 1 1884 0
 225 0004 FFF7FEFF 		bl	vPortEnterCritical
 226              	.LVL20:
1885:FreeRTOS/Source/queue.c **** 	{
1886:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1887:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 227              		.loc 1 1887 0
 228 0008 A36C     		ldr	r3, [r4, #72]
 229 000a 002B     		cmp	r3, #0
 230 000c 14DD     		ble	.L24
1888:FreeRTOS/Source/queue.c **** 		{
1889:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1890:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1891:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1892:FreeRTOS/Source/queue.c **** 			{
1893:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1894:FreeRTOS/Source/queue.c **** 				{
1895:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1896:FreeRTOS/Source/queue.c **** 					{
1897:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1898:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1899:FreeRTOS/Source/queue.c **** 						A context switch is required. */
1900:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1901:FreeRTOS/Source/queue.c **** 					}
1902:FreeRTOS/Source/queue.c **** 					else
1903:FreeRTOS/Source/queue.c **** 					{
1904:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1905:FreeRTOS/Source/queue.c **** 					}
1906:FreeRTOS/Source/queue.c **** 				}
1907:FreeRTOS/Source/queue.c **** 				else
1908:FreeRTOS/Source/queue.c **** 				{
1909:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1910:FreeRTOS/Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1911:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1912:FreeRTOS/Source/queue.c **** 					{
1913:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1914:FreeRTOS/Source/queue.c **** 						{
1915:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1916:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1917:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
1918:FreeRTOS/Source/queue.c **** 						}
1919:FreeRTOS/Source/queue.c **** 						else
1920:FreeRTOS/Source/queue.c **** 						{
1921:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1922:FreeRTOS/Source/queue.c **** 						}
1923:FreeRTOS/Source/queue.c **** 					}
1924:FreeRTOS/Source/queue.c **** 					else
1925:FreeRTOS/Source/queue.c **** 					{
1926:FreeRTOS/Source/queue.c **** 						break;
1927:FreeRTOS/Source/queue.c **** 					}
1928:FreeRTOS/Source/queue.c **** 				}
1929:FreeRTOS/Source/queue.c **** 			}
1930:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1931:FreeRTOS/Source/queue.c **** 			{
1932:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1933:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1934:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 231              		.loc 1 1934 0
 232 000e 636A     		ldr	r3, [r4, #36]
 233 0010 93B1     		cbz	r3, .L24
 234 0012 04F12405 		add	r5, r4, #36
 235 0016 07E0     		b	.L25
 236              	.L26:
1935:FreeRTOS/Source/queue.c **** 				{
1936:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1937:FreeRTOS/Source/queue.c **** 					{
1938:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1939:FreeRTOS/Source/queue.c **** 						context	switch is required. */
1940:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
1941:FreeRTOS/Source/queue.c **** 					}
1942:FreeRTOS/Source/queue.c **** 					else
1943:FreeRTOS/Source/queue.c **** 					{
1944:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1945:FreeRTOS/Source/queue.c **** 					}
1946:FreeRTOS/Source/queue.c **** 				}
1947:FreeRTOS/Source/queue.c **** 				else
1948:FreeRTOS/Source/queue.c **** 				{
1949:FreeRTOS/Source/queue.c **** 					break;
1950:FreeRTOS/Source/queue.c **** 				}
1951:FreeRTOS/Source/queue.c **** 			}
1952:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1953:FreeRTOS/Source/queue.c **** 
1954:FreeRTOS/Source/queue.c **** 			--( pxQueue->xTxLock );
 237              		.loc 1 1954 0
 238 0018 A36C     		ldr	r3, [r4, #72]
 239 001a 013B     		subs	r3, r3, #1
 240 001c A364     		str	r3, [r4, #72]
1887:FreeRTOS/Source/queue.c **** 		{
 241              		.loc 1 1887 0
 242 001e A36C     		ldr	r3, [r4, #72]
 243 0020 002B     		cmp	r3, #0
 244 0022 09DD     		ble	.L24
1934:FreeRTOS/Source/queue.c **** 				{
 245              		.loc 1 1934 0
 246 0024 636A     		ldr	r3, [r4, #36]
 247 0026 3BB1     		cbz	r3, .L24
 248              	.L25:
1936:FreeRTOS/Source/queue.c **** 					{
 249              		.loc 1 1936 0
 250 0028 2846     		mov	r0, r5
 251 002a FFF7FEFF 		bl	xTaskRemoveFromEventList
 252              	.LVL21:
 253 002e 0028     		cmp	r0, #0
 254 0030 F2D0     		beq	.L26
1940:FreeRTOS/Source/queue.c **** 					}
 255              		.loc 1 1940 0
 256 0032 FFF7FEFF 		bl	vTaskMissedYield
 257              	.LVL22:
 258 0036 EFE7     		b	.L26
 259              	.L24:
1955:FreeRTOS/Source/queue.c **** 		}
1956:FreeRTOS/Source/queue.c **** 
1957:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 260              		.loc 1 1957 0
 261 0038 4FF0FF33 		mov	r3, #-1
 262 003c A364     		str	r3, [r4, #72]
1958:FreeRTOS/Source/queue.c **** 	}
1959:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 263              		.loc 1 1959 0
 264 003e FFF7FEFF 		bl	vPortExitCritical
 265              	.LVL23:
1960:FreeRTOS/Source/queue.c **** 
1961:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1962:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 266              		.loc 1 1962 0
 267 0042 FFF7FEFF 		bl	vPortEnterCritical
 268              	.LVL24:
1963:FreeRTOS/Source/queue.c **** 	{
1964:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 269              		.loc 1 1964 0
 270 0046 636C     		ldr	r3, [r4, #68]
 271 0048 002B     		cmp	r3, #0
 272 004a 14DD     		ble	.L23
1965:FreeRTOS/Source/queue.c **** 		{
1966:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 273              		.loc 1 1966 0
 274 004c 2369     		ldr	r3, [r4, #16]
 275 004e 93B1     		cbz	r3, .L23
 276 0050 04F11005 		add	r5, r4, #16
 277 0054 07E0     		b	.L28
 278              	.L29:
1967:FreeRTOS/Source/queue.c **** 			{
1968:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1969:FreeRTOS/Source/queue.c **** 				{
1970:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
1971:FreeRTOS/Source/queue.c **** 				}
1972:FreeRTOS/Source/queue.c **** 				else
1973:FreeRTOS/Source/queue.c **** 				{
1974:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1975:FreeRTOS/Source/queue.c **** 				}
1976:FreeRTOS/Source/queue.c **** 
1977:FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 279              		.loc 1 1977 0
 280 0056 636C     		ldr	r3, [r4, #68]
 281 0058 013B     		subs	r3, r3, #1
 282 005a 6364     		str	r3, [r4, #68]
1964:FreeRTOS/Source/queue.c **** 		{
 283              		.loc 1 1964 0
 284 005c 636C     		ldr	r3, [r4, #68]
 285 005e 002B     		cmp	r3, #0
 286 0060 09DD     		ble	.L23
1966:FreeRTOS/Source/queue.c **** 			{
 287              		.loc 1 1966 0
 288 0062 2369     		ldr	r3, [r4, #16]
 289 0064 3BB1     		cbz	r3, .L23
 290              	.L28:
1968:FreeRTOS/Source/queue.c **** 				{
 291              		.loc 1 1968 0
 292 0066 2846     		mov	r0, r5
 293 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 294              	.LVL25:
 295 006c 0028     		cmp	r0, #0
 296 006e F2D0     		beq	.L29
1970:FreeRTOS/Source/queue.c **** 				}
 297              		.loc 1 1970 0
 298 0070 FFF7FEFF 		bl	vTaskMissedYield
 299              	.LVL26:
 300 0074 EFE7     		b	.L29
 301              	.L23:
1978:FreeRTOS/Source/queue.c **** 			}
1979:FreeRTOS/Source/queue.c **** 			else
1980:FreeRTOS/Source/queue.c **** 			{
1981:FreeRTOS/Source/queue.c **** 				break;
1982:FreeRTOS/Source/queue.c **** 			}
1983:FreeRTOS/Source/queue.c **** 		}
1984:FreeRTOS/Source/queue.c **** 
1985:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 302              		.loc 1 1985 0
 303 0076 4FF0FF33 		mov	r3, #-1
 304 007a 6364     		str	r3, [r4, #68]
1986:FreeRTOS/Source/queue.c **** 	}
1987:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
1988:FreeRTOS/Source/queue.c **** }
 305              		.loc 1 1988 0
 306 007c BDE83840 		pop	{r3, r4, r5, lr}
 307              	.LCFI4:
 308              		.cfi_restore 14
 309              		.cfi_restore 5
 310              		.cfi_restore 4
 311              		.cfi_restore 3
 312              		.cfi_def_cfa_offset 0
 313              	.LVL27:
1987:FreeRTOS/Source/queue.c **** }
 314              		.loc 1 1987 0
 315 0080 FFF7FEBF 		b	vPortExitCritical
 316              	.LVL28:
 317              		.cfi_endproc
 318              	.LFE125:
 320              		.section	.text.xQueueGenericReset,"ax",%progbits
 321              		.align	2
 322              		.global	xQueueGenericReset
 323              		.thumb
 324              		.thumb_func
 326              	xQueueGenericReset:
 327              	.LFB110:
 261:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 328              		.loc 1 261 0
 329              		.cfi_startproc
 330              		@ args = 0, pretend = 0, frame = 0
 331              		@ frame_needed = 0, uses_anonymous_args = 0
 332              	.LVL29:
 333 0000 38B5     		push	{r3, r4, r5, lr}
 334              	.LCFI5:
 335              		.cfi_def_cfa_offset 16
 336              		.cfi_offset 3, -16
 337              		.cfi_offset 4, -12
 338              		.cfi_offset 5, -8
 339              		.cfi_offset 14, -4
 261:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 340              		.loc 1 261 0
 341 0002 0446     		mov	r4, r0
 342              	.LVL30:
 343 0004 0D46     		mov	r5, r1
 266:FreeRTOS/Source/queue.c **** 	{
 344              		.loc 1 266 0
 345 0006 FFF7FEFF 		bl	vPortEnterCritical
 346              	.LVL31:
 268:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 347              		.loc 1 268 0
 348 000a 236C     		ldr	r3, [r4, #64]
 349 000c E26B     		ldr	r2, [r4, #60]
 350 000e 2068     		ldr	r0, [r4]
 270:FreeRTOS/Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
 351              		.loc 1 270 0
 352 0010 A060     		str	r0, [r4, #8]
 268:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 353              		.loc 1 268 0
 354 0012 02FB03F2 		mul	r2, r2, r3
 271:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 355              		.loc 1 271 0
 356 0016 D31A     		subs	r3, r2, r3
 357 0018 0344     		add	r3, r3, r0
 268:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 358              		.loc 1 268 0
 359 001a 0244     		add	r2, r2, r0
 269:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 360              		.loc 1 269 0
 361 001c 0021     		movs	r1, #0
 272:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 362              		.loc 1 272 0
 363 001e 4FF0FF30 		mov	r0, #-1
 269:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
 364              		.loc 1 269 0
 365 0022 A163     		str	r1, [r4, #56]
 268:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 366              		.loc 1 268 0
 367 0024 6260     		str	r2, [r4, #4]
 272:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 368              		.loc 1 272 0
 369 0026 6064     		str	r0, [r4, #68]
 271:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 370              		.loc 1 271 0
 371 0028 E360     		str	r3, [r4, #12]
 273:FreeRTOS/Source/queue.c **** 
 372              		.loc 1 273 0
 373 002a A064     		str	r0, [r4, #72]
 275:FreeRTOS/Source/queue.c **** 		{
 374              		.loc 1 275 0
 375 002c 75B9     		cbnz	r5, .L51
 282:FreeRTOS/Source/queue.c **** 			{
 376              		.loc 1 282 0
 377 002e 2369     		ldr	r3, [r4, #16]
 378 0030 1BB9     		cbnz	r3, .L56
 379              	.L53:
 305:FreeRTOS/Source/queue.c **** 
 380              		.loc 1 305 0
 381 0032 FFF7FEFF 		bl	vPortExitCritical
 382              	.LVL32:
 310:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 383              		.loc 1 310 0
 384 0036 0120     		movs	r0, #1
 385 0038 38BD     		pop	{r3, r4, r5, pc}
 386              	.LVL33:
 387              	.L56:
 284:FreeRTOS/Source/queue.c **** 				{
 388              		.loc 1 284 0
 389 003a 04F11000 		add	r0, r4, #16
 390 003e FFF7FEFF 		bl	xTaskRemoveFromEventList
 391              	.LVL34:
 392 0042 0128     		cmp	r0, #1
 393 0044 F5D1     		bne	.L53
 286:FreeRTOS/Source/queue.c **** 				}
 394              		.loc 1 286 0
 395 0046 FFF7FEFF 		bl	vPortYieldFromISR
 396              	.LVL35:
 397 004a F2E7     		b	.L53
 398              	.L51:
 301:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 399              		.loc 1 301 0
 400 004c 04F11000 		add	r0, r4, #16
 401 0050 FFF7FEFF 		bl	vListInitialise
 402              	.LVL36:
 302:FreeRTOS/Source/queue.c **** 		}
 403              		.loc 1 302 0
 404 0054 04F12400 		add	r0, r4, #36
 405 0058 FFF7FEFF 		bl	vListInitialise
 406              	.LVL37:
 305:FreeRTOS/Source/queue.c **** 
 407              		.loc 1 305 0
 408 005c FFF7FEFF 		bl	vPortExitCritical
 409              	.LVL38:
 310:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 410              		.loc 1 310 0
 411 0060 0120     		movs	r0, #1
 412 0062 38BD     		pop	{r3, r4, r5, pc}
 413              		.cfi_endproc
 414              	.LFE110:
 416              		.section	.text.xQueueGenericCreate,"ax",%progbits
 417              		.align	2
 418              		.global	xQueueGenericCreate
 419              		.thumb
 420              		.thumb_func
 422              	xQueueGenericCreate:
 423              	.LFB111:
 314:FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 424              		.loc 1 314 0
 425              		.cfi_startproc
 426              		@ args = 0, pretend = 0, frame = 0
 427              		@ frame_needed = 0, uses_anonymous_args = 0
 428              	.LVL39:
 429 0000 70B5     		push	{r4, r5, r6, lr}
 430              	.LCFI6:
 431              		.cfi_def_cfa_offset 16
 432              		.cfi_offset 4, -16
 433              		.cfi_offset 5, -12
 434              		.cfi_offset 6, -8
 435              		.cfi_offset 14, -4
 314:FreeRTOS/Source/queue.c **** Queue_t *pxNewQueue;
 436              		.loc 1 314 0
 437 0002 0646     		mov	r6, r0
 325:FreeRTOS/Source/queue.c **** 	{
 438              		.loc 1 325 0
 439 0004 0D46     		mov	r5, r1
 440 0006 51B1     		cbz	r1, .L58
 441              	.LVL40:
 334:FreeRTOS/Source/queue.c **** 	}
 442              		.loc 1 334 0
 443 0008 00FB01F0 		mul	r0, r0, r1
 444              	.LVL41:
 338:FreeRTOS/Source/queue.c **** 
 445              		.loc 1 338 0
 446 000c 4D30     		adds	r0, r0, #77
 447 000e FFF7FEFF 		bl	malloc
 448              	.LVL42:
 340:FreeRTOS/Source/queue.c **** 	{
 449              		.loc 1 340 0
 450 0012 0446     		mov	r4, r0
 451 0014 88B1     		cbz	r0, .L63
 354:FreeRTOS/Source/queue.c **** 		}
 452              		.loc 1 354 0
 453 0016 00F14C03 		add	r3, r0, #76
 454 001a 0360     		str	r3, [r0]
 455 001c 05E0     		b	.L61
 456              	.LVL43:
 457              	.L58:
 338:FreeRTOS/Source/queue.c **** 
 458              		.loc 1 338 0
 459 001e 4C20     		movs	r0, #76
 460              	.LVL44:
 461 0020 FFF7FEFF 		bl	malloc
 462              	.LVL45:
 340:FreeRTOS/Source/queue.c **** 	{
 463              		.loc 1 340 0
 464 0024 0446     		mov	r4, r0
 465 0026 40B1     		cbz	r0, .L63
 348:FreeRTOS/Source/queue.c **** 		}
 466              		.loc 1 348 0
 467 0028 2460     		str	r4, [r4]
 468              	.LVL46:
 469              	.L61:
 359:FreeRTOS/Source/queue.c **** 		pxNewQueue->uxItemSize = uxItemSize;
 470              		.loc 1 359 0
 471 002a E663     		str	r6, [r4, #60]
 360:FreeRTOS/Source/queue.c **** 		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 472              		.loc 1 360 0
 473 002c 2564     		str	r5, [r4, #64]
 361:FreeRTOS/Source/queue.c **** 
 474              		.loc 1 361 0
 475 002e 2046     		mov	r0, r4
 476              	.LVL47:
 477 0030 0121     		movs	r1, #1
 478 0032 FFF7FEFF 		bl	xQueueGenericReset
 479              	.LVL48:
 480              	.L64:
 386:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 481              		.loc 1 386 0
 482 0036 2046     		mov	r0, r4
 483 0038 70BD     		pop	{r4, r5, r6, pc}
 484              	.LVL49:
 485              	.L63:
 317:FreeRTOS/Source/queue.c **** 
 486              		.loc 1 317 0
 487 003a 0024     		movs	r4, #0
 488 003c FBE7     		b	.L64
 489              		.cfi_endproc
 490              	.LFE111:
 492 003e 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 493              		.align	2
 494              		.global	xQueueGenericSend
 495              		.thumb
 496              		.thumb_func
 498              	xQueueGenericSend:
 499              	.LFB113:
 610:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 500              		.loc 1 610 0
 501              		.cfi_startproc
 502              		@ args = 0, pretend = 0, frame = 16
 503              		@ frame_needed = 0, uses_anonymous_args = 0
 504              	.LVL50:
 505 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 506              	.LCFI7:
 507              		.cfi_def_cfa_offset 28
 508              		.cfi_offset 4, -28
 509              		.cfi_offset 5, -24
 510              		.cfi_offset 6, -20
 511              		.cfi_offset 7, -16
 512              		.cfi_offset 8, -12
 513              		.cfi_offset 9, -8
 514              		.cfi_offset 14, -4
 515 0004 85B0     		sub	sp, sp, #20
 516              	.LCFI8:
 517              		.cfi_def_cfa_offset 48
 611:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 518              		.loc 1 611 0
 519 0006 0026     		movs	r6, #0
 610:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 520              		.loc 1 610 0
 521 0008 0446     		mov	r4, r0
 522              	.LVL51:
 523 000a 8946     		mov	r9, r1
 524 000c 0192     		str	r2, [sp, #4]
 525 000e 1F46     		mov	r7, r3
 760:FreeRTOS/Source/queue.c **** 
 526              		.loc 1 760 0
 527 0010 B046     		mov	r8, r6
 528 0012 25E0     		b	.L67
 529              	.LVL52:
 530              	.L76:
 754:FreeRTOS/Source/queue.c **** 
 531              		.loc 1 754 0
 532 0014 FFF7FEFF 		bl	vPortExitCritical
 533              	.LVL53:
 759:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 534              		.loc 1 759 0
 535 0018 FFF7FEFF 		bl	vTaskSuspendAll
 536              	.LVL54:
 760:FreeRTOS/Source/queue.c **** 
 537              		.loc 1 760 0
 538 001c FFF7FEFF 		bl	vPortEnterCritical
 539              	.LVL55:
 540 0020 636C     		ldr	r3, [r4, #68]
 541 0022 0133     		adds	r3, r3, #1
 542 0024 08BF     		it	eq
 543 0026 C4F84480 		streq	r8, [r4, #68]
 544 002a A36C     		ldr	r3, [r4, #72]
 545 002c 0133     		adds	r3, r3, #1
 546 002e 08BF     		it	eq
 547 0030 C4F84880 		streq	r8, [r4, #72]
 548 0034 FFF7FEFF 		bl	vPortExitCritical
 549              	.LVL56:
 763:FreeRTOS/Source/queue.c **** 		{
 550              		.loc 1 763 0
 551 0038 02A8     		add	r0, sp, #8
 552 003a 01A9     		add	r1, sp, #4
 553              	.LVL57:
 554 003c FFF7FEFF 		bl	xTaskCheckForTimeOut
 555              	.LVL58:
 556 0040 0028     		cmp	r0, #0
 557 0042 42D1     		bne	.L79
 558              	.LVL59:
 559              	.LBB6:
 560              	.LBB7:
1989:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1990:FreeRTOS/Source/queue.c **** 
1991:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1992:FreeRTOS/Source/queue.c **** {
1993:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1994:FreeRTOS/Source/queue.c **** 
1995:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
1996:FreeRTOS/Source/queue.c **** 	{
1997:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
1998:FreeRTOS/Source/queue.c **** 		{
1999:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2000:FreeRTOS/Source/queue.c **** 		}
2001:FreeRTOS/Source/queue.c **** 		else
2002:FreeRTOS/Source/queue.c **** 		{
2003:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2004:FreeRTOS/Source/queue.c **** 		}
2005:FreeRTOS/Source/queue.c **** 	}
2006:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
2007:FreeRTOS/Source/queue.c **** 
2008:FreeRTOS/Source/queue.c **** 	return xReturn;
2009:FreeRTOS/Source/queue.c **** }
2010:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2011:FreeRTOS/Source/queue.c **** 
2012:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2013:FreeRTOS/Source/queue.c **** {
2014:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2015:FreeRTOS/Source/queue.c **** 
2016:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2017:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
2018:FreeRTOS/Source/queue.c **** 	{
2019:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2020:FreeRTOS/Source/queue.c **** 	}
2021:FreeRTOS/Source/queue.c **** 	else
2022:FreeRTOS/Source/queue.c **** 	{
2023:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2024:FreeRTOS/Source/queue.c **** 	}
2025:FreeRTOS/Source/queue.c **** 
2026:FreeRTOS/Source/queue.c **** 	return xReturn;
2027:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2028:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2029:FreeRTOS/Source/queue.c **** 
2030:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2031:FreeRTOS/Source/queue.c **** {
2032:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2033:FreeRTOS/Source/queue.c **** 
2034:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 561              		.loc 1 2034 0
 562 0044 FFF7FEFF 		bl	vPortEnterCritical
 563              	.LVL60:
2035:FreeRTOS/Source/queue.c **** 	{
2036:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 564              		.loc 1 2036 0
 565 0048 A26B     		ldr	r2, [r4, #56]
 566 004a E36B     		ldr	r3, [r4, #60]
 567 004c 9A42     		cmp	r2, r3
 568 004e 17D0     		beq	.L93
 569              	.LVL61:
2037:FreeRTOS/Source/queue.c **** 		{
2038:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
2039:FreeRTOS/Source/queue.c **** 		}
2040:FreeRTOS/Source/queue.c **** 		else
2041:FreeRTOS/Source/queue.c **** 		{
2042:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
2043:FreeRTOS/Source/queue.c **** 		}
2044:FreeRTOS/Source/queue.c **** 	}
2045:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 570              		.loc 1 2045 0
 571 0050 FFF7FEFF 		bl	vPortExitCritical
 572              	.LVL62:
 573              	.LBE7:
 574              	.LBE6:
 790:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 575              		.loc 1 790 0
 576 0054 2046     		mov	r0, r4
 577 0056 FFF7FEFF 		bl	prvUnlockQueue
 578              	.LVL63:
 791:FreeRTOS/Source/queue.c **** 			}
 579              		.loc 1 791 0
 580 005a FFF7FEFF 		bl	xTaskResumeAll
 581              	.LVL64:
 582              	.L82:
 583 005e 0126     		movs	r6, #1
 584              	.LVL65:
 585              	.L67:
 630:FreeRTOS/Source/queue.c **** 		{
 586              		.loc 1 630 0
 587 0060 FFF7FEFF 		bl	vPortEnterCritical
 588              	.LVL66:
 636:FreeRTOS/Source/queue.c **** 			{
 589              		.loc 1 636 0
 590 0064 A26B     		ldr	r2, [r4, #56]
 591 0066 E36B     		ldr	r3, [r4, #60]
 592 0068 9A42     		cmp	r2, r3
 593 006a 1AD3     		bcc	.L68
 636:FreeRTOS/Source/queue.c **** 			{
 594              		.loc 1 636 0 is_stmt 0 discriminator 1
 595 006c 022F     		cmp	r7, #2
 596 006e 18D0     		beq	.L68
 729:FreeRTOS/Source/queue.c **** 				{
 597              		.loc 1 729 0 is_stmt 1
 598 0070 019D     		ldr	r5, [sp, #4]
 599 0072 25B3     		cbz	r5, .L94
 740:FreeRTOS/Source/queue.c **** 				{
 600              		.loc 1 740 0
 601 0074 002E     		cmp	r6, #0
 602 0076 CDD1     		bne	.L76
 744:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 603              		.loc 1 744 0
 604 0078 02A8     		add	r0, sp, #8
 605 007a FFF7FEFF 		bl	vTaskSetTimeOutState
 606              	.LVL67:
 607 007e C9E7     		b	.L76
 608              	.LVL68:
 609              	.L93:
 610              	.LBB9:
 611              	.LBB8:
 612              		.loc 1 2045 0
 613 0080 FFF7FEFF 		bl	vPortExitCritical
 614              	.LVL69:
 615              	.LBE8:
 616              	.LBE9:
 768:FreeRTOS/Source/queue.c **** 
 617              		.loc 1 768 0
 618 0084 04F11000 		add	r0, r4, #16
 619 0088 0199     		ldr	r1, [sp, #4]
 620 008a FFF7FEFF 		bl	vTaskPlaceOnEventList
 621              	.LVL70:
 775:FreeRTOS/Source/queue.c **** 
 622              		.loc 1 775 0
 623 008e 2046     		mov	r0, r4
 624 0090 FFF7FEFF 		bl	prvUnlockQueue
 625              	.LVL71:
 782:FreeRTOS/Source/queue.c **** 				{
 626              		.loc 1 782 0
 627 0094 FFF7FEFF 		bl	xTaskResumeAll
 628              	.LVL72:
 629 0098 0028     		cmp	r0, #0
 630 009a E0D1     		bne	.L82
 784:FreeRTOS/Source/queue.c **** 				}
 631              		.loc 1 784 0
 632 009c FFF7FEFF 		bl	vPortYieldFromISR
 633              	.LVL73:
 634 00a0 DDE7     		b	.L82
 635              	.LVL74:
 636              	.L68:
 639:FreeRTOS/Source/queue.c **** 
 637              		.loc 1 639 0
 638 00a2 4946     		mov	r1, r9
 639 00a4 3A46     		mov	r2, r7
 640 00a6 2046     		mov	r0, r4
 641 00a8 FFF7FEFF 		bl	prvCopyDataToQueue
 642              	.LVL75:
 694:FreeRTOS/Source/queue.c **** 					{
 643              		.loc 1 694 0
 644 00ac 636A     		ldr	r3, [r4, #36]
 645 00ae ABB9     		cbnz	r3, .L95
 709:FreeRTOS/Source/queue.c **** 					{
 646              		.loc 1 709 0
 647 00b0 D0B9     		cbnz	r0, .L71
 648              	.LVL76:
 649              	.L72:
 724:FreeRTOS/Source/queue.c **** 				return pdPASS;
 650              		.loc 1 724 0
 651 00b2 FFF7FEFF 		bl	vPortExitCritical
 652              	.LVL77:
 725:FreeRTOS/Source/queue.c **** 			}
 653              		.loc 1 725 0
 654 00b6 0120     		movs	r0, #1
 806:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 655              		.loc 1 806 0
 656 00b8 05B0     		add	sp, sp, #20
 657              	.LCFI9:
 658              		.cfi_remember_state
 659              		.cfi_def_cfa_offset 28
 660              		@ sp needed
 661 00ba BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 662              	.LVL78:
 663              	.L94:
 664              	.LCFI10:
 665              		.cfi_restore_state
 733:FreeRTOS/Source/queue.c **** 
 666              		.loc 1 733 0
 667 00be FFF7FEFF 		bl	vPortExitCritical
 668              	.LVL79:
 738:FreeRTOS/Source/queue.c **** 				}
 669              		.loc 1 738 0
 670 00c2 2846     		mov	r0, r5
 806:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 671              		.loc 1 806 0
 672 00c4 05B0     		add	sp, sp, #20
 673              	.LCFI11:
 674              		.cfi_remember_state
 675              		.cfi_def_cfa_offset 28
 676              		@ sp needed
 677 00c6 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 678              	.LVL80:
 679              	.L79:
 680              	.LCFI12:
 681              		.cfi_restore_state
 797:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 682              		.loc 1 797 0
 683 00ca 2046     		mov	r0, r4
 684 00cc FFF7FEFF 		bl	prvUnlockQueue
 685              	.LVL81:
 798:FreeRTOS/Source/queue.c **** 
 686              		.loc 1 798 0
 687 00d0 FFF7FEFF 		bl	xTaskResumeAll
 688              	.LVL82:
 803:FreeRTOS/Source/queue.c **** 		}
 689              		.loc 1 803 0
 690 00d4 0020     		movs	r0, #0
 806:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 691              		.loc 1 806 0
 692 00d6 05B0     		add	sp, sp, #20
 693              	.LCFI13:
 694              		.cfi_remember_state
 695              		.cfi_def_cfa_offset 28
 696              		@ sp needed
 697 00d8 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 698              	.LVL83:
 699              	.L95:
 700              	.LCFI14:
 701              		.cfi_restore_state
 696:FreeRTOS/Source/queue.c **** 						{
 702              		.loc 1 696 0
 703 00dc 04F12400 		add	r0, r4, #36
 704              	.LVL84:
 705 00e0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 706              	.LVL85:
 707 00e4 0128     		cmp	r0, #1
 708 00e6 E4D1     		bne	.L72
 709              	.L71:
 702:FreeRTOS/Source/queue.c **** 						}
 710              		.loc 1 702 0
 711 00e8 FFF7FEFF 		bl	vPortYieldFromISR
 712              	.LVL86:
 713 00ec E1E7     		b	.L72
 714              		.cfi_endproc
 715              	.LFE113:
 717 00ee 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 718              		.align	2
 719              		.global	xQueueCreateMutex
 720              		.thumb
 721              		.thumb_func
 723              	xQueueCreateMutex:
 724              	.LFB112:
 392:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 725              		.loc 1 392 0
 726              		.cfi_startproc
 727              		@ args = 0, pretend = 0, frame = 0
 728              		@ frame_needed = 0, uses_anonymous_args = 0
 729              	.LVL87:
 730 0000 38B5     		push	{r3, r4, r5, lr}
 731              	.LCFI15:
 732              		.cfi_def_cfa_offset 16
 733              		.cfi_offset 3, -16
 734              		.cfi_offset 4, -12
 735              		.cfi_offset 5, -8
 736              		.cfi_offset 14, -4
 400:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 737              		.loc 1 400 0
 738 0002 4C20     		movs	r0, #76
 739              	.LVL88:
 740 0004 FFF7FEFF 		bl	malloc
 741              	.LVL89:
 401:FreeRTOS/Source/queue.c **** 		{
 742              		.loc 1 401 0
 743 0008 0446     		mov	r4, r0
 744 000a C8B1     		cbz	r0, .L97
 404:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 745              		.loc 1 404 0
 746 000c 0025     		movs	r5, #0
 418:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 747              		.loc 1 418 0
 748 000e 4FF0FF33 		mov	r3, #-1
 416:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 749              		.loc 1 416 0
 750 0012 0122     		movs	r2, #1
 415:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
 751              		.loc 1 415 0
 752 0014 8563     		str	r5, [r0, #56]
 416:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
 753              		.loc 1 416 0
 754 0016 C263     		str	r2, [r0, #60]
 418:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 755              		.loc 1 418 0
 756 0018 4364     		str	r3, [r0, #68]
 404:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 757              		.loc 1 404 0
 758 001a 4560     		str	r5, [r0, #4]
 419:FreeRTOS/Source/queue.c **** 
 759              		.loc 1 419 0
 760 001c 8364     		str	r3, [r0, #72]
 405:FreeRTOS/Source/queue.c **** 
 761              		.loc 1 405 0
 762 001e 0560     		str	r5, [r0]
 409:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 763              		.loc 1 409 0
 764 0020 8560     		str	r5, [r0, #8]
 410:FreeRTOS/Source/queue.c **** 
 765              		.loc 1 410 0
 766 0022 C560     		str	r5, [r0, #12]
 417:FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 767              		.loc 1 417 0
 768 0024 0564     		str	r5, [r0, #64]
 434:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 769              		.loc 1 434 0
 770 0026 1030     		adds	r0, r0, #16
 771              	.LVL90:
 772 0028 FFF7FEFF 		bl	vListInitialise
 773              	.LVL91:
 435:FreeRTOS/Source/queue.c **** 
 774              		.loc 1 435 0
 775 002c 04F12400 		add	r0, r4, #36
 776 0030 FFF7FEFF 		bl	vListInitialise
 777              	.LVL92:
 440:FreeRTOS/Source/queue.c **** 		}
 778              		.loc 1 440 0
 779 0034 2046     		mov	r0, r4
 780 0036 2946     		mov	r1, r5
 781 0038 2A46     		mov	r2, r5
 782 003a 2B46     		mov	r3, r5
 783 003c FFF7FEFF 		bl	xQueueGenericSend
 784              	.LVL93:
 785              	.L97:
 448:FreeRTOS/Source/queue.c **** 
 786              		.loc 1 448 0
 787 0040 2046     		mov	r0, r4
 788 0042 38BD     		pop	{r3, r4, r5, pc}
 789              		.cfi_endproc
 790              	.LFE112:
 792              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 793              		.align	2
 794              		.global	xQueueGenericSendFromISR
 795              		.thumb
 796              		.thumb_func
 798              	xQueueGenericSendFromISR:
 799              	.LFB114:
1055:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 800              		.loc 1 1055 0
 801              		.cfi_startproc
 802              		@ args = 0, pretend = 0, frame = 0
 803              		@ frame_needed = 0, uses_anonymous_args = 0
 804              	.LVL94:
 805 0000 38B5     		push	{r3, r4, r5, lr}
 806              	.LCFI16:
 807              		.cfi_def_cfa_offset 16
 808              		.cfi_offset 3, -16
 809              		.cfi_offset 4, -12
 810              		.cfi_offset 5, -8
 811              		.cfi_offset 14, -4
1055:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 812              		.loc 1 1055 0
 813 0002 0446     		mov	r4, r0
 814              	.LVL95:
1085:FreeRTOS/Source/queue.c **** 	{
 815              		.loc 1 1085 0
 816              	@ 1085 "FreeRTOS/Source/queue.c" 1
 817 0004 4FF0BF00 			mov r0, #191								
 818 0008 80F31188 		msr basepri, r0							
 819              	
 820              	@ 0 "" 2
 821              	.LVL96:
1087:FreeRTOS/Source/queue.c **** 		{
 822              		.loc 1 1087 0
 823              		.thumb
 824 000c A56B     		ldr	r5, [r4, #56]
 825 000e E06B     		ldr	r0, [r4, #60]
 826 0010 8542     		cmp	r5, r0
 827 0012 08D3     		bcc	.L103
1087:FreeRTOS/Source/queue.c **** 		{
 828              		.loc 1 1087 0 is_stmt 0 discriminator 1
 829 0014 022B     		cmp	r3, #2
 830 0016 06D0     		beq	.L103
1194:FreeRTOS/Source/queue.c **** 		}
 831              		.loc 1 1194 0 is_stmt 1
 832 0018 0023     		movs	r3, #0
 833              	.LVL97:
 834              	.L104:
1197:FreeRTOS/Source/queue.c **** 
 835              		.loc 1 1197 0
 836              	@ 1197 "FreeRTOS/Source/queue.c" 1
 837 001a 4FF00000 			mov r0, #0					
 838 001e 80F31188 		msr basepri, r0				
 839              	
 840              	@ 0 "" 2
1200:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 841              		.loc 1 1200 0
 842              		.thumb
 843 0022 1846     		mov	r0, r3
 844 0024 38BD     		pop	{r3, r4, r5, pc}
 845              	.LVL98:
 846              	.L103:
 847 0026 1546     		mov	r5, r2
1096:FreeRTOS/Source/queue.c **** 
 848              		.loc 1 1096 0
 849 0028 2046     		mov	r0, r4
 850 002a 1A46     		mov	r2, r3
 851              	.LVL99:
 852 002c FFF7FEFF 		bl	prvCopyDataToQueue
 853              	.LVL100:
1100:FreeRTOS/Source/queue.c **** 			{
 854              		.loc 1 1100 0
 855 0030 A36C     		ldr	r3, [r4, #72]
 856 0032 0133     		adds	r3, r3, #1
 857 0034 04D0     		beq	.L117
1186:FreeRTOS/Source/queue.c **** 			}
 858              		.loc 1 1186 0
 859 0036 A36C     		ldr	r3, [r4, #72]
 860 0038 0133     		adds	r3, r3, #1
 861 003a A364     		str	r3, [r4, #72]
 862              	.L116:
1189:FreeRTOS/Source/queue.c **** 		}
 863              		.loc 1 1189 0
 864 003c 0123     		movs	r3, #1
 865 003e ECE7     		b	.L104
 866              	.L117:
1155:FreeRTOS/Source/queue.c **** 					{
 867              		.loc 1 1155 0
 868 0040 636A     		ldr	r3, [r4, #36]
 869 0042 002B     		cmp	r3, #0
 870 0044 FAD0     		beq	.L116
1157:FreeRTOS/Source/queue.c **** 						{
 871              		.loc 1 1157 0
 872 0046 04F12400 		add	r0, r4, #36
 873 004a FFF7FEFF 		bl	xTaskRemoveFromEventList
 874              	.LVL101:
 875 004e 0028     		cmp	r0, #0
 876 0050 F4D0     		beq	.L116
1161:FreeRTOS/Source/queue.c **** 							{
 877              		.loc 1 1161 0
 878 0052 002D     		cmp	r5, #0
 879 0054 F2D0     		beq	.L116
1163:FreeRTOS/Source/queue.c **** 							}
 880              		.loc 1 1163 0
 881 0056 0123     		movs	r3, #1
 882 0058 2B60     		str	r3, [r5]
 883 005a DEE7     		b	.L104
 884              		.cfi_endproc
 885              	.LFE114:
 887              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 888              		.align	2
 889              		.global	xQueueGiveFromISR
 890              		.thumb
 891              		.thumb_func
 893              	xQueueGiveFromISR:
 894              	.LFB115:
1204:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 895              		.loc 1 1204 0
 896              		.cfi_startproc
 897              		@ args = 0, pretend = 0, frame = 0
 898              		@ frame_needed = 0, uses_anonymous_args = 0
 899              	.LVL102:
 900 0000 0346     		mov	r3, r0
 901              	.LVL103:
1242:FreeRTOS/Source/queue.c **** 	{
 902              		.loc 1 1242 0
 903              	@ 1242 "FreeRTOS/Source/queue.c" 1
 904 0002 4FF0BF00 			mov r0, #191								
 905 0006 80F31188 		msr basepri, r0							
 906              	
 907              	@ 0 "" 2
 908              	.LVL104:
1247:FreeRTOS/Source/queue.c **** 		{
 909              		.loc 1 1247 0
 910              		.thumb
 911 000a 986B     		ldr	r0, [r3, #56]
 912 000c DA6B     		ldr	r2, [r3, #60]
 913 000e 9042     		cmp	r0, r2
 914 0010 0FD2     		bcs	.L123
1257:FreeRTOS/Source/queue.c **** 
 915              		.loc 1 1257 0
 916 0012 9A6B     		ldr	r2, [r3, #56]
 917 0014 0132     		adds	r2, r2, #1
 918 0016 9A63     		str	r2, [r3, #56]
1261:FreeRTOS/Source/queue.c **** 			{
 919              		.loc 1 1261 0
 920 0018 9A6C     		ldr	r2, [r3, #72]
 921 001a 0132     		adds	r2, r2, #1
 922 001c 0BD0     		beq	.L134
1347:FreeRTOS/Source/queue.c **** 			}
 923              		.loc 1 1347 0
 924 001e 9A6C     		ldr	r2, [r3, #72]
 925 0020 0132     		adds	r2, r2, #1
 926 0022 9A64     		str	r2, [r3, #72]
1350:FreeRTOS/Source/queue.c **** 		}
 927              		.loc 1 1350 0
 928 0024 0123     		movs	r3, #1
 929              	.LVL105:
 930              	.L132:
1358:FreeRTOS/Source/queue.c **** 
 931              		.loc 1 1358 0
 932              	@ 1358 "FreeRTOS/Source/queue.c" 1
 933 0026 4FF00000 			mov r0, #0					
 934 002a 80F31188 		msr basepri, r0				
 935              	
 936              	@ 0 "" 2
1361:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 937              		.loc 1 1361 0
 938              		.thumb
 939 002e 1846     		mov	r0, r3
 940 0030 7047     		bx	lr
 941              	.LVL106:
 942              	.L123:
1355:FreeRTOS/Source/queue.c **** 		}
 943              		.loc 1 1355 0
 944 0032 0023     		movs	r3, #0
 945              	.LVL107:
 946 0034 F7E7     		b	.L132
 947              	.LVL108:
 948              	.L134:
1316:FreeRTOS/Source/queue.c **** 					{
 949              		.loc 1 1316 0
 950 0036 5A6A     		ldr	r2, [r3, #36]
 951 0038 0AB9     		cbnz	r2, .L135
1350:FreeRTOS/Source/queue.c **** 		}
 952              		.loc 1 1350 0
 953 003a 0123     		movs	r3, #1
 954              	.LVL109:
 955 003c F3E7     		b	.L132
 956              	.LVL110:
 957              	.L135:
 958 003e 1846     		mov	r0, r3
1204:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 959              		.loc 1 1204 0
 960 0040 10B5     		push	{r4, lr}
 961              	.LCFI17:
 962              		.cfi_def_cfa_offset 8
 963              		.cfi_offset 4, -8
 964              		.cfi_offset 14, -4
1318:FreeRTOS/Source/queue.c **** 						{
 965              		.loc 1 1318 0
 966 0042 2430     		adds	r0, r0, #36
 967 0044 0C46     		mov	r4, r1
 968 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 969              	.LVL111:
1324:FreeRTOS/Source/queue.c **** 							}
 970              		.loc 1 1324 0
 971 004a 0123     		movs	r3, #1
1318:FreeRTOS/Source/queue.c **** 						{
 972              		.loc 1 1318 0
 973 004c 08B1     		cbz	r0, .L119
1322:FreeRTOS/Source/queue.c **** 							{
 974              		.loc 1 1322 0
 975 004e 04B1     		cbz	r4, .L119
1324:FreeRTOS/Source/queue.c **** 							}
 976              		.loc 1 1324 0
 977 0050 2360     		str	r3, [r4]
 978              	.L119:
 979              	.LVL112:
1358:FreeRTOS/Source/queue.c **** 
 980              		.loc 1 1358 0
 981              	@ 1358 "FreeRTOS/Source/queue.c" 1
 982 0052 4FF00000 			mov r0, #0					
 983 0056 80F31188 		msr basepri, r0				
 984              	
 985              	@ 0 "" 2
1361:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 986              		.loc 1 1361 0
 987              		.thumb
 988 005a 1846     		mov	r0, r3
 989 005c 10BD     		pop	{r4, pc}
 990              		.cfi_endproc
 991              	.LFE115:
 993 005e 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 994              		.align	2
 995              		.global	xQueueGenericReceive
 996              		.thumb
 997              		.thumb_func
 999              	xQueueGenericReceive:
 1000              	.LFB116:
1365:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1001              		.loc 1 1365 0
 1002              		.cfi_startproc
 1003              		@ args = 0, pretend = 0, frame = 16
 1004              		@ frame_needed = 0, uses_anonymous_args = 0
 1005              	.LVL113:
 1006 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1007              	.LCFI18:
 1008              		.cfi_def_cfa_offset 28
 1009              		.cfi_offset 4, -28
 1010              		.cfi_offset 5, -24
 1011              		.cfi_offset 6, -20
 1012              		.cfi_offset 7, -16
 1013              		.cfi_offset 8, -12
 1014              		.cfi_offset 9, -8
 1015              		.cfi_offset 14, -4
 1016 0004 85B0     		sub	sp, sp, #20
 1017              	.LCFI19:
 1018              		.cfi_def_cfa_offset 48
1366:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 1019              		.loc 1 1366 0
 1020 0006 0026     		movs	r6, #0
1365:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1021              		.loc 1 1365 0
 1022 0008 0446     		mov	r4, r0
 1023              	.LVL114:
 1024 000a 8946     		mov	r9, r1
 1025 000c 0192     		str	r2, [sp, #4]
 1026 000e 9846     		mov	r8, r3
1496:FreeRTOS/Source/queue.c **** 
 1027              		.loc 1 1496 0
 1028 0010 3746     		mov	r7, r6
 1029 0012 11E0     		b	.L137
 1030              	.LVL115:
 1031              	.L151:
 1032              	.LBB10:
 1033              	.LBB11:
2006:FreeRTOS/Source/queue.c **** 
 1034              		.loc 1 2006 0
 1035 0014 FFF7FEFF 		bl	vPortExitCritical
 1036              	.LVL116:
 1037              	.LBE11:
 1038              	.LBE10:
1507:FreeRTOS/Source/queue.c **** 					{
 1039              		.loc 1 1507 0
 1040 0018 2368     		ldr	r3, [r4]
 1041 001a 002B     		cmp	r3, #0
 1042 001c 3FD0     		beq	.L165
 1043              	.L155:
1522:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1044              		.loc 1 1522 0
 1045 001e 04F12400 		add	r0, r4, #36
 1046 0022 0199     		ldr	r1, [sp, #4]
 1047 0024 FFF7FEFF 		bl	vTaskPlaceOnEventList
 1048              	.LVL117:
1523:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1049              		.loc 1 1523 0
 1050 0028 2046     		mov	r0, r4
 1051 002a FFF7FEFF 		bl	prvUnlockQueue
 1052              	.LVL118:
1524:FreeRTOS/Source/queue.c **** 				{
 1053              		.loc 1 1524 0
 1054 002e FFF7FEFF 		bl	xTaskResumeAll
 1055              	.LVL119:
 1056 0032 0028     		cmp	r0, #0
 1057 0034 30D0     		beq	.L166
 1058              	.LVL120:
 1059              	.L153:
 1060 0036 0126     		movs	r6, #1
 1061              	.LVL121:
 1062              	.L137:
1385:FreeRTOS/Source/queue.c **** 		{
 1063              		.loc 1 1385 0
 1064 0038 FFF7FEFF 		bl	vPortEnterCritical
 1065              	.LVL122:
1389:FreeRTOS/Source/queue.c **** 			{
 1066              		.loc 1 1389 0
 1067 003c A36B     		ldr	r3, [r4, #56]
 1068 003e 002B     		cmp	r3, #0
 1069 0040 35D1     		bne	.L167
1468:FreeRTOS/Source/queue.c **** 				{
 1070              		.loc 1 1468 0
 1071 0042 019D     		ldr	r5, [sp, #4]
 1072 0044 002D     		cmp	r5, #0
 1073 0046 4AD0     		beq	.L168
1476:FreeRTOS/Source/queue.c **** 				{
 1074              		.loc 1 1476 0
 1075 0048 16B3     		cbz	r6, .L169
 1076              	.LVL123:
 1077              	.L147:
1490:FreeRTOS/Source/queue.c **** 
 1078              		.loc 1 1490 0
 1079 004a FFF7FEFF 		bl	vPortExitCritical
 1080              	.LVL124:
1495:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1081              		.loc 1 1495 0
 1082 004e FFF7FEFF 		bl	vTaskSuspendAll
 1083              	.LVL125:
1496:FreeRTOS/Source/queue.c **** 
 1084              		.loc 1 1496 0
 1085 0052 FFF7FEFF 		bl	vPortEnterCritical
 1086              	.LVL126:
 1087 0056 636C     		ldr	r3, [r4, #68]
 1088 0058 0133     		adds	r3, r3, #1
 1089 005a 08BF     		it	eq
 1090 005c 6764     		streq	r7, [r4, #68]
 1091 005e A36C     		ldr	r3, [r4, #72]
 1092 0060 0133     		adds	r3, r3, #1
 1093 0062 08BF     		it	eq
 1094 0064 A764     		streq	r7, [r4, #72]
 1095 0066 FFF7FEFF 		bl	vPortExitCritical
 1096              	.LVL127:
1499:FreeRTOS/Source/queue.c **** 		{
 1097              		.loc 1 1499 0
 1098 006a 02A8     		add	r0, sp, #8
 1099 006c 01A9     		add	r1, sp, #4
 1100              	.LVL128:
 1101 006e FFF7FEFF 		bl	xTaskCheckForTimeOut
 1102              	.LVL129:
 1103 0072 0028     		cmp	r0, #0
 1104 0074 39D1     		bne	.L150
 1105              	.LVL130:
 1106              	.LBB13:
 1107              	.LBB12:
1995:FreeRTOS/Source/queue.c **** 	{
 1108              		.loc 1 1995 0
 1109 0076 FFF7FEFF 		bl	vPortEnterCritical
 1110              	.LVL131:
1997:FreeRTOS/Source/queue.c **** 		{
 1111              		.loc 1 1997 0
 1112 007a A36B     		ldr	r3, [r4, #56]
 1113 007c 002B     		cmp	r3, #0
 1114 007e C9D0     		beq	.L151
 1115              	.LVL132:
2006:FreeRTOS/Source/queue.c **** 
 1116              		.loc 1 2006 0
 1117 0080 FFF7FEFF 		bl	vPortExitCritical
 1118              	.LVL133:
 1119              	.LBE12:
 1120              	.LBE13:
1536:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1121              		.loc 1 1536 0
 1122 0084 2046     		mov	r0, r4
 1123 0086 FFF7FEFF 		bl	prvUnlockQueue
 1124              	.LVL134:
1537:FreeRTOS/Source/queue.c **** 			}
 1125              		.loc 1 1537 0
 1126 008a FFF7FEFF 		bl	xTaskResumeAll
 1127              	.LVL135:
 1128 008e D2E7     		b	.L153
 1129              	.LVL136:
 1130              	.L169:
1480:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1131              		.loc 1 1480 0
 1132 0090 02A8     		add	r0, sp, #8
 1133 0092 FFF7FEFF 		bl	vTaskSetTimeOutState
 1134              	.LVL137:
 1135 0096 D8E7     		b	.L147
 1136              	.LVL138:
 1137              	.L166:
1526:FreeRTOS/Source/queue.c **** 				}
 1138              		.loc 1 1526 0
 1139 0098 FFF7FEFF 		bl	vPortYieldFromISR
 1140              	.LVL139:
 1141 009c CBE7     		b	.L153
 1142              	.L165:
1509:FreeRTOS/Source/queue.c **** 						{
 1143              		.loc 1 1509 0
 1144 009e FFF7FEFF 		bl	vPortEnterCritical
 1145              	.LVL140:
1511:FreeRTOS/Source/queue.c **** 						}
 1146              		.loc 1 1511 0
 1147 00a2 6068     		ldr	r0, [r4, #4]
 1148 00a4 FFF7FEFF 		bl	vTaskPriorityInherit
 1149              	.LVL141:
1513:FreeRTOS/Source/queue.c **** 					}
 1150              		.loc 1 1513 0
 1151 00a8 FFF7FEFF 		bl	vPortExitCritical
 1152              	.LVL142:
 1153 00ac B7E7     		b	.L155
 1154              	.LVL143:
 1155              	.L167:
1395:FreeRTOS/Source/queue.c **** 
 1156              		.loc 1 1395 0
 1157 00ae 4946     		mov	r1, r9
 1158 00b0 2046     		mov	r0, r4
1393:FreeRTOS/Source/queue.c **** 
 1159              		.loc 1 1393 0
 1160 00b2 E568     		ldr	r5, [r4, #12]
 1161              	.LVL144:
1395:FreeRTOS/Source/queue.c **** 
 1162              		.loc 1 1395 0
 1163 00b4 FFF7FEFF 		bl	prvCopyDataFromQueue
 1164              	.LVL145:
1397:FreeRTOS/Source/queue.c **** 				{
 1165              		.loc 1 1397 0
 1166 00b8 B8F1000F 		cmp	r8, #0
 1167 00bc 1ED1     		bne	.L139
1402:FreeRTOS/Source/queue.c **** 
 1168              		.loc 1 1402 0
 1169 00be A36B     		ldr	r3, [r4, #56]
1406:FreeRTOS/Source/queue.c **** 						{
 1170              		.loc 1 1406 0
 1171 00c0 2268     		ldr	r2, [r4]
1402:FreeRTOS/Source/queue.c **** 
 1172              		.loc 1 1402 0
 1173 00c2 013B     		subs	r3, r3, #1
 1174 00c4 A363     		str	r3, [r4, #56]
1406:FreeRTOS/Source/queue.c **** 						{
 1175              		.loc 1 1406 0
 1176 00c6 4AB3     		cbz	r2, .L170
 1177              	.L140:
1419:FreeRTOS/Source/queue.c **** 					{
 1178              		.loc 1 1419 0
 1179 00c8 2369     		ldr	r3, [r4, #16]
 1180 00ca D3B1     		cbz	r3, .L142
1421:FreeRTOS/Source/queue.c **** 						{
 1181              		.loc 1 1421 0
 1182 00cc 04F11000 		add	r0, r4, #16
 1183 00d0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1184              	.LVL146:
 1185 00d4 0128     		cmp	r0, #1
 1186 00d6 14D1     		bne	.L142
 1187              	.L144:
1423:FreeRTOS/Source/queue.c **** 						}
 1188              		.loc 1 1423 0
 1189 00d8 FFF7FEFF 		bl	vPortYieldFromISR
 1190              	.LVL147:
 1191 00dc 11E0     		b	.L142
 1192              	.LVL148:
 1193              	.L168:
1472:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1194              		.loc 1 1472 0
 1195 00de FFF7FEFF 		bl	vPortExitCritical
 1196              	.LVL149:
1474:FreeRTOS/Source/queue.c **** 				}
 1197              		.loc 1 1474 0
 1198 00e2 2846     		mov	r0, r5
1548:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1199              		.loc 1 1548 0
 1200 00e4 05B0     		add	sp, sp, #20
 1201              	.LCFI20:
 1202              		.cfi_remember_state
 1203              		.cfi_def_cfa_offset 28
 1204              		@ sp needed
 1205 00e6 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1206              	.LVL150:
 1207              	.L150:
 1208              	.LCFI21:
 1209              		.cfi_restore_state
1542:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1210              		.loc 1 1542 0
 1211 00ea 2046     		mov	r0, r4
 1212 00ec FFF7FEFF 		bl	prvUnlockQueue
 1213              	.LVL151:
1543:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 1214              		.loc 1 1543 0
 1215 00f0 FFF7FEFF 		bl	xTaskResumeAll
 1216              	.LVL152:
1545:FreeRTOS/Source/queue.c **** 		}
 1217              		.loc 1 1545 0
 1218 00f4 0020     		movs	r0, #0
1548:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1219              		.loc 1 1548 0
 1220 00f6 05B0     		add	sp, sp, #20
 1221              	.LCFI22:
 1222              		.cfi_remember_state
 1223              		.cfi_def_cfa_offset 28
 1224              		@ sp needed
 1225 00f8 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1226              	.LVL153:
 1227              	.L139:
 1228              	.LCFI23:
 1229              		.cfi_restore_state
1445:FreeRTOS/Source/queue.c **** 					{
 1230              		.loc 1 1445 0
 1231 00fc 636A     		ldr	r3, [r4, #36]
1441:FreeRTOS/Source/queue.c **** 
 1232              		.loc 1 1441 0
 1233 00fe E560     		str	r5, [r4, #12]
1445:FreeRTOS/Source/queue.c **** 					{
 1234              		.loc 1 1445 0
 1235 0100 2BB9     		cbnz	r3, .L171
 1236              	.L142:
1463:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1237              		.loc 1 1463 0
 1238 0102 FFF7FEFF 		bl	vPortExitCritical
 1239              	.LVL154:
1464:FreeRTOS/Source/queue.c **** 			}
 1240              		.loc 1 1464 0
 1241 0106 0120     		movs	r0, #1
1548:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1242              		.loc 1 1548 0
 1243 0108 05B0     		add	sp, sp, #20
 1244              	.LCFI24:
 1245              		.cfi_remember_state
 1246              		.cfi_def_cfa_offset 28
 1247              		@ sp needed
 1248 010a BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1249              	.LVL155:
 1250              	.L171:
 1251              	.LCFI25:
 1252              		.cfi_restore_state
1447:FreeRTOS/Source/queue.c **** 						{
 1253              		.loc 1 1447 0
 1254 010e 04F12400 		add	r0, r4, #36
 1255 0112 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1256              	.LVL156:
 1257 0116 0028     		cmp	r0, #0
 1258 0118 F3D0     		beq	.L142
 1259 011a DDE7     		b	.L144
 1260              	.L170:
1410:FreeRTOS/Source/queue.c **** 						}
 1261              		.loc 1 1410 0
 1262 011c FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1263              	.LVL157:
 1264 0120 6060     		str	r0, [r4, #4]
 1265 0122 D1E7     		b	.L140
 1266              		.cfi_endproc
 1267              	.LFE116:
 1269              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1270              		.align	2
 1271              		.global	xQueueReceiveFromISR
 1272              		.thumb
 1273              		.thumb_func
 1275              	xQueueReceiveFromISR:
 1276              	.LFB117:
1552:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1277              		.loc 1 1552 0
 1278              		.cfi_startproc
 1279              		@ args = 0, pretend = 0, frame = 0
 1280              		@ frame_needed = 0, uses_anonymous_args = 0
 1281              	.LVL158:
 1282 0000 38B5     		push	{r3, r4, r5, lr}
 1283              	.LCFI26:
 1284              		.cfi_def_cfa_offset 16
 1285              		.cfi_offset 3, -16
 1286              		.cfi_offset 4, -12
 1287              		.cfi_offset 5, -8
 1288              		.cfi_offset 14, -4
1552:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1289              		.loc 1 1552 0
 1290 0002 0446     		mov	r4, r0
 1291              	.LVL159:
1576:FreeRTOS/Source/queue.c **** 	{
 1292              		.loc 1 1576 0
 1293              	@ 1576 "FreeRTOS/Source/queue.c" 1
 1294 0004 4FF0BF00 			mov r0, #191								
 1295 0008 80F31188 		msr basepri, r0							
 1296              	
 1297              	@ 0 "" 2
 1298              	.LVL160:
1579:FreeRTOS/Source/queue.c **** 		{
 1299              		.loc 1 1579 0
 1300              		.thumb
 1301 000c A06B     		ldr	r0, [r4, #56]
 1302 000e 30B9     		cbnz	r0, .L186
1628:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 1303              		.loc 1 1628 0
 1304 0010 0346     		mov	r3, r0
 1305              	.LVL161:
 1306              	.L173:
1632:FreeRTOS/Source/queue.c **** 
 1307              		.loc 1 1632 0
 1308              	@ 1632 "FreeRTOS/Source/queue.c" 1
 1309 0012 4FF00000 			mov r0, #0					
 1310 0016 80F31188 		msr basepri, r0				
 1311              	
 1312              	@ 0 "" 2
1635:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1313              		.loc 1 1635 0
 1314              		.thumb
 1315 001a 1846     		mov	r0, r3
 1316 001c 38BD     		pop	{r3, r4, r5, pc}
 1317              	.LVL162:
 1318              	.L186:
1583:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1319              		.loc 1 1583 0
 1320 001e 2046     		mov	r0, r4
 1321 0020 1546     		mov	r5, r2
 1322 0022 FFF7FEFF 		bl	prvCopyDataFromQueue
 1323              	.LVL163:
1584:FreeRTOS/Source/queue.c **** 
 1324              		.loc 1 1584 0
 1325 0026 A36B     		ldr	r3, [r4, #56]
 1326 0028 013B     		subs	r3, r3, #1
 1327 002a A363     		str	r3, [r4, #56]
1590:FreeRTOS/Source/queue.c **** 			{
 1328              		.loc 1 1590 0
 1329 002c 636C     		ldr	r3, [r4, #68]
 1330 002e 0133     		adds	r3, r3, #1
 1331 0030 04D0     		beq	.L187
1621:FreeRTOS/Source/queue.c **** 			}
 1332              		.loc 1 1621 0
 1333 0032 636C     		ldr	r3, [r4, #68]
 1334 0034 0133     		adds	r3, r3, #1
 1335 0036 6364     		str	r3, [r4, #68]
 1336              	.L185:
1624:FreeRTOS/Source/queue.c **** 		}
 1337              		.loc 1 1624 0
 1338 0038 0123     		movs	r3, #1
 1339 003a EAE7     		b	.L173
 1340              	.L187:
1592:FreeRTOS/Source/queue.c **** 				{
 1341              		.loc 1 1592 0
 1342 003c 2369     		ldr	r3, [r4, #16]
 1343 003e 002B     		cmp	r3, #0
 1344 0040 FAD0     		beq	.L185
1594:FreeRTOS/Source/queue.c **** 					{
 1345              		.loc 1 1594 0
 1346 0042 04F11000 		add	r0, r4, #16
 1347 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1348              	.LVL164:
 1349 004a 0028     		cmp	r0, #0
 1350 004c F4D0     		beq	.L185
1598:FreeRTOS/Source/queue.c **** 						{
 1351              		.loc 1 1598 0
 1352 004e 002D     		cmp	r5, #0
 1353 0050 F2D0     		beq	.L185
1600:FreeRTOS/Source/queue.c **** 						}
 1354              		.loc 1 1600 0
 1355 0052 0120     		movs	r0, #1
 1356 0054 2860     		str	r0, [r5]
1624:FreeRTOS/Source/queue.c **** 		}
 1357              		.loc 1 1624 0
 1358 0056 0346     		mov	r3, r0
 1359 0058 DBE7     		b	.L173
 1360              		.cfi_endproc
 1361              	.LFE117:
 1363 005a 00BF     		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1364              		.align	2
 1365              		.global	xQueuePeekFromISR
 1366              		.thumb
 1367              		.thumb_func
 1369              	xQueuePeekFromISR:
 1370              	.LFB118:
1639:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1371              		.loc 1 1639 0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 0
 1374              		@ frame_needed = 0, uses_anonymous_args = 0
 1375              	.LVL165:
 1376 0000 38B5     		push	{r3, r4, r5, lr}
 1377              	.LCFI27:
 1378              		.cfi_def_cfa_offset 16
 1379              		.cfi_offset 3, -16
 1380              		.cfi_offset 4, -12
 1381              		.cfi_offset 5, -8
 1382              		.cfi_offset 14, -4
1639:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1383              		.loc 1 1639 0
 1384 0002 0346     		mov	r3, r0
 1385              	.LVL166:
1665:FreeRTOS/Source/queue.c **** 	{
 1386              		.loc 1 1665 0
 1387              	@ 1665 "FreeRTOS/Source/queue.c" 1
 1388 0004 4FF0BF00 			mov r0, #191								
 1389 0008 80F31188 		msr basepri, r0							
 1390              	
 1391              	@ 0 "" 2
 1392              	.LVL167:
1668:FreeRTOS/Source/queue.c **** 		{
 1393              		.loc 1 1668 0
 1394              		.thumb
 1395 000c 986B     		ldr	r0, [r3, #56]
 1396 000e 30B9     		cbnz	r0, .L192
1682:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 1397              		.loc 1 1682 0
 1398 0010 0346     		mov	r3, r0
 1399              	.LVL168:
 1400              	.L189:
1686:FreeRTOS/Source/queue.c **** 
 1401              		.loc 1 1686 0
 1402              	@ 1686 "FreeRTOS/Source/queue.c" 1
 1403 0012 4FF00000 			mov r0, #0					
 1404 0016 80F31188 		msr basepri, r0				
 1405              	
 1406              	@ 0 "" 2
1689:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1407              		.loc 1 1689 0
 1408              		.thumb
 1409 001a 1846     		mov	r0, r3
 1410 001c 38BD     		pop	{r3, r4, r5, pc}
 1411              	.LVL169:
 1412              	.L192:
 1413 001e 1C46     		mov	r4, r3
1674:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1414              		.loc 1 1674 0
 1415 0020 DD68     		ldr	r5, [r3, #12]
 1416              	.LVL170:
1675:FreeRTOS/Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1417              		.loc 1 1675 0
 1418 0022 1846     		mov	r0, r3
 1419 0024 FFF7FEFF 		bl	prvCopyDataFromQueue
 1420              	.LVL171:
1676:FreeRTOS/Source/queue.c **** 
 1421              		.loc 1 1676 0
 1422 0028 E560     		str	r5, [r4, #12]
 1423              	.LVL172:
1678:FreeRTOS/Source/queue.c **** 		}
 1424              		.loc 1 1678 0
 1425 002a 0123     		movs	r3, #1
 1426 002c F1E7     		b	.L189
 1427              		.cfi_endproc
 1428              	.LFE118:
 1430 002e 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1431              		.align	2
 1432              		.global	uxQueueMessagesWaiting
 1433              		.thumb
 1434              		.thumb_func
 1436              	uxQueueMessagesWaiting:
 1437              	.LFB119:
1693:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 1438              		.loc 1 1693 0
 1439              		.cfi_startproc
 1440              		@ args = 0, pretend = 0, frame = 0
 1441              		@ frame_needed = 0, uses_anonymous_args = 0
 1442              	.LVL173:
 1443 0000 10B5     		push	{r4, lr}
 1444              	.LCFI28:
 1445              		.cfi_def_cfa_offset 8
 1446              		.cfi_offset 4, -8
 1447              		.cfi_offset 14, -4
1693:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 1448              		.loc 1 1693 0
 1449 0002 0446     		mov	r4, r0
1698:FreeRTOS/Source/queue.c **** 	{
 1450              		.loc 1 1698 0
 1451 0004 FFF7FEFF 		bl	vPortEnterCritical
 1452              	.LVL174:
1700:FreeRTOS/Source/queue.c **** 	}
 1453              		.loc 1 1700 0
 1454 0008 A46B     		ldr	r4, [r4, #56]
 1455              	.LVL175:
1702:FreeRTOS/Source/queue.c **** 
 1456              		.loc 1 1702 0
 1457 000a FFF7FEFF 		bl	vPortExitCritical
 1458              	.LVL176:
1705:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1459              		.loc 1 1705 0
 1460 000e 2046     		mov	r0, r4
 1461 0010 10BD     		pop	{r4, pc}
 1462              		.cfi_endproc
 1463              	.LFE119:
 1465 0012 00BF     		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1466              		.align	2
 1467              		.global	uxQueueSpacesAvailable
 1468              		.thumb
 1469              		.thumb_func
 1471              	uxQueueSpacesAvailable:
 1472              	.LFB120:
1709:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 1473              		.loc 1 1709 0
 1474              		.cfi_startproc
 1475              		@ args = 0, pretend = 0, frame = 0
 1476              		@ frame_needed = 0, uses_anonymous_args = 0
 1477              	.LVL177:
 1478 0000 38B5     		push	{r3, r4, r5, lr}
 1479              	.LCFI29:
 1480              		.cfi_def_cfa_offset 16
 1481              		.cfi_offset 3, -16
 1482              		.cfi_offset 4, -12
 1483              		.cfi_offset 5, -8
 1484              		.cfi_offset 14, -4
1709:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 1485              		.loc 1 1709 0
 1486 0002 0546     		mov	r5, r0
 1487              	.LVL178:
1716:FreeRTOS/Source/queue.c **** 	{
 1488              		.loc 1 1716 0
 1489 0004 FFF7FEFF 		bl	vPortEnterCritical
 1490              	.LVL179:
1718:FreeRTOS/Source/queue.c **** 	}
 1491              		.loc 1 1718 0
 1492 0008 AC6B     		ldr	r4, [r5, #56]
 1493 000a EB6B     		ldr	r3, [r5, #60]
 1494 000c 1C1B     		subs	r4, r3, r4
 1495              	.LVL180:
1720:FreeRTOS/Source/queue.c **** 
 1496              		.loc 1 1720 0
 1497 000e FFF7FEFF 		bl	vPortExitCritical
 1498              	.LVL181:
1723:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1499              		.loc 1 1723 0
 1500 0012 2046     		mov	r0, r4
 1501 0014 38BD     		pop	{r3, r4, r5, pc}
 1502              		.cfi_endproc
 1503              	.LFE120:
 1505 0016 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1506              		.align	2
 1507              		.global	uxQueueMessagesWaitingFromISR
 1508              		.thumb
 1509              		.thumb_func
 1511              	uxQueueMessagesWaitingFromISR:
 1512              	.LFB121:
1727:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
 1513              		.loc 1 1727 0
 1514              		.cfi_startproc
 1515              		@ args = 0, pretend = 0, frame = 0
 1516              		@ frame_needed = 0, uses_anonymous_args = 0
 1517              		@ link register save eliminated.
 1518              	.LVL182:
1732:FreeRTOS/Source/queue.c **** 
 1519              		.loc 1 1732 0
 1520 0000 806B     		ldr	r0, [r0, #56]
 1521              	.LVL183:
1735:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1522              		.loc 1 1735 0
 1523 0002 7047     		bx	lr
 1524              		.cfi_endproc
 1525              	.LFE121:
 1527              		.section	.text.vQueueDelete,"ax",%progbits
 1528              		.align	2
 1529              		.global	vQueueDelete
 1530              		.thumb
 1531              		.thumb_func
 1533              	vQueueDelete:
 1534              	.LFB122:
1739:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1535              		.loc 1 1739 0
 1536              		.cfi_startproc
 1537              		@ args = 0, pretend = 0, frame = 0
 1538              		@ frame_needed = 0, uses_anonymous_args = 0
 1539              		@ link register save eliminated.
 1540              	.LVL184:
1750:FreeRTOS/Source/queue.c **** }
 1541              		.loc 1 1750 0
 1542 0000 FFF7FEBF 		b	free
 1543              	.LVL185:
 1544              		.cfi_endproc
 1545              	.LFE122:
 1547              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1548              		.align	2
 1549              		.global	xQueueIsQueueEmptyFromISR
 1550              		.thumb
 1551              		.thumb_func
 1553              	xQueueIsQueueEmptyFromISR:
 1554              	.LFB127:
2013:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 1555              		.loc 1 2013 0
 1556              		.cfi_startproc
 1557              		@ args = 0, pretend = 0, frame = 0
 1558              		@ frame_needed = 0, uses_anonymous_args = 0
 1559              		@ link register save eliminated.
 1560              	.LVL186:
2017:FreeRTOS/Source/queue.c **** 	{
 1561              		.loc 1 2017 0
 1562 0000 806B     		ldr	r0, [r0, #56]
 1563              	.LVL187:
2027:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1564              		.loc 1 2027 0
 1565 0002 B0FA80F0 		clz	r0, r0
 1566              	.LVL188:
 1567 0006 4009     		lsrs	r0, r0, #5
 1568 0008 7047     		bx	lr
 1569              		.cfi_endproc
 1570              	.LFE127:
 1572 000a 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1573              		.align	2
 1574              		.global	xQueueIsQueueFullFromISR
 1575              		.thumb
 1576              		.thumb_func
 1578              	xQueueIsQueueFullFromISR:
 1579              	.LFB129:
2046:FreeRTOS/Source/queue.c **** 
2047:FreeRTOS/Source/queue.c **** 	return xReturn;
2048:FreeRTOS/Source/queue.c **** }
2049:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2050:FreeRTOS/Source/queue.c **** 
2051:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2052:FreeRTOS/Source/queue.c **** {
 1580              		.loc 1 2052 0
 1581              		.cfi_startproc
 1582              		@ args = 0, pretend = 0, frame = 0
 1583              		@ frame_needed = 0, uses_anonymous_args = 0
 1584              		@ link register save eliminated.
 1585              	.LVL189:
2053:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2054:FreeRTOS/Source/queue.c **** 
2055:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
2056:FreeRTOS/Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 1586              		.loc 1 2056 0
 1587 0000 826B     		ldr	r2, [r0, #56]
 1588              	.LVL190:
 1589 0002 C06B     		ldr	r0, [r0, #60]
 1590              	.LVL191:
2057:FreeRTOS/Source/queue.c **** 	{
2058:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
2059:FreeRTOS/Source/queue.c **** 	}
2060:FreeRTOS/Source/queue.c **** 	else
2061:FreeRTOS/Source/queue.c **** 	{
2062:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
2063:FreeRTOS/Source/queue.c **** 	}
2064:FreeRTOS/Source/queue.c **** 
2065:FreeRTOS/Source/queue.c **** 	return xReturn;
2066:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1591              		.loc 1 2066 0
 1592 0004 101A     		subs	r0, r2, r0
 1593              	.LVL192:
 1594 0006 B0FA80F0 		clz	r0, r0
 1595 000a 4009     		lsrs	r0, r0, #5
 1596 000c 7047     		bx	lr
 1597              		.cfi_endproc
 1598              	.LFE129:
 1600 000e 00BF     		.text
 1601              	.Letext0:
 1602              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\lib\\gcc\\arm-none-eabi\\4.9
 1603              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\mach
 1604              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\stdi
 1605              		.file 5 "FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 1606              		.file 6 "FreeRTOS/Source/include/list.h"
 1607              		.file 7 "FreeRTOS/Source/include/task.h"
 1608              		.file 8 "FreeRTOS/Source/include/queue.h"
 1609              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\stdl
 1610              		.file 10 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:20     .text.prvCopyDataToQueue:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:24     .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:152    .text.prvCopyDataFromQueue:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:156    .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:204    .text.prvUnlockQueue:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:208    .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:321    .text.xQueueGenericReset:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:326    .text.xQueueGenericReset:00000000 xQueueGenericReset
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:417    .text.xQueueGenericCreate:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:422    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:493    .text.xQueueGenericSend:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:498    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:718    .text.xQueueCreateMutex:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:723    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:793    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:798    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:888    .text.xQueueGiveFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:893    .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:994    .text.xQueueGenericReceive:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:999    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1270   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1275   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1364   .text.xQueuePeekFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1369   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1431   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1436   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1466   .text.uxQueueSpacesAvailable:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1471   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1506   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1511   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1528   .text.vQueueDelete:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1533   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1548   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1553   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1573   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccFEMGea.s:1578   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
xTaskPriorityDisinherit
vPortEnterCritical
xTaskRemoveFromEventList
vTaskMissedYield
vPortExitCritical
vPortYieldFromISR
vListInitialise
malloc
vTaskSuspendAll
xTaskCheckForTimeOut
xTaskResumeAll
vTaskSetTimeOutState
vTaskPlaceOnEventList
vTaskPriorityInherit
pvTaskIncrementMutexHeldCount
free

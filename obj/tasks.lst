   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 2
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	prvResetNextTaskUnblockTime:
  25              	.LFB150:
  26              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c ****     All rights reserved
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:FreeRTOS/Source/tasks.c **** 
   7:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:FreeRTOS/Source/tasks.c **** 
   9:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:FreeRTOS/Source/tasks.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:FreeRTOS/Source/tasks.c **** 
  13:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  14:FreeRTOS/Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:FreeRTOS/Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:FreeRTOS/Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:FreeRTOS/Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  19:FreeRTOS/Source/tasks.c **** 
  20:FreeRTOS/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:FreeRTOS/Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:FreeRTOS/Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:FreeRTOS/Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  26:FreeRTOS/Source/tasks.c ****      *                                                                       *
  27:FreeRTOS/Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:FreeRTOS/Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:FreeRTOS/Source/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:FreeRTOS/Source/tasks.c ****      *    is the industry's de facto standard.                               *
  31:FreeRTOS/Source/tasks.c ****      *                                                                       *
  32:FreeRTOS/Source/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:FreeRTOS/Source/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:FreeRTOS/Source/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:FreeRTOS/Source/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:FreeRTOS/Source/tasks.c ****      *                                                                       *
  37:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  38:FreeRTOS/Source/tasks.c **** 
  39:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:FreeRTOS/Source/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:FreeRTOS/Source/tasks.c ****     defined configASSERT()?
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:FreeRTOS/Source/tasks.c ****     embedded software for free we request you assist our global community by
  45:FreeRTOS/Source/tasks.c ****     participating in the support forum.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:FreeRTOS/Source/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:FreeRTOS/Source/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:FreeRTOS/Source/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:FreeRTOS/Source/tasks.c **** 
  52:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:FreeRTOS/Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:FreeRTOS/Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:FreeRTOS/Source/tasks.c **** 
  56:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:FreeRTOS/Source/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:FreeRTOS/Source/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:FreeRTOS/Source/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:FreeRTOS/Source/tasks.c **** 
  63:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:FreeRTOS/Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:FreeRTOS/Source/tasks.c ****     mission critical applications that require provable dependability.
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  68:FreeRTOS/Source/tasks.c **** */
  69:FreeRTOS/Source/tasks.c **** 
  70:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  71:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  72:FreeRTOS/Source/tasks.c **** #include <string.h>
  73:FreeRTOS/Source/tasks.c **** 
  74:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  77:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:FreeRTOS/Source/tasks.c **** 
  79:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  80:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  81:FreeRTOS/Source/tasks.c **** #include "task.h"
  82:FreeRTOS/Source/tasks.c **** #include "timers.h"
  83:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  84:FreeRTOS/Source/tasks.c **** 
  85:FreeRTOS/Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:FreeRTOS/Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:FreeRTOS/Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:FreeRTOS/Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:FreeRTOS/Source/tasks.c **** 
  91:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  93:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  99:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:FreeRTOS/Source/tasks.c **** 
 101:FreeRTOS/Source/tasks.c **** /* Sanity check the configuration. */
 102:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
 103:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_vTaskSuspend != 1 )
 104:FreeRTOS/Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
 105:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 106:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 107:FreeRTOS/Source/tasks.c **** 
 108:FreeRTOS/Source/tasks.c **** /*
 109:FreeRTOS/Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 110:FreeRTOS/Source/tasks.c ****  */
 111:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 112:FreeRTOS/Source/tasks.c **** 
 113:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 114:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 115:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 116:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 117:FreeRTOS/Source/tasks.c **** #else
 118:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 119:FreeRTOS/Source/tasks.c **** #endif
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /* Value that can be assigned to the eNotifyState member of the TCB. */
 122:FreeRTOS/Source/tasks.c **** typedef enum
 123:FreeRTOS/Source/tasks.c **** {
 124:FreeRTOS/Source/tasks.c **** 	eNotWaitingNotification = 0,
 125:FreeRTOS/Source/tasks.c **** 	eWaitingNotification,
 126:FreeRTOS/Source/tasks.c **** 	eNotified
 127:FreeRTOS/Source/tasks.c **** } eNotifyValue;
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*
 130:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 131:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 132:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 133:FreeRTOS/Source/tasks.c ****  */
 134:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
 135:FreeRTOS/Source/tasks.c **** {
 136:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 137:FreeRTOS/Source/tasks.c **** 
 138:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 139:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 140:FreeRTOS/Source/tasks.c **** 		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocat
 141:FreeRTOS/Source/tasks.c **** 	#endif
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from d
 144:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 145:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 146:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 147:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 148:FreeRTOS/Source/tasks.c **** 
 149:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 150:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 151:FreeRTOS/Source/tasks.c **** 	#endif
 152:FreeRTOS/Source/tasks.c **** 
 153:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 154:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do n
 155:FreeRTOS/Source/tasks.c **** 	#endif
 156:FreeRTOS/Source/tasks.c **** 
 157:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 158:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 159:FreeRTOS/Source/tasks.c **** 		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. 
 160:FreeRTOS/Source/tasks.c **** 	#endif
 161:FreeRTOS/Source/tasks.c **** 
 162:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 163:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 164:FreeRTOS/Source/tasks.c **** 		UBaseType_t 	uxMutexesHeld;
 165:FreeRTOS/Source/tasks.c **** 	#endif
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 168:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 169:FreeRTOS/Source/tasks.c **** 	#endif
 170:FreeRTOS/Source/tasks.c **** 
 171:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 172:FreeRTOS/Source/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 173:FreeRTOS/Source/tasks.c **** 	#endif
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 176:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 177:FreeRTOS/Source/tasks.c **** 	#endif
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 180:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 181:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 182:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 183:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 184:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 185:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 186:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 187:FreeRTOS/Source/tasks.c **** 		struct 	_reent xNewLib_reent;
 188:FreeRTOS/Source/tasks.c **** 	#endif
 189:FreeRTOS/Source/tasks.c **** 
 190:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 191:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 192:FreeRTOS/Source/tasks.c **** 		volatile eNotifyValue eNotifyState;
 193:FreeRTOS/Source/tasks.c **** 	#endif
 194:FreeRTOS/Source/tasks.c **** 
 195:FreeRTOS/Source/tasks.c **** } tskTCB;
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 198:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 199:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 200:FreeRTOS/Source/tasks.c **** 
 201:FreeRTOS/Source/tasks.c **** /*
 202:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 203:FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 204:FreeRTOS/Source/tasks.c ****  */
 205:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 206:FreeRTOS/Source/tasks.c **** 	#define static
 207:FreeRTOS/Source/tasks.c **** #endif
 208:FreeRTOS/Source/tasks.c **** 
 209:FreeRTOS/Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 210:FreeRTOS/Source/tasks.c **** static variables must be declared volatile. */
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 215:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 216:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 217:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 218:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 219:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 220:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 221:FreeRTOS/Source/tasks.c **** 
 222:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 223:FreeRTOS/Source/tasks.c **** 
 224:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 225:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
 226:FreeRTOS/Source/tasks.c **** 
 227:FreeRTOS/Source/tasks.c **** #endif
 228:FreeRTOS/Source/tasks.c **** 
 229:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 230:FreeRTOS/Source/tasks.c **** 
 231:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 232:FreeRTOS/Source/tasks.c **** 
 233:FreeRTOS/Source/tasks.c **** #endif
 234:FreeRTOS/Source/tasks.c **** 
 235:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 236:FreeRTOS/Source/tasks.c **** 
 237:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle tas
 238:FreeRTOS/Source/tasks.c **** 
 239:FreeRTOS/Source/tasks.c **** #endif
 240:FreeRTOS/Source/tasks.c **** 
 241:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 242:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 243:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 244:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 245:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 246:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 247:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 248:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 249:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 250:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 251:FreeRTOS/Source/tasks.c **** 
 252:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 253:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xGenericListItem of a TCB, or any of the
 254:FreeRTOS/Source/tasks.c **** lists the xGenericListItem can be referenced from, if the scheduler is suspended.
 255:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 256:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 257:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 258:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 259:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 260:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 261:FreeRTOS/Source/tasks.c **** 
 262:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 263:FreeRTOS/Source/tasks.c **** 
 264:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 265:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 266:FreeRTOS/Source/tasks.c **** 
 267:FreeRTOS/Source/tasks.c **** #endif
 268:FreeRTOS/Source/tasks.c **** 
 269:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 270:FreeRTOS/Source/tasks.c **** 
 271:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 272:FreeRTOS/Source/tasks.c **** 
 273:FreeRTOS/Source/tasks.c **** /*
 274:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 275:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 276:FreeRTOS/Source/tasks.c ****  */
 277:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 278:FreeRTOS/Source/tasks.c **** 
 279:FreeRTOS/Source/tasks.c **** /*
 280:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 281:FreeRTOS/Source/tasks.c ****  */
 282:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 283:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 284:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 285:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 286:FreeRTOS/Source/tasks.c **** 
 287:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 288:FreeRTOS/Source/tasks.c **** 
 289:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 290:FreeRTOS/Source/tasks.c **** 
 291:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 292:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 293:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 294:FreeRTOS/Source/tasks.c **** 
 295:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 296:FreeRTOS/Source/tasks.c **** 	state task. */
 297:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 298:FreeRTOS/Source/tasks.c **** 	{																									\
 299:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 300:FreeRTOS/Source/tasks.c **** 		{																								\
 301:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 302:FreeRTOS/Source/tasks.c **** 		}																								\
 303:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 306:FreeRTOS/Source/tasks.c **** 
 307:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 308:FreeRTOS/Source/tasks.c **** 	{																									\
 309:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 310:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
 311:FreeRTOS/Source/tasks.c **** 		{																								\
 312:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );															\
 313:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;																		\
 314:FreeRTOS/Source/tasks.c **** 		}																								\
 315:FreeRTOS/Source/tasks.c **** 																										\
 316:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 317:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 318:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
 319:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 320:FreeRTOS/Source/tasks.c **** 
 321:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 322:FreeRTOS/Source/tasks.c **** 
 323:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 324:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 325:FreeRTOS/Source/tasks.c **** 	being used. */
 326:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 327:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 330:FreeRTOS/Source/tasks.c **** 
 331:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 332:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 333:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 336:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 337:FreeRTOS/Source/tasks.c **** 
 338:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 339:FreeRTOS/Source/tasks.c **** 
 340:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 341:FreeRTOS/Source/tasks.c **** 	{																								\
 342:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 343:FreeRTOS/Source/tasks.c **** 																									\
 344:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 345:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 346:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 347:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 348:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 349:FreeRTOS/Source/tasks.c **** 
 350:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 351:FreeRTOS/Source/tasks.c **** 
 352:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 353:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 354:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 355:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 356:FreeRTOS/Source/tasks.c **** 	{																									\
 357:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 358:FreeRTOS/Source/tasks.c **** 		{																								\
 359:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 360:FreeRTOS/Source/tasks.c **** 		}																								\
 361:FreeRTOS/Source/tasks.c **** 	}
 362:FreeRTOS/Source/tasks.c **** 
 363:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 364:FreeRTOS/Source/tasks.c **** 
 365:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 366:FreeRTOS/Source/tasks.c **** 
 367:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 368:FreeRTOS/Source/tasks.c **** count overflows. */
 369:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 370:FreeRTOS/Source/tasks.c **** {																									\
 371:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 372:FreeRTOS/Source/tasks.c **** 																									\
 373:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 374:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 375:FreeRTOS/Source/tasks.c **** 																									\
 376:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 377:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 378:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 379:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 380:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 381:FreeRTOS/Source/tasks.c **** }
 382:FreeRTOS/Source/tasks.c **** 
 383:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 384:FreeRTOS/Source/tasks.c **** 
 385:FreeRTOS/Source/tasks.c **** /*
 386:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 387:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 388:FreeRTOS/Source/tasks.c ****  */
 389:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 390:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 391:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 392:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 393:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 394:FreeRTOS/Source/tasks.c **** 
 395:FreeRTOS/Source/tasks.c **** /*
 396:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 397:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 398:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 399:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 400:FreeRTOS/Source/tasks.c ****  */
 401:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 402:FreeRTOS/Source/tasks.c **** 
 403:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 404:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 405:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 406:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 407:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 408:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 409:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 410:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 411:FreeRTOS/Source/tasks.c **** #if configUSE_16_BIT_TICKS == 1
 412:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 413:FreeRTOS/Source/tasks.c **** #else
 414:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 415:FreeRTOS/Source/tasks.c **** #endif
 416:FreeRTOS/Source/tasks.c **** 
 417:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 418:FreeRTOS/Source/tasks.c **** #if configCHECK_FOR_STACK_OVERFLOW > 0
 419:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 420:FreeRTOS/Source/tasks.c **** #endif
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** #if configUSE_TICK_HOOK > 0
 423:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void );
 424:FreeRTOS/Source/tasks.c **** #endif
 425:FreeRTOS/Source/tasks.c **** 
 426:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 427:FreeRTOS/Source/tasks.c **** 
 428:FreeRTOS/Source/tasks.c **** /*
 429:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 430:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 431:FreeRTOS/Source/tasks.c ****  */
 432:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
 433:FreeRTOS/Source/tasks.c **** 
 434:FreeRTOS/Source/tasks.c **** /**
 435:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 436:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 437:FreeRTOS/Source/tasks.c ****  * is in any other state.
 438:FreeRTOS/Source/tasks.c ****  */
 439:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 440:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 441:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 442:FreeRTOS/Source/tasks.c **** 
 443:FreeRTOS/Source/tasks.c **** /*
 444:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 445:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 446:FreeRTOS/Source/tasks.c ****  */
 447:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 448:FreeRTOS/Source/tasks.c **** 
 449:FreeRTOS/Source/tasks.c **** /*
 450:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 451:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 452:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 453:FreeRTOS/Source/tasks.c ****  *
 454:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 455:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 456:FreeRTOS/Source/tasks.c ****  *
 457:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 458:FreeRTOS/Source/tasks.c ****  *
 459:FreeRTOS/Source/tasks.c ****  */
 460:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 461:FreeRTOS/Source/tasks.c **** 
 462:FreeRTOS/Source/tasks.c **** /*
 463:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 464:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 465:FreeRTOS/Source/tasks.c ****  *
 466:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 467:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 468:FreeRTOS/Source/tasks.c ****  */
 469:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 470:FreeRTOS/Source/tasks.c **** 
 471:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 472:FreeRTOS/Source/tasks.c **** 
 473:FreeRTOS/Source/tasks.c **** #endif
 474:FreeRTOS/Source/tasks.c **** 
 475:FreeRTOS/Source/tasks.c **** /*
 476:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 477:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 478:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 479:FreeRTOS/Source/tasks.c ****  */
 480:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** /*
 483:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 484:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 485:FreeRTOS/Source/tasks.c ****  */
 486:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
 487:FreeRTOS/Source/tasks.c **** 
 488:FreeRTOS/Source/tasks.c **** /*
 489:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 490:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 491:FreeRTOS/Source/tasks.c ****  */
 492:FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
 493:FreeRTOS/Source/tasks.c **** 
 494:FreeRTOS/Source/tasks.c **** /*
 495:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 496:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 497:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 498:FreeRTOS/Source/tasks.c ****  *
 499:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 500:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 501:FreeRTOS/Source/tasks.c ****  */
 502:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 503:FreeRTOS/Source/tasks.c **** 
 504:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
 505:FreeRTOS/Source/tasks.c **** 
 506:FreeRTOS/Source/tasks.c **** #endif
 507:FreeRTOS/Source/tasks.c **** 
 508:FreeRTOS/Source/tasks.c **** /*
 509:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 510:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 511:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 512:FreeRTOS/Source/tasks.c ****  */
 513:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 514:FreeRTOS/Source/tasks.c **** 
 515:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 516:FreeRTOS/Source/tasks.c **** 
 517:FreeRTOS/Source/tasks.c **** #endif
 518:FreeRTOS/Source/tasks.c **** 
 519:FreeRTOS/Source/tasks.c **** /*
 520:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 521:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 522:FreeRTOS/Source/tasks.c ****  *
 523:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 524:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 525:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 526:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 527:FreeRTOS/Source/tasks.c ****  */
 528:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 529:FreeRTOS/Source/tasks.c **** 
 530:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 531:FreeRTOS/Source/tasks.c **** 
 532:FreeRTOS/Source/tasks.c **** #endif
 533:FreeRTOS/Source/tasks.c **** 
 534:FreeRTOS/Source/tasks.c **** /*
 535:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 536:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 537:FreeRTOS/Source/tasks.c ****  */
 538:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 539:FreeRTOS/Source/tasks.c **** 
 540:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 541:FreeRTOS/Source/tasks.c **** 
 542:FreeRTOS/Source/tasks.c **** 	/*
 543:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 544:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 545:FreeRTOS/Source/tasks.c **** 	 */
 546:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
 547:FreeRTOS/Source/tasks.c **** 
 548:FreeRTOS/Source/tasks.c **** #endif
 549:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 550:FreeRTOS/Source/tasks.c **** 
 551:FreeRTOS/Source/tasks.c **** BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t
 552:FreeRTOS/Source/tasks.c **** {
 553:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 554:FreeRTOS/Source/tasks.c **** TCB_t * pxNewTCB;
 555:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 556:FreeRTOS/Source/tasks.c **** 
 557:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 558:FreeRTOS/Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMA
 559:FreeRTOS/Source/tasks.c **** 
 560:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 561:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 562:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 563:FreeRTOS/Source/tasks.c **** 
 564:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 565:FreeRTOS/Source/tasks.c **** 	{
 566:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 567:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 568:FreeRTOS/Source/tasks.c **** 			BaseType_t xRunPrivileged;
 569:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 570:FreeRTOS/Source/tasks.c **** 			{
 571:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 572:FreeRTOS/Source/tasks.c **** 			}
 573:FreeRTOS/Source/tasks.c **** 			else
 574:FreeRTOS/Source/tasks.c **** 			{
 575:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 576:FreeRTOS/Source/tasks.c **** 			}
 577:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 578:FreeRTOS/Source/tasks.c **** 
 579:FreeRTOS/Source/tasks.c **** 			if( puxStackBuffer != NULL )
 580:FreeRTOS/Source/tasks.c **** 			{
 581:FreeRTOS/Source/tasks.c **** 				/* The application provided its own stack.  Note this so no
 582:FreeRTOS/Source/tasks.c **** 				attempt is made to delete the stack should that task be
 583:FreeRTOS/Source/tasks.c **** 				deleted. */
 584:FreeRTOS/Source/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
 585:FreeRTOS/Source/tasks.c **** 			}
 586:FreeRTOS/Source/tasks.c **** 			else
 587:FreeRTOS/Source/tasks.c **** 			{
 588:FreeRTOS/Source/tasks.c **** 				/* The stack was allocated dynamically.  Note this so it can be
 589:FreeRTOS/Source/tasks.c **** 				deleted again if the task is deleted. */
 590:FreeRTOS/Source/tasks.c **** 				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
 591:FreeRTOS/Source/tasks.c **** 			}
 592:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 593:FreeRTOS/Source/tasks.c **** 
 594:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 595:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or vice versa.
 596:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 597:FreeRTOS/Source/tasks.c **** 		required by the port. */
 598:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 599:FreeRTOS/Source/tasks.c **** 		{
 600:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 601:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINT
 602:FreeRTOS/Source/tasks.c **** 
 603:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 604:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_AL
 605:FreeRTOS/Source/tasks.c **** 		}
 606:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 607:FreeRTOS/Source/tasks.c **** 		{
 608:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 609:FreeRTOS/Source/tasks.c **** 
 610:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 611:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBY
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 614:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 615:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 616:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 617:FreeRTOS/Source/tasks.c **** 		}
 618:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 619:FreeRTOS/Source/tasks.c **** 
 620:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 621:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 622:FreeRTOS/Source/tasks.c **** 
 623:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 624:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 625:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 626:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 627:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 628:FreeRTOS/Source/tasks.c **** 		{
 629:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 630:FreeRTOS/Source/tasks.c **** 		}
 631:FreeRTOS/Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 632:FreeRTOS/Source/tasks.c **** 		{
 633:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 634:FreeRTOS/Source/tasks.c **** 		}
 635:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 636:FreeRTOS/Source/tasks.c **** 
 637:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 638:FreeRTOS/Source/tasks.c **** 		{
 639:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 640:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 641:FreeRTOS/Source/tasks.c **** 			required.*/
 642:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 643:FreeRTOS/Source/tasks.c **** 		}
 644:FreeRTOS/Source/tasks.c **** 		else
 645:FreeRTOS/Source/tasks.c **** 		{
 646:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 647:FreeRTOS/Source/tasks.c **** 		}
 648:FreeRTOS/Source/tasks.c **** 
 649:FreeRTOS/Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 650:FreeRTOS/Source/tasks.c **** 		updated. */
 651:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 652:FreeRTOS/Source/tasks.c **** 		{
 653:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 654:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 655:FreeRTOS/Source/tasks.c **** 			{
 656:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 657:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 658:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 659:FreeRTOS/Source/tasks.c **** 
 660:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 661:FreeRTOS/Source/tasks.c **** 				{
 662:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 663:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 664:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 665:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 666:FreeRTOS/Source/tasks.c **** 				}
 667:FreeRTOS/Source/tasks.c **** 				else
 668:FreeRTOS/Source/tasks.c **** 				{
 669:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 670:FreeRTOS/Source/tasks.c **** 				}
 671:FreeRTOS/Source/tasks.c **** 			}
 672:FreeRTOS/Source/tasks.c **** 			else
 673:FreeRTOS/Source/tasks.c **** 			{
 674:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 675:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 676:FreeRTOS/Source/tasks.c **** 				so far. */
 677:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 678:FreeRTOS/Source/tasks.c **** 				{
 679:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 680:FreeRTOS/Source/tasks.c **** 					{
 681:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 682:FreeRTOS/Source/tasks.c **** 					}
 683:FreeRTOS/Source/tasks.c **** 					else
 684:FreeRTOS/Source/tasks.c **** 					{
 685:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
 686:FreeRTOS/Source/tasks.c **** 					}
 687:FreeRTOS/Source/tasks.c **** 				}
 688:FreeRTOS/Source/tasks.c **** 				else
 689:FreeRTOS/Source/tasks.c **** 				{
 690:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 691:FreeRTOS/Source/tasks.c **** 				}
 692:FreeRTOS/Source/tasks.c **** 			}
 693:FreeRTOS/Source/tasks.c **** 
 694:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 695:FreeRTOS/Source/tasks.c **** 
 696:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 697:FreeRTOS/Source/tasks.c **** 			{
 698:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 699:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 700:FreeRTOS/Source/tasks.c **** 			}
 701:FreeRTOS/Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 702:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 703:FreeRTOS/Source/tasks.c **** 
 704:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 705:FreeRTOS/Source/tasks.c **** 
 706:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 707:FreeRTOS/Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 708:FreeRTOS/Source/tasks.c **** 		}
 709:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 710:FreeRTOS/Source/tasks.c **** 	}
 711:FreeRTOS/Source/tasks.c **** 	else
 712:FreeRTOS/Source/tasks.c **** 	{
 713:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 714:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 715:FreeRTOS/Source/tasks.c **** 	}
 716:FreeRTOS/Source/tasks.c **** 
 717:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 718:FreeRTOS/Source/tasks.c **** 	{
 719:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 720:FreeRTOS/Source/tasks.c **** 		{
 721:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 722:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 723:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 724:FreeRTOS/Source/tasks.c **** 			{
 725:FreeRTOS/Source/tasks.c **** 				taskYIELD_IF_USING_PREEMPTION();
 726:FreeRTOS/Source/tasks.c **** 			}
 727:FreeRTOS/Source/tasks.c **** 			else
 728:FreeRTOS/Source/tasks.c **** 			{
 729:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 730:FreeRTOS/Source/tasks.c **** 			}
 731:FreeRTOS/Source/tasks.c **** 		}
 732:FreeRTOS/Source/tasks.c **** 		else
 733:FreeRTOS/Source/tasks.c **** 		{
 734:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 735:FreeRTOS/Source/tasks.c **** 		}
 736:FreeRTOS/Source/tasks.c **** 	}
 737:FreeRTOS/Source/tasks.c **** 
 738:FreeRTOS/Source/tasks.c **** 	return xReturn;
 739:FreeRTOS/Source/tasks.c **** }
 740:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 741:FreeRTOS/Source/tasks.c **** 
 742:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 743:FreeRTOS/Source/tasks.c **** 
 744:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
 745:FreeRTOS/Source/tasks.c **** 	{
 746:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 747:FreeRTOS/Source/tasks.c **** 
 748:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 749:FreeRTOS/Source/tasks.c **** 		{
 750:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
 751:FreeRTOS/Source/tasks.c **** 			being deleted. */
 752:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 753:FreeRTOS/Source/tasks.c **** 
 754:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 755:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 756:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 757:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 758:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 759:FreeRTOS/Source/tasks.c **** 			{
 760:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 761:FreeRTOS/Source/tasks.c **** 			}
 762:FreeRTOS/Source/tasks.c **** 			else
 763:FreeRTOS/Source/tasks.c **** 			{
 764:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 765:FreeRTOS/Source/tasks.c **** 			}
 766:FreeRTOS/Source/tasks.c **** 
 767:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 768:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 769:FreeRTOS/Source/tasks.c **** 			{
 770:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 771:FreeRTOS/Source/tasks.c **** 			}
 772:FreeRTOS/Source/tasks.c **** 			else
 773:FreeRTOS/Source/tasks.c **** 			{
 774:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 775:FreeRTOS/Source/tasks.c **** 			}
 776:FreeRTOS/Source/tasks.c **** 
 777:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 780:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 781:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 782:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 783:FreeRTOS/Source/tasks.c **** 
 784:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 785:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 786:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 789:FreeRTOS/Source/tasks.c **** 		}
 790:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 791:FreeRTOS/Source/tasks.c **** 
 792:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
 793:FreeRTOS/Source/tasks.c **** 		been deleted. */
 794:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 795:FreeRTOS/Source/tasks.c **** 		{
 796:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 797:FreeRTOS/Source/tasks.c **** 			{
 798:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
 799:FreeRTOS/Source/tasks.c **** 
 800:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
 801:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
 802:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
 803:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
 804:FreeRTOS/Source/tasks.c **** 				required. */
 805:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 806:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 807:FreeRTOS/Source/tasks.c **** 			}
 808:FreeRTOS/Source/tasks.c **** 			else
 809:FreeRTOS/Source/tasks.c **** 			{
 810:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
 811:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
 812:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 813:FreeRTOS/Source/tasks.c **** 				{
 814:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 815:FreeRTOS/Source/tasks.c **** 				}
 816:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 817:FreeRTOS/Source/tasks.c **** 			}
 818:FreeRTOS/Source/tasks.c **** 		}
 819:FreeRTOS/Source/tasks.c **** 	}
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 822:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 823:FreeRTOS/Source/tasks.c **** 
 824:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 825:FreeRTOS/Source/tasks.c **** 
 826:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
 827:FreeRTOS/Source/tasks.c **** 	{
 828:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 829:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 830:FreeRTOS/Source/tasks.c **** 
 831:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 832:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 833:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
 834:FreeRTOS/Source/tasks.c **** 
 835:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 836:FreeRTOS/Source/tasks.c **** 		{
 837:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 838:FreeRTOS/Source/tasks.c **** 			block. */
 839:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 840:FreeRTOS/Source/tasks.c **** 
 841:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 842:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 843:FreeRTOS/Source/tasks.c **** 
 844:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 845:FreeRTOS/Source/tasks.c **** 			{
 846:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 847:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 848:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 849:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 850:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 851:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 852:FreeRTOS/Source/tasks.c **** 				{
 853:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 854:FreeRTOS/Source/tasks.c **** 				}
 855:FreeRTOS/Source/tasks.c **** 				else
 856:FreeRTOS/Source/tasks.c **** 				{
 857:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 858:FreeRTOS/Source/tasks.c **** 				}
 859:FreeRTOS/Source/tasks.c **** 			}
 860:FreeRTOS/Source/tasks.c **** 			else
 861:FreeRTOS/Source/tasks.c **** 			{
 862:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 863:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 864:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 865:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 866:FreeRTOS/Source/tasks.c **** 				{
 867:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 				else
 870:FreeRTOS/Source/tasks.c **** 				{
 871:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 872:FreeRTOS/Source/tasks.c **** 				}
 873:FreeRTOS/Source/tasks.c **** 			}
 874:FreeRTOS/Source/tasks.c **** 
 875:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 876:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 877:FreeRTOS/Source/tasks.c **** 
 878:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 879:FreeRTOS/Source/tasks.c **** 			{
 880:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 881:FreeRTOS/Source/tasks.c **** 
 882:FreeRTOS/Source/tasks.c **** 				/* Remove the task from the ready list before adding it to the
 883:FreeRTOS/Source/tasks.c **** 				blocked list as the same list item is used for both lists. */
 884:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 885:FreeRTOS/Source/tasks.c **** 				{
 886:FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 887:FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 888:FreeRTOS/Source/tasks.c **** 					directly. */
 889:FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 890:FreeRTOS/Source/tasks.c **** 				}
 891:FreeRTOS/Source/tasks.c **** 				else
 892:FreeRTOS/Source/tasks.c **** 				{
 893:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 894:FreeRTOS/Source/tasks.c **** 				}
 895:FreeRTOS/Source/tasks.c **** 
 896:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 897:FreeRTOS/Source/tasks.c **** 			}
 898:FreeRTOS/Source/tasks.c **** 			else
 899:FreeRTOS/Source/tasks.c **** 			{
 900:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 901:FreeRTOS/Source/tasks.c **** 			}
 902:FreeRTOS/Source/tasks.c **** 		}
 903:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 904:FreeRTOS/Source/tasks.c **** 
 905:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 906:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 907:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 908:FreeRTOS/Source/tasks.c **** 		{
 909:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 910:FreeRTOS/Source/tasks.c **** 		}
 911:FreeRTOS/Source/tasks.c **** 		else
 912:FreeRTOS/Source/tasks.c **** 		{
 913:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 914:FreeRTOS/Source/tasks.c **** 		}
 915:FreeRTOS/Source/tasks.c **** 	}
 916:FreeRTOS/Source/tasks.c **** 
 917:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 918:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 919:FreeRTOS/Source/tasks.c **** 
 920:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
 923:FreeRTOS/Source/tasks.c **** 	{
 924:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 925:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 926:FreeRTOS/Source/tasks.c **** 
 927:FreeRTOS/Source/tasks.c **** 
 928:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 929:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 930:FreeRTOS/Source/tasks.c **** 		{
 931:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
 932:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 933:FreeRTOS/Source/tasks.c **** 			{
 934:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 935:FreeRTOS/Source/tasks.c **** 
 936:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 937:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 938:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 939:FreeRTOS/Source/tasks.c **** 				is resumed.
 940:FreeRTOS/Source/tasks.c **** 
 941:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 942:FreeRTOS/Source/tasks.c **** 				executing task. */
 943:FreeRTOS/Source/tasks.c **** 
 944:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 945:FreeRTOS/Source/tasks.c **** 				not a problem. */
 946:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 949:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 950:FreeRTOS/Source/tasks.c **** 				both lists. */
 951:FreeRTOS/Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 952:FreeRTOS/Source/tasks.c **** 				{
 953:FreeRTOS/Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 954:FreeRTOS/Source/tasks.c **** 					no need to check, and the port reset macro can be called
 955:FreeRTOS/Source/tasks.c **** 					directly. */
 956:FreeRTOS/Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 957:FreeRTOS/Source/tasks.c **** 				}
 958:FreeRTOS/Source/tasks.c **** 				else
 959:FreeRTOS/Source/tasks.c **** 				{
 960:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
 961:FreeRTOS/Source/tasks.c **** 				}
 962:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 963:FreeRTOS/Source/tasks.c **** 			}
 964:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 965:FreeRTOS/Source/tasks.c **** 		}
 966:FreeRTOS/Source/tasks.c **** 		else
 967:FreeRTOS/Source/tasks.c **** 		{
 968:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 969:FreeRTOS/Source/tasks.c **** 		}
 970:FreeRTOS/Source/tasks.c **** 
 971:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 972:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 973:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 974:FreeRTOS/Source/tasks.c **** 		{
 975:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 976:FreeRTOS/Source/tasks.c **** 		}
 977:FreeRTOS/Source/tasks.c **** 		else
 978:FreeRTOS/Source/tasks.c **** 		{
 979:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 980:FreeRTOS/Source/tasks.c **** 		}
 981:FreeRTOS/Source/tasks.c **** 	}
 982:FreeRTOS/Source/tasks.c **** 
 983:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 984:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 985:FreeRTOS/Source/tasks.c **** 
 986:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 987:FreeRTOS/Source/tasks.c **** 
 988:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
 989:FreeRTOS/Source/tasks.c **** 	{
 990:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
 991:FreeRTOS/Source/tasks.c **** 	List_t *pxStateList;
 992:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
 995:FreeRTOS/Source/tasks.c **** 
 996:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 997:FreeRTOS/Source/tasks.c **** 		{
 998:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 999:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1000:FreeRTOS/Source/tasks.c **** 		}
1001:FreeRTOS/Source/tasks.c **** 		else
1002:FreeRTOS/Source/tasks.c **** 		{
1003:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1004:FreeRTOS/Source/tasks.c **** 			{
1005:FreeRTOS/Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
1006:FreeRTOS/Source/tasks.c **** 			}
1007:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1008:FreeRTOS/Source/tasks.c **** 
1009:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
1010:FreeRTOS/Source/tasks.c **** 			{
1011:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1012:FreeRTOS/Source/tasks.c **** 				lists. */
1013:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1014:FreeRTOS/Source/tasks.c **** 			}
1015:FreeRTOS/Source/tasks.c **** 
1016:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1017:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1018:FreeRTOS/Source/tasks.c **** 				{
1019:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1020:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
1021:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1022:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1023:FreeRTOS/Source/tasks.c **** 					{
1024:FreeRTOS/Source/tasks.c **** 						eReturn = eSuspended;
1025:FreeRTOS/Source/tasks.c **** 					}
1026:FreeRTOS/Source/tasks.c **** 					else
1027:FreeRTOS/Source/tasks.c **** 					{
1028:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1029:FreeRTOS/Source/tasks.c **** 					}
1030:FreeRTOS/Source/tasks.c **** 				}
1031:FreeRTOS/Source/tasks.c **** 			#endif
1032:FreeRTOS/Source/tasks.c **** 
1033:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1034:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
1035:FreeRTOS/Source/tasks.c **** 				{
1036:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1037:FreeRTOS/Source/tasks.c **** 					tasks list. */
1038:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1039:FreeRTOS/Source/tasks.c **** 				}
1040:FreeRTOS/Source/tasks.c **** 			#endif
1041:FreeRTOS/Source/tasks.c **** 
1042:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1043:FreeRTOS/Source/tasks.c **** 			{
1044:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1045:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1046:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1047:FreeRTOS/Source/tasks.c **** 			}
1048:FreeRTOS/Source/tasks.c **** 		}
1049:FreeRTOS/Source/tasks.c **** 
1050:FreeRTOS/Source/tasks.c **** 		return eReturn;
1051:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1052:FreeRTOS/Source/tasks.c **** 
1053:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1054:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1055:FreeRTOS/Source/tasks.c **** 
1056:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1057:FreeRTOS/Source/tasks.c **** 
1058:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1059:FreeRTOS/Source/tasks.c **** 	{
1060:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1061:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1062:FreeRTOS/Source/tasks.c **** 
1063:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1064:FreeRTOS/Source/tasks.c **** 		{
1065:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1066:FreeRTOS/Source/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1067:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1068:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1069:FreeRTOS/Source/tasks.c **** 		}
1070:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1071:FreeRTOS/Source/tasks.c **** 
1072:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1073:FreeRTOS/Source/tasks.c **** 	}
1074:FreeRTOS/Source/tasks.c **** 
1075:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1076:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1077:FreeRTOS/Source/tasks.c **** 
1078:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1079:FreeRTOS/Source/tasks.c **** 
1080:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1081:FreeRTOS/Source/tasks.c **** 	{
1082:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1083:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1084:FreeRTOS/Source/tasks.c **** 
1085:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1086:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1087:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1088:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1089:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1090:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1091:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1092:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1093:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1094:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1095:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1096:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1097:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1098:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1099:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1100:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1101:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1102:FreeRTOS/Source/tasks.c **** 
1103:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1104:FreeRTOS/Source/tasks.c **** 		{
1105:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1106:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1107:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1108:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
1109:FreeRTOS/Source/tasks.c **** 		}
1110:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1111:FreeRTOS/Source/tasks.c **** 
1112:FreeRTOS/Source/tasks.c **** 		return uxReturn;
1113:FreeRTOS/Source/tasks.c **** 	}
1114:FreeRTOS/Source/tasks.c **** 
1115:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1116:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1117:FreeRTOS/Source/tasks.c **** 
1118:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1119:FreeRTOS/Source/tasks.c **** 
1120:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1121:FreeRTOS/Source/tasks.c **** 	{
1122:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1123:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1124:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1125:FreeRTOS/Source/tasks.c **** 
1126:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1127:FreeRTOS/Source/tasks.c **** 
1128:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1129:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1130:FreeRTOS/Source/tasks.c **** 		{
1131:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1132:FreeRTOS/Source/tasks.c **** 		}
1133:FreeRTOS/Source/tasks.c **** 		else
1134:FreeRTOS/Source/tasks.c **** 		{
1135:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1136:FreeRTOS/Source/tasks.c **** 		}
1137:FreeRTOS/Source/tasks.c **** 
1138:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1139:FreeRTOS/Source/tasks.c **** 		{
1140:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1141:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1142:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
1143:FreeRTOS/Source/tasks.c **** 
1144:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1145:FreeRTOS/Source/tasks.c **** 
1146:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1147:FreeRTOS/Source/tasks.c **** 			{
1148:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1149:FreeRTOS/Source/tasks.c **** 			}
1150:FreeRTOS/Source/tasks.c **** 			#else
1151:FreeRTOS/Source/tasks.c **** 			{
1152:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1153:FreeRTOS/Source/tasks.c **** 			}
1154:FreeRTOS/Source/tasks.c **** 			#endif
1155:FreeRTOS/Source/tasks.c **** 
1156:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
1157:FreeRTOS/Source/tasks.c **** 			{
1158:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1159:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1160:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
1161:FreeRTOS/Source/tasks.c **** 				{
1162:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
1163:FreeRTOS/Source/tasks.c **** 					{
1164:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1165:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1166:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1167:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
1168:FreeRTOS/Source/tasks.c **** 						{
1169:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
1170:FreeRTOS/Source/tasks.c **** 						}
1171:FreeRTOS/Source/tasks.c **** 						else
1172:FreeRTOS/Source/tasks.c **** 						{
1173:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1174:FreeRTOS/Source/tasks.c **** 						}
1175:FreeRTOS/Source/tasks.c **** 					}
1176:FreeRTOS/Source/tasks.c **** 					else
1177:FreeRTOS/Source/tasks.c **** 					{
1178:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1179:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1180:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1181:FreeRTOS/Source/tasks.c **** 					}
1182:FreeRTOS/Source/tasks.c **** 				}
1183:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
1184:FreeRTOS/Source/tasks.c **** 				{
1185:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1186:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1187:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1188:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
1189:FreeRTOS/Source/tasks.c **** 				}
1190:FreeRTOS/Source/tasks.c **** 				else
1191:FreeRTOS/Source/tasks.c **** 				{
1192:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1193:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1194:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1195:FreeRTOS/Source/tasks.c **** 				}
1196:FreeRTOS/Source/tasks.c **** 
1197:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1198:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1199:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1200:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
1201:FreeRTOS/Source/tasks.c **** 
1202:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1203:FreeRTOS/Source/tasks.c **** 				{
1204:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1205:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1206:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1207:FreeRTOS/Source/tasks.c **** 					{
1208:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1209:FreeRTOS/Source/tasks.c **** 					}
1210:FreeRTOS/Source/tasks.c **** 					else
1211:FreeRTOS/Source/tasks.c **** 					{
1212:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1213:FreeRTOS/Source/tasks.c **** 					}
1214:FreeRTOS/Source/tasks.c **** 
1215:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1216:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1217:FreeRTOS/Source/tasks.c **** 				}
1218:FreeRTOS/Source/tasks.c **** 				#else
1219:FreeRTOS/Source/tasks.c **** 				{
1220:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1221:FreeRTOS/Source/tasks.c **** 				}
1222:FreeRTOS/Source/tasks.c **** 				#endif
1223:FreeRTOS/Source/tasks.c **** 
1224:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1225:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1226:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
1227:FreeRTOS/Source/tasks.c **** 				{
1228:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
1229:FreeRTOS/Source/tasks.c **** 				}
1230:FreeRTOS/Source/tasks.c **** 				else
1231:FreeRTOS/Source/tasks.c **** 				{
1232:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1233:FreeRTOS/Source/tasks.c **** 				}
1234:FreeRTOS/Source/tasks.c **** 
1235:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1236:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1237:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1238:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1239:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
1240:FreeRTOS/Source/tasks.c **** 				{
1241:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1242:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1243:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1244:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1245:FreeRTOS/Source/tasks.c **** 					{
1246:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1247:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1248:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1249:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1250:FreeRTOS/Source/tasks.c **** 					}
1251:FreeRTOS/Source/tasks.c **** 					else
1252:FreeRTOS/Source/tasks.c **** 					{
1253:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1254:FreeRTOS/Source/tasks.c **** 					}
1255:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1256:FreeRTOS/Source/tasks.c **** 				}
1257:FreeRTOS/Source/tasks.c **** 				else
1258:FreeRTOS/Source/tasks.c **** 				{
1259:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1260:FreeRTOS/Source/tasks.c **** 				}
1261:FreeRTOS/Source/tasks.c **** 
1262:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
1263:FreeRTOS/Source/tasks.c **** 				{
1264:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1265:FreeRTOS/Source/tasks.c **** 				}
1266:FreeRTOS/Source/tasks.c **** 				else
1267:FreeRTOS/Source/tasks.c **** 				{
1268:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1269:FreeRTOS/Source/tasks.c **** 				}
1270:FreeRTOS/Source/tasks.c **** 
1271:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1272:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1273:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1274:FreeRTOS/Source/tasks.c **** 			}
1275:FreeRTOS/Source/tasks.c **** 		}
1276:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1277:FreeRTOS/Source/tasks.c **** 	}
1278:FreeRTOS/Source/tasks.c **** 
1279:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1280:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1281:FreeRTOS/Source/tasks.c **** 
1282:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1283:FreeRTOS/Source/tasks.c **** 
1284:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1285:FreeRTOS/Source/tasks.c **** 	{
1286:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1287:FreeRTOS/Source/tasks.c **** 
1288:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1289:FreeRTOS/Source/tasks.c **** 		{
1290:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1291:FreeRTOS/Source/tasks.c **** 			being suspended. */
1292:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1293:FreeRTOS/Source/tasks.c **** 
1294:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1295:FreeRTOS/Source/tasks.c **** 
1296:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1297:FreeRTOS/Source/tasks.c **** 			suspended list. */
1298:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
1299:FreeRTOS/Source/tasks.c **** 			{
1300:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1301:FreeRTOS/Source/tasks.c **** 			}
1302:FreeRTOS/Source/tasks.c **** 			else
1303:FreeRTOS/Source/tasks.c **** 			{
1304:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1305:FreeRTOS/Source/tasks.c **** 			}
1306:FreeRTOS/Source/tasks.c **** 
1307:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1308:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1309:FreeRTOS/Source/tasks.c **** 			{
1310:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1311:FreeRTOS/Source/tasks.c **** 			}
1312:FreeRTOS/Source/tasks.c **** 			else
1313:FreeRTOS/Source/tasks.c **** 			{
1314:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1315:FreeRTOS/Source/tasks.c **** 			}
1316:FreeRTOS/Source/tasks.c **** 
1317:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
1318:FreeRTOS/Source/tasks.c **** 		}
1319:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1320:FreeRTOS/Source/tasks.c **** 
1321:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1322:FreeRTOS/Source/tasks.c **** 		{
1323:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1324:FreeRTOS/Source/tasks.c **** 			{
1325:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1326:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1327:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
1328:FreeRTOS/Source/tasks.c **** 			}
1329:FreeRTOS/Source/tasks.c **** 			else
1330:FreeRTOS/Source/tasks.c **** 			{
1331:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1332:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1333:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1334:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
1335:FreeRTOS/Source/tasks.c **** 				{
1336:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1337:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1338:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
1339:FreeRTOS/Source/tasks.c **** 					is. */
1340:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1341:FreeRTOS/Source/tasks.c **** 				}
1342:FreeRTOS/Source/tasks.c **** 				else
1343:FreeRTOS/Source/tasks.c **** 				{
1344:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1345:FreeRTOS/Source/tasks.c **** 				}
1346:FreeRTOS/Source/tasks.c **** 			}
1347:FreeRTOS/Source/tasks.c **** 		}
1348:FreeRTOS/Source/tasks.c **** 		else
1349:FreeRTOS/Source/tasks.c **** 		{
1350:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
1351:FreeRTOS/Source/tasks.c **** 			{
1352:FreeRTOS/Source/tasks.c **** 				/* A task other than the currently running task was suspended,
1353:FreeRTOS/Source/tasks.c **** 				reset the next expected unblock time in case it referred to the
1354:FreeRTOS/Source/tasks.c **** 				task that is now in the Suspended state. */
1355:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
1356:FreeRTOS/Source/tasks.c **** 				{
1357:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
1358:FreeRTOS/Source/tasks.c **** 				}
1359:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
1360:FreeRTOS/Source/tasks.c **** 			}
1361:FreeRTOS/Source/tasks.c **** 			else
1362:FreeRTOS/Source/tasks.c **** 			{
1363:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1364:FreeRTOS/Source/tasks.c **** 			}
1365:FreeRTOS/Source/tasks.c **** 		}
1366:FreeRTOS/Source/tasks.c **** 	}
1367:FreeRTOS/Source/tasks.c **** 
1368:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1369:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1370:FreeRTOS/Source/tasks.c **** 
1371:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1374:FreeRTOS/Source/tasks.c **** 	{
1375:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
1376:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
1377:FreeRTOS/Source/tasks.c **** 
1378:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1379:FreeRTOS/Source/tasks.c **** 		section. */
1380:FreeRTOS/Source/tasks.c **** 
1381:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1382:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1383:FreeRTOS/Source/tasks.c **** 
1384:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1385:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
1386:FreeRTOS/Source/tasks.c **** 		{
1387:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1388:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
1389:FreeRTOS/Source/tasks.c **** 			{
1390:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1391:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1392:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
1393:FreeRTOS/Source/tasks.c **** 				{
1394:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
1395:FreeRTOS/Source/tasks.c **** 				}
1396:FreeRTOS/Source/tasks.c **** 				else
1397:FreeRTOS/Source/tasks.c **** 				{
1398:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1399:FreeRTOS/Source/tasks.c **** 				}
1400:FreeRTOS/Source/tasks.c **** 			}
1401:FreeRTOS/Source/tasks.c **** 			else
1402:FreeRTOS/Source/tasks.c **** 			{
1403:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1404:FreeRTOS/Source/tasks.c **** 			}
1405:FreeRTOS/Source/tasks.c **** 		}
1406:FreeRTOS/Source/tasks.c **** 		else
1407:FreeRTOS/Source/tasks.c **** 		{
1408:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1409:FreeRTOS/Source/tasks.c **** 		}
1410:FreeRTOS/Source/tasks.c **** 
1411:FreeRTOS/Source/tasks.c **** 		return xReturn;
1412:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1413:FreeRTOS/Source/tasks.c **** 
1414:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1415:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1416:FreeRTOS/Source/tasks.c **** 
1417:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1420:FreeRTOS/Source/tasks.c **** 	{
1421:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1422:FreeRTOS/Source/tasks.c **** 
1423:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1424:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1425:FreeRTOS/Source/tasks.c **** 
1426:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1427:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1428:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1429:FreeRTOS/Source/tasks.c **** 		{
1430:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1431:FreeRTOS/Source/tasks.c **** 			{
1432:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1433:FreeRTOS/Source/tasks.c **** 				{
1434:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1435:FreeRTOS/Source/tasks.c **** 
1436:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1437:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1438:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1439:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1440:FreeRTOS/Source/tasks.c **** 
1441:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1442:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1443:FreeRTOS/Source/tasks.c **** 					{
1444:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1445:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1446:FreeRTOS/Source/tasks.c **** 						next yield. */
1447:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
1448:FreeRTOS/Source/tasks.c **** 					}
1449:FreeRTOS/Source/tasks.c **** 					else
1450:FreeRTOS/Source/tasks.c **** 					{
1451:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1452:FreeRTOS/Source/tasks.c **** 					}
1453:FreeRTOS/Source/tasks.c **** 				}
1454:FreeRTOS/Source/tasks.c **** 				else
1455:FreeRTOS/Source/tasks.c **** 				{
1456:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1457:FreeRTOS/Source/tasks.c **** 				}
1458:FreeRTOS/Source/tasks.c **** 			}
1459:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1460:FreeRTOS/Source/tasks.c **** 		}
1461:FreeRTOS/Source/tasks.c **** 		else
1462:FreeRTOS/Source/tasks.c **** 		{
1463:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1464:FreeRTOS/Source/tasks.c **** 		}
1465:FreeRTOS/Source/tasks.c **** 	}
1466:FreeRTOS/Source/tasks.c **** 
1467:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1468:FreeRTOS/Source/tasks.c **** 
1469:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1470:FreeRTOS/Source/tasks.c **** 
1471:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1472:FreeRTOS/Source/tasks.c **** 
1473:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1474:FreeRTOS/Source/tasks.c **** 	{
1475:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
1476:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
1477:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1478:FreeRTOS/Source/tasks.c **** 
1479:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1480:FreeRTOS/Source/tasks.c **** 
1481:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1482:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1483:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1484:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1485:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1486:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1487:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1488:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1489:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1490:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1491:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1492:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1493:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1494:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1495:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1496:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1497:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1498:FreeRTOS/Source/tasks.c **** 
1499:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1500:FreeRTOS/Source/tasks.c **** 		{
1501:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1502:FreeRTOS/Source/tasks.c **** 			{
1503:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1504:FreeRTOS/Source/tasks.c **** 
1505:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1506:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1507:FreeRTOS/Source/tasks.c **** 				{
1508:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1509:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1510:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1511:FreeRTOS/Source/tasks.c **** 					{
1512:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1513:FreeRTOS/Source/tasks.c **** 					}
1514:FreeRTOS/Source/tasks.c **** 					else
1515:FreeRTOS/Source/tasks.c **** 					{
1516:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1517:FreeRTOS/Source/tasks.c **** 					}
1518:FreeRTOS/Source/tasks.c **** 
1519:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
1520:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1521:FreeRTOS/Source/tasks.c **** 				}
1522:FreeRTOS/Source/tasks.c **** 				else
1523:FreeRTOS/Source/tasks.c **** 				{
1524:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1525:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1526:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1527:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1528:FreeRTOS/Source/tasks.c **** 				}
1529:FreeRTOS/Source/tasks.c **** 			}
1530:FreeRTOS/Source/tasks.c **** 			else
1531:FreeRTOS/Source/tasks.c **** 			{
1532:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1533:FreeRTOS/Source/tasks.c **** 			}
1534:FreeRTOS/Source/tasks.c **** 		}
1535:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1536:FreeRTOS/Source/tasks.c **** 
1537:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1538:FreeRTOS/Source/tasks.c **** 	}
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1541:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1542:FreeRTOS/Source/tasks.c **** 
1543:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1544:FreeRTOS/Source/tasks.c **** {
1545:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1546:FreeRTOS/Source/tasks.c **** 
1547:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1548:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1549:FreeRTOS/Source/tasks.c **** 	{
1550:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1551:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1552:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1553:FreeRTOS/Source/tasks.c **** 	}
1554:FreeRTOS/Source/tasks.c **** 	#else
1555:FreeRTOS/Source/tasks.c **** 	{
1556:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1557:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORI
1558:FreeRTOS/Source/tasks.c **** 	}
1559:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1560:FreeRTOS/Source/tasks.c **** 
1561:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1562:FreeRTOS/Source/tasks.c **** 	{
1563:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1564:FreeRTOS/Source/tasks.c **** 		{
1565:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1566:FreeRTOS/Source/tasks.c **** 		}
1567:FreeRTOS/Source/tasks.c **** 		else
1568:FreeRTOS/Source/tasks.c **** 		{
1569:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1570:FreeRTOS/Source/tasks.c **** 		}
1571:FreeRTOS/Source/tasks.c **** 	}
1572:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1573:FreeRTOS/Source/tasks.c **** 
1574:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1575:FreeRTOS/Source/tasks.c **** 	{
1576:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1577:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1578:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1579:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1580:FreeRTOS/Source/tasks.c **** 		starts to run. */
1581:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1582:FreeRTOS/Source/tasks.c **** 
1583:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1584:FreeRTOS/Source/tasks.c **** 		{
1585:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1586:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first. */
1587:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1588:FreeRTOS/Source/tasks.c **** 		}
1589:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1590:FreeRTOS/Source/tasks.c **** 
1591:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
1592:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1593:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
1594:FreeRTOS/Source/tasks.c **** 
1595:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1596:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1597:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1598:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1599:FreeRTOS/Source/tasks.c **** 
1600:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1601:FreeRTOS/Source/tasks.c **** 		portable interface. */
1602:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1603:FreeRTOS/Source/tasks.c **** 		{
1604:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1605:FreeRTOS/Source/tasks.c **** 			function will not return. */
1606:FreeRTOS/Source/tasks.c **** 		}
1607:FreeRTOS/Source/tasks.c **** 		else
1608:FreeRTOS/Source/tasks.c **** 		{
1609:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1610:FreeRTOS/Source/tasks.c **** 		}
1611:FreeRTOS/Source/tasks.c **** 	}
1612:FreeRTOS/Source/tasks.c **** 	else
1613:FreeRTOS/Source/tasks.c **** 	{
1614:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1615:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1616:FreeRTOS/Source/tasks.c **** 		or the timer task. */
1617:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn );
1618:FreeRTOS/Source/tasks.c **** 	}
1619:FreeRTOS/Source/tasks.c **** }
1620:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1621:FreeRTOS/Source/tasks.c **** 
1622:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1623:FreeRTOS/Source/tasks.c **** {
1624:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1625:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1626:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1627:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1628:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1629:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
1630:FreeRTOS/Source/tasks.c **** }
1631:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1632:FreeRTOS/Source/tasks.c **** 
1633:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1634:FreeRTOS/Source/tasks.c **** {
1635:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1636:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1637:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1638:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
1639:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
1640:FreeRTOS/Source/tasks.c **** }
1641:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1642:FreeRTOS/Source/tasks.c **** 
1643:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1644:FreeRTOS/Source/tasks.c **** 
1645:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1646:FreeRTOS/Source/tasks.c **** 	{
1647:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
1648:FreeRTOS/Source/tasks.c **** 
1649:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1650:FreeRTOS/Source/tasks.c **** 		{
1651:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1652:FreeRTOS/Source/tasks.c **** 		}
1653:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1654:FreeRTOS/Source/tasks.c **** 		{
1655:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1656:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1657:FreeRTOS/Source/tasks.c **** 			processed. */
1658:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
1659:FreeRTOS/Source/tasks.c **** 		}
1660:FreeRTOS/Source/tasks.c **** 		else
1661:FreeRTOS/Source/tasks.c **** 		{
1662:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1663:FreeRTOS/Source/tasks.c **** 		}
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** 		return xReturn;
1666:FreeRTOS/Source/tasks.c **** 	}
1667:FreeRTOS/Source/tasks.c **** 
1668:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1669:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1670:FreeRTOS/Source/tasks.c **** 
1671:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
1672:FreeRTOS/Source/tasks.c **** {
1673:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
1674:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
1675:FreeRTOS/Source/tasks.c **** 
1676:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1677:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1678:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1679:FreeRTOS/Source/tasks.c **** 
1680:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1681:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1682:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1683:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1684:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1685:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1686:FreeRTOS/Source/tasks.c **** 	{
1687:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
1688:FreeRTOS/Source/tasks.c **** 
1689:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1690:FreeRTOS/Source/tasks.c **** 		{
1691:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
1692:FreeRTOS/Source/tasks.c **** 			{
1693:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1694:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1695:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
1696:FreeRTOS/Source/tasks.c **** 				{
1697:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
1698:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1699:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1700:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
1701:FreeRTOS/Source/tasks.c **** 
1702:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
1703:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
1704:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1705:FreeRTOS/Source/tasks.c **** 					{
1706:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
1707:FreeRTOS/Source/tasks.c **** 					}
1708:FreeRTOS/Source/tasks.c **** 					else
1709:FreeRTOS/Source/tasks.c **** 					{
1710:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1711:FreeRTOS/Source/tasks.c **** 					}
1712:FreeRTOS/Source/tasks.c **** 				}
1713:FreeRTOS/Source/tasks.c **** 
1714:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1715:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
1716:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
1717:FreeRTOS/Source/tasks.c **** 				time. */
1718:FreeRTOS/Source/tasks.c **** 				if( uxPendedTicks > ( UBaseType_t ) 0U )
1719:FreeRTOS/Source/tasks.c **** 				{
1720:FreeRTOS/Source/tasks.c **** 					while( uxPendedTicks > ( UBaseType_t ) 0U )
1721:FreeRTOS/Source/tasks.c **** 					{
1722:FreeRTOS/Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
1723:FreeRTOS/Source/tasks.c **** 						{
1724:FreeRTOS/Source/tasks.c **** 							xYieldPending = pdTRUE;
1725:FreeRTOS/Source/tasks.c **** 						}
1726:FreeRTOS/Source/tasks.c **** 						else
1727:FreeRTOS/Source/tasks.c **** 						{
1728:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1729:FreeRTOS/Source/tasks.c **** 						}
1730:FreeRTOS/Source/tasks.c **** 						--uxPendedTicks;
1731:FreeRTOS/Source/tasks.c **** 					}
1732:FreeRTOS/Source/tasks.c **** 				}
1733:FreeRTOS/Source/tasks.c **** 				else
1734:FreeRTOS/Source/tasks.c **** 				{
1735:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1736:FreeRTOS/Source/tasks.c **** 				}
1737:FreeRTOS/Source/tasks.c **** 
1738:FreeRTOS/Source/tasks.c **** 				if( xYieldPending == pdTRUE )
1739:FreeRTOS/Source/tasks.c **** 				{
1740:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
1741:FreeRTOS/Source/tasks.c **** 					{
1742:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
1743:FreeRTOS/Source/tasks.c **** 					}
1744:FreeRTOS/Source/tasks.c **** 					#endif
1745:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
1746:FreeRTOS/Source/tasks.c **** 				}
1747:FreeRTOS/Source/tasks.c **** 				else
1748:FreeRTOS/Source/tasks.c **** 				{
1749:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1750:FreeRTOS/Source/tasks.c **** 				}
1751:FreeRTOS/Source/tasks.c **** 			}
1752:FreeRTOS/Source/tasks.c **** 		}
1753:FreeRTOS/Source/tasks.c **** 		else
1754:FreeRTOS/Source/tasks.c **** 		{
1755:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1756:FreeRTOS/Source/tasks.c **** 		}
1757:FreeRTOS/Source/tasks.c **** 	}
1758:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1759:FreeRTOS/Source/tasks.c **** 
1760:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
1761:FreeRTOS/Source/tasks.c **** }
1762:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1763:FreeRTOS/Source/tasks.c **** 
1764:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
1765:FreeRTOS/Source/tasks.c **** {
1766:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
1767:FreeRTOS/Source/tasks.c **** 
1768:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1769:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
1770:FreeRTOS/Source/tasks.c **** 	{
1771:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
1772:FreeRTOS/Source/tasks.c **** 	}
1773:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
1774:FreeRTOS/Source/tasks.c **** 
1775:FreeRTOS/Source/tasks.c **** 	return xTicks;
1776:FreeRTOS/Source/tasks.c **** }
1777:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1778:FreeRTOS/Source/tasks.c **** 
1779:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
1780:FreeRTOS/Source/tasks.c **** {
1781:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
1782:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
1783:FreeRTOS/Source/tasks.c **** 
1784:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1785:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1786:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
1787:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1788:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1789:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1790:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1791:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1792:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1793:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1794:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1795:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1796:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1797:FreeRTOS/Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1798:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1799:FreeRTOS/Source/tasks.c **** 
1800:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
1801:FreeRTOS/Source/tasks.c **** 	{
1802:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
1803:FreeRTOS/Source/tasks.c **** 	}
1804:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1805:FreeRTOS/Source/tasks.c **** 
1806:FreeRTOS/Source/tasks.c **** 	return xReturn;
1807:FreeRTOS/Source/tasks.c **** }
1808:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
1811:FreeRTOS/Source/tasks.c **** {
1812:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1813:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
1814:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1815:FreeRTOS/Source/tasks.c **** }
1816:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1817:FreeRTOS/Source/tasks.c **** 
1818:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1819:FreeRTOS/Source/tasks.c **** 
1820:FreeRTOS/Source/tasks.c **** 	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allow
1821:FreeRTOS/Source/tasks.c **** 	{
1822:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1823:FreeRTOS/Source/tasks.c **** 
1824:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1825:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1826:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1827:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1828:FreeRTOS/Source/tasks.c **** 	}
1829:FreeRTOS/Source/tasks.c **** 
1830:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1831:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1832:FreeRTOS/Source/tasks.c **** 
1833:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1834:FreeRTOS/Source/tasks.c **** 
1835:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
1836:FreeRTOS/Source/tasks.c **** 	{
1837:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
1838:FreeRTOS/Source/tasks.c **** 
1839:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1840:FreeRTOS/Source/tasks.c **** 		{
1841:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1842:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
1843:FreeRTOS/Source/tasks.c **** 			{
1844:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1845:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
1846:FreeRTOS/Source/tasks.c **** 				do
1847:FreeRTOS/Source/tasks.c **** 				{
1848:FreeRTOS/Source/tasks.c **** 					uxQueue--;
1849:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
1850:FreeRTOS/Source/tasks.c **** 
1851:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
1852:FreeRTOS/Source/tasks.c **** 
1853:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
1854:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
1855:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayed
1856:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflo
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1859:FreeRTOS/Source/tasks.c **** 				{
1860:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1861:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1862:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
1863:FreeRTOS/Source/tasks.c **** 				}
1864:FreeRTOS/Source/tasks.c **** 				#endif
1865:FreeRTOS/Source/tasks.c **** 
1866:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1867:FreeRTOS/Source/tasks.c **** 				{
1868:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
1869:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
1870:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
1871:FreeRTOS/Source/tasks.c **** 				}
1872:FreeRTOS/Source/tasks.c **** 				#endif
1873:FreeRTOS/Source/tasks.c **** 
1874:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1875:FreeRTOS/Source/tasks.c **** 				{
1876:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1877:FreeRTOS/Source/tasks.c **** 					{
1878:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1879:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1880:FreeRTOS/Source/tasks.c **** 						#else
1881:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1882:FreeRTOS/Source/tasks.c **** 						#endif
1883:FreeRTOS/Source/tasks.c **** 					}
1884:FreeRTOS/Source/tasks.c **** 				}
1885:FreeRTOS/Source/tasks.c **** 				#else
1886:FreeRTOS/Source/tasks.c **** 				{
1887:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1888:FreeRTOS/Source/tasks.c **** 					{
1889:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
1890:FreeRTOS/Source/tasks.c **** 					}
1891:FreeRTOS/Source/tasks.c **** 				}
1892:FreeRTOS/Source/tasks.c **** 				#endif
1893:FreeRTOS/Source/tasks.c **** 			}
1894:FreeRTOS/Source/tasks.c **** 			else
1895:FreeRTOS/Source/tasks.c **** 			{
1896:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1897:FreeRTOS/Source/tasks.c **** 			}
1898:FreeRTOS/Source/tasks.c **** 		}
1899:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** 		return uxTask;
1902:FreeRTOS/Source/tasks.c **** 	}
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1905:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1906:FreeRTOS/Source/tasks.c **** 
1907:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1908:FreeRTOS/Source/tasks.c **** 
1909:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
1910:FreeRTOS/Source/tasks.c **** 	{
1911:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1912:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1913:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1914:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1915:FreeRTOS/Source/tasks.c **** 	}
1916:FreeRTOS/Source/tasks.c **** 
1917:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1918:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1919:FreeRTOS/Source/tasks.c **** 
1920:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1921:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1922:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1923:FreeRTOS/Source/tasks.c **** 1. */
1924:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1925:FreeRTOS/Source/tasks.c **** 
1926:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
1927:FreeRTOS/Source/tasks.c **** 	{
1928:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1929:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1930:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
1931:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1932:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
1933:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1934:FreeRTOS/Source/tasks.c **** 	}
1935:FreeRTOS/Source/tasks.c **** 
1936:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1937:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1938:FreeRTOS/Source/tasks.c **** 
1939:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
1940:FreeRTOS/Source/tasks.c **** {
1941:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
1942:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
1943:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
1944:FreeRTOS/Source/tasks.c **** 
1945:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1946:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1947:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1948:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1949:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1950:FreeRTOS/Source/tasks.c **** 	{
1951:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1952:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
1953:FreeRTOS/Source/tasks.c **** 		++xTickCount;
1954:FreeRTOS/Source/tasks.c **** 
1955:FreeRTOS/Source/tasks.c **** 		{
1956:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1957:FreeRTOS/Source/tasks.c **** 			block. */
1958:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
1959:FreeRTOS/Source/tasks.c **** 
1960:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount == ( TickType_t ) 0U )
1961:FreeRTOS/Source/tasks.c **** 			{
1962:FreeRTOS/Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
1963:FreeRTOS/Source/tasks.c **** 			}
1964:FreeRTOS/Source/tasks.c **** 			else
1965:FreeRTOS/Source/tasks.c **** 			{
1966:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1967:FreeRTOS/Source/tasks.c **** 			}
1968:FreeRTOS/Source/tasks.c **** 
1969:FreeRTOS/Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in
1970:FreeRTOS/Source/tasks.c **** 			the	queue in the order of their wake time - meaning once one task
1971:FreeRTOS/Source/tasks.c **** 			has been found whose block time has not expired there is no need to
1972:FreeRTOS/Source/tasks.c **** 			look any further down the list. */
1973:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
1974:FreeRTOS/Source/tasks.c **** 			{
1975:FreeRTOS/Source/tasks.c **** 				for( ;; )
1976:FreeRTOS/Source/tasks.c **** 				{
1977:FreeRTOS/Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1978:FreeRTOS/Source/tasks.c **** 					{
1979:FreeRTOS/Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime
1980:FreeRTOS/Source/tasks.c **** 						to the maximum possible value so it is extremely
1981:FreeRTOS/Source/tasks.c **** 						unlikely that the
1982:FreeRTOS/Source/tasks.c **** 						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1983:FreeRTOS/Source/tasks.c **** 						next time through. */
1984:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1985:FreeRTOS/Source/tasks.c **** 						break;
1986:FreeRTOS/Source/tasks.c **** 					}
1987:FreeRTOS/Source/tasks.c **** 					else
1988:FreeRTOS/Source/tasks.c **** 					{
1989:FreeRTOS/Source/tasks.c **** 						/* The delayed list is not empty, get the value of the
1990:FreeRTOS/Source/tasks.c **** 						item at the head of the delayed list.  This is the time
1991:FreeRTOS/Source/tasks.c **** 						at which the task at the head of the delayed list must
1992:FreeRTOS/Source/tasks.c **** 						be removed from the Blocked state. */
1993:FreeRTOS/Source/tasks.c **** 						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1994:FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1995:FreeRTOS/Source/tasks.c **** 
1996:FreeRTOS/Source/tasks.c **** 						if( xConstTickCount < xItemValue )
1997:FreeRTOS/Source/tasks.c **** 						{
1998:FreeRTOS/Source/tasks.c **** 							/* It is not time to unblock this item yet, but the
1999:FreeRTOS/Source/tasks.c **** 							item value is the time at which the task at the head
2000:FreeRTOS/Source/tasks.c **** 							of the blocked list must be removed from the Blocked
2001:FreeRTOS/Source/tasks.c **** 							state -	so record the item value in
2002:FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime. */
2003:FreeRTOS/Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
2004:FreeRTOS/Source/tasks.c **** 							break;
2005:FreeRTOS/Source/tasks.c **** 						}
2006:FreeRTOS/Source/tasks.c **** 						else
2007:FreeRTOS/Source/tasks.c **** 						{
2008:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2009:FreeRTOS/Source/tasks.c **** 						}
2010:FreeRTOS/Source/tasks.c **** 
2011:FreeRTOS/Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
2012:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
2013:FreeRTOS/Source/tasks.c **** 
2014:FreeRTOS/Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove
2015:FreeRTOS/Source/tasks.c **** 						it from the event list. */
2016:FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2017:FreeRTOS/Source/tasks.c **** 						{
2018:FreeRTOS/Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2019:FreeRTOS/Source/tasks.c **** 						}
2020:FreeRTOS/Source/tasks.c **** 						else
2021:FreeRTOS/Source/tasks.c **** 						{
2022:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2023:FreeRTOS/Source/tasks.c **** 						}
2024:FreeRTOS/Source/tasks.c **** 
2025:FreeRTOS/Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
2026:FreeRTOS/Source/tasks.c **** 						list. */
2027:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
2028:FreeRTOS/Source/tasks.c **** 
2029:FreeRTOS/Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate
2030:FreeRTOS/Source/tasks.c **** 						context switch if preemption is turned off. */
2031:FreeRTOS/Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
2032:FreeRTOS/Source/tasks.c **** 						{
2033:FreeRTOS/Source/tasks.c **** 							/* Preemption is on, but a context switch should
2034:FreeRTOS/Source/tasks.c **** 							only be performed if the unblocked task has a
2035:FreeRTOS/Source/tasks.c **** 							priority that is equal to or higher than the
2036:FreeRTOS/Source/tasks.c **** 							currently executing task. */
2037:FreeRTOS/Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2038:FreeRTOS/Source/tasks.c **** 							{
2039:FreeRTOS/Source/tasks.c **** 								xSwitchRequired = pdTRUE;
2040:FreeRTOS/Source/tasks.c **** 							}
2041:FreeRTOS/Source/tasks.c **** 							else
2042:FreeRTOS/Source/tasks.c **** 							{
2043:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2044:FreeRTOS/Source/tasks.c **** 							}
2045:FreeRTOS/Source/tasks.c **** 						}
2046:FreeRTOS/Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
2047:FreeRTOS/Source/tasks.c **** 					}
2048:FreeRTOS/Source/tasks.c **** 				}
2049:FreeRTOS/Source/tasks.c **** 			}
2050:FreeRTOS/Source/tasks.c **** 		}
2051:FreeRTOS/Source/tasks.c **** 
2052:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2053:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2054:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2055:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2056:FreeRTOS/Source/tasks.c **** 		{
2057:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
2058:FreeRTOS/Source/tasks.c **** 			{
2059:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
2060:FreeRTOS/Source/tasks.c **** 			}
2061:FreeRTOS/Source/tasks.c **** 			else
2062:FreeRTOS/Source/tasks.c **** 			{
2063:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2064:FreeRTOS/Source/tasks.c **** 			}
2065:FreeRTOS/Source/tasks.c **** 		}
2066:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2067:FreeRTOS/Source/tasks.c **** 
2068:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2069:FreeRTOS/Source/tasks.c **** 		{
2070:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2071:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2072:FreeRTOS/Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2073:FreeRTOS/Source/tasks.c **** 			{
2074:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2075:FreeRTOS/Source/tasks.c **** 			}
2076:FreeRTOS/Source/tasks.c **** 			else
2077:FreeRTOS/Source/tasks.c **** 			{
2078:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2079:FreeRTOS/Source/tasks.c **** 			}
2080:FreeRTOS/Source/tasks.c **** 		}
2081:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2082:FreeRTOS/Source/tasks.c **** 	}
2083:FreeRTOS/Source/tasks.c **** 	else
2084:FreeRTOS/Source/tasks.c **** 	{
2085:FreeRTOS/Source/tasks.c **** 		++uxPendedTicks;
2086:FreeRTOS/Source/tasks.c **** 
2087:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2088:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2089:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2090:FreeRTOS/Source/tasks.c **** 		{
2091:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2092:FreeRTOS/Source/tasks.c **** 		}
2093:FreeRTOS/Source/tasks.c **** 		#endif
2094:FreeRTOS/Source/tasks.c **** 	}
2095:FreeRTOS/Source/tasks.c **** 
2096:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2097:FreeRTOS/Source/tasks.c **** 	{
2098:FreeRTOS/Source/tasks.c **** 		if( xYieldPending != pdFALSE )
2099:FreeRTOS/Source/tasks.c **** 		{
2100:FreeRTOS/Source/tasks.c **** 			xSwitchRequired = pdTRUE;
2101:FreeRTOS/Source/tasks.c **** 		}
2102:FreeRTOS/Source/tasks.c **** 		else
2103:FreeRTOS/Source/tasks.c **** 		{
2104:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2105:FreeRTOS/Source/tasks.c **** 		}
2106:FreeRTOS/Source/tasks.c **** 	}
2107:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2108:FreeRTOS/Source/tasks.c **** 
2109:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
2110:FreeRTOS/Source/tasks.c **** }
2111:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2112:FreeRTOS/Source/tasks.c **** 
2113:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2114:FreeRTOS/Source/tasks.c **** 
2115:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2116:FreeRTOS/Source/tasks.c **** 	{
2117:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2118:FreeRTOS/Source/tasks.c **** 
2119:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2120:FreeRTOS/Source/tasks.c **** 		getting set. */
2121:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2122:FreeRTOS/Source/tasks.c **** 		{
2123:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2124:FreeRTOS/Source/tasks.c **** 		}
2125:FreeRTOS/Source/tasks.c **** 		else
2126:FreeRTOS/Source/tasks.c **** 		{
2127:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2128:FreeRTOS/Source/tasks.c **** 		}
2129:FreeRTOS/Source/tasks.c **** 
2130:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2131:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2132:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2133:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2134:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2135:FreeRTOS/Source/tasks.c **** 	}
2136:FreeRTOS/Source/tasks.c **** 
2137:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2138:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2139:FreeRTOS/Source/tasks.c **** 
2140:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2141:FreeRTOS/Source/tasks.c **** 
2142:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2143:FreeRTOS/Source/tasks.c **** 	{
2144:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2145:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2146:FreeRTOS/Source/tasks.c **** 
2147:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2148:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2149:FreeRTOS/Source/tasks.c **** 		{
2150:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2151:FreeRTOS/Source/tasks.c **** 		}
2152:FreeRTOS/Source/tasks.c **** 		else
2153:FreeRTOS/Source/tasks.c **** 		{
2154:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2155:FreeRTOS/Source/tasks.c **** 		}
2156:FreeRTOS/Source/tasks.c **** 
2157:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2158:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2159:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2160:FreeRTOS/Source/tasks.c **** 		{
2161:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2162:FreeRTOS/Source/tasks.c **** 		}
2163:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2164:FreeRTOS/Source/tasks.c **** 
2165:FreeRTOS/Source/tasks.c **** 		return xReturn;
2166:FreeRTOS/Source/tasks.c **** 	}
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2169:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2170:FreeRTOS/Source/tasks.c **** 
2171:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2172:FreeRTOS/Source/tasks.c **** 
2173:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2174:FreeRTOS/Source/tasks.c **** 	{
2175:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2176:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2177:FreeRTOS/Source/tasks.c **** 
2178:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2179:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2180:FreeRTOS/Source/tasks.c **** 		{
2181:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2182:FreeRTOS/Source/tasks.c **** 		}
2183:FreeRTOS/Source/tasks.c **** 		else
2184:FreeRTOS/Source/tasks.c **** 		{
2185:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2186:FreeRTOS/Source/tasks.c **** 		}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2189:FreeRTOS/Source/tasks.c **** 		{
2190:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2191:FreeRTOS/Source/tasks.c **** 		}
2192:FreeRTOS/Source/tasks.c **** 		else
2193:FreeRTOS/Source/tasks.c **** 		{
2194:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2195:FreeRTOS/Source/tasks.c **** 		}
2196:FreeRTOS/Source/tasks.c **** 
2197:FreeRTOS/Source/tasks.c **** 		return xReturn;
2198:FreeRTOS/Source/tasks.c **** 	}
2199:FreeRTOS/Source/tasks.c **** 
2200:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2201:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2204:FreeRTOS/Source/tasks.c **** {
2205:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
2206:FreeRTOS/Source/tasks.c **** 	{
2207:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2208:FreeRTOS/Source/tasks.c **** 		switch. */
2209:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2210:FreeRTOS/Source/tasks.c **** 	}
2211:FreeRTOS/Source/tasks.c **** 	else
2212:FreeRTOS/Source/tasks.c **** 	{
2213:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
2214:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2215:FreeRTOS/Source/tasks.c **** 
2216:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2217:FreeRTOS/Source/tasks.c **** 		{
2218:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2219:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2220:FreeRTOS/Source/tasks.c **** 				#else
2221:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2222:FreeRTOS/Source/tasks.c **** 				#endif
2223:FreeRTOS/Source/tasks.c **** 
2224:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2225:FreeRTOS/Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
2226:FreeRTOS/Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2227:FreeRTOS/Source/tasks.c **** 				protection here	so count values are only valid until the timer
2228:FreeRTOS/Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2229:FreeRTOS/Source/tasks.c **** 				against suspect run time stat counter implementations - which
2230:FreeRTOS/Source/tasks.c **** 				are provided by the application, not the kernel. */
2231:FreeRTOS/Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2232:FreeRTOS/Source/tasks.c **** 				{
2233:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2234:FreeRTOS/Source/tasks.c **** 				}
2235:FreeRTOS/Source/tasks.c **** 				else
2236:FreeRTOS/Source/tasks.c **** 				{
2237:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2238:FreeRTOS/Source/tasks.c **** 				}
2239:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2240:FreeRTOS/Source/tasks.c **** 		}
2241:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2242:FreeRTOS/Source/tasks.c **** 
2243:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2244:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
2245:FreeRTOS/Source/tasks.c **** 
2246:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2247:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
2248:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
2249:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2250:FreeRTOS/Source/tasks.c **** 
2251:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2252:FreeRTOS/Source/tasks.c **** 		{
2253:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2254:FreeRTOS/Source/tasks.c **** 			structure specific to this task. */
2255:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2256:FreeRTOS/Source/tasks.c **** 		}
2257:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2258:FreeRTOS/Source/tasks.c **** 	}
2259:FreeRTOS/Source/tasks.c **** }
2260:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2261:FreeRTOS/Source/tasks.c **** 
2262:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2263:FreeRTOS/Source/tasks.c **** {
2264:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2265:FreeRTOS/Source/tasks.c **** 
2266:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2267:FreeRTOS/Source/tasks.c **** 
2268:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2269:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2270:FreeRTOS/Source/tasks.c **** 
2271:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2272:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2273:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2274:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2275:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2276:FreeRTOS/Source/tasks.c **** 
2277:FreeRTOS/Source/tasks.c **** 	/* The task must be removed from from the ready list before it is added to
2278:FreeRTOS/Source/tasks.c **** 	the blocked list as the same list item is used for both lists.  Exclusive
2279:FreeRTOS/Source/tasks.c **** 	access to the ready lists guaranteed because the scheduler is locked. */
2280:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2281:FreeRTOS/Source/tasks.c **** 	{
2282:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2283:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2284:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2285:FreeRTOS/Source/tasks.c **** 	}
2286:FreeRTOS/Source/tasks.c **** 	else
2287:FreeRTOS/Source/tasks.c **** 	{
2288:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2289:FreeRTOS/Source/tasks.c **** 	}
2290:FreeRTOS/Source/tasks.c **** 
2291:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2292:FreeRTOS/Source/tasks.c **** 	{
2293:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2294:FreeRTOS/Source/tasks.c **** 		{
2295:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2296:FreeRTOS/Source/tasks.c **** 			list to ensure the task is not woken by a timing event.  It will
2297:FreeRTOS/Source/tasks.c **** 			block indefinitely. */
2298:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2299:FreeRTOS/Source/tasks.c **** 		}
2300:FreeRTOS/Source/tasks.c **** 		else
2301:FreeRTOS/Source/tasks.c **** 		{
2302:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2303:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2304:FreeRTOS/Source/tasks.c **** 			scheduler will handle it. */
2305:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2306:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2307:FreeRTOS/Source/tasks.c **** 		}
2308:FreeRTOS/Source/tasks.c **** 	}
2309:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2310:FreeRTOS/Source/tasks.c **** 	{
2311:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2312:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the scheduler
2313:FreeRTOS/Source/tasks.c **** 			will handle it. */
2314:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2315:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2316:FreeRTOS/Source/tasks.c **** 	}
2317:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2318:FreeRTOS/Source/tasks.c **** }
2319:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2320:FreeRTOS/Source/tasks.c **** 
2321:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2322:FreeRTOS/Source/tasks.c **** {
2323:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
2324:FreeRTOS/Source/tasks.c **** 
2325:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
2326:FreeRTOS/Source/tasks.c **** 
2327:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2328:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
2329:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2330:FreeRTOS/Source/tasks.c **** 
2331:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2332:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2333:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
2334:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
2335:FreeRTOS/Source/tasks.c **** 
2336:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2337:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2338:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2339:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2340:FreeRTOS/Source/tasks.c **** 	the task level). */
2341:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2342:FreeRTOS/Source/tasks.c **** 
2343:FreeRTOS/Source/tasks.c **** 	/* The task must be removed from the ready list before it is added to the
2344:FreeRTOS/Source/tasks.c **** 	blocked list.  Exclusive access can be assured to the ready list as the
2345:FreeRTOS/Source/tasks.c **** 	scheduler is locked. */
2346:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2347:FreeRTOS/Source/tasks.c **** 	{
2348:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
2349:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
2350:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2351:FreeRTOS/Source/tasks.c **** 	}
2352:FreeRTOS/Source/tasks.c **** 	else
2353:FreeRTOS/Source/tasks.c **** 	{
2354:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2355:FreeRTOS/Source/tasks.c **** 	}
2356:FreeRTOS/Source/tasks.c **** 
2357:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2358:FreeRTOS/Source/tasks.c **** 	{
2359:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
2360:FreeRTOS/Source/tasks.c **** 		{
2361:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
2362:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
2363:FreeRTOS/Source/tasks.c **** 			indefinitely. */
2364:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2365:FreeRTOS/Source/tasks.c **** 		}
2366:FreeRTOS/Source/tasks.c **** 		else
2367:FreeRTOS/Source/tasks.c **** 		{
2368:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2369:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
2370:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
2371:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2372:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2373:FreeRTOS/Source/tasks.c **** 		}
2374:FreeRTOS/Source/tasks.c **** 	}
2375:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
2376:FreeRTOS/Source/tasks.c **** 	{
2377:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
2378:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter, the kernel
2379:FreeRTOS/Source/tasks.c **** 			will manage it correctly. */
2380:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2381:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2382:FreeRTOS/Source/tasks.c **** 	}
2383:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2384:FreeRTOS/Source/tasks.c **** }
2385:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2386:FreeRTOS/Source/tasks.c **** 
2387:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, c
2390:FreeRTOS/Source/tasks.c **** 	{
2391:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
2392:FreeRTOS/Source/tasks.c **** 
2393:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
2394:FreeRTOS/Source/tasks.c **** 
2395:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
2396:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2397:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2398:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
2399:FreeRTOS/Source/tasks.c **** 
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2402:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2403:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2404:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
2405:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
2408:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
2409:FreeRTOS/Source/tasks.c **** 		function is called with the scheduler locked so interrupts will not
2410:FreeRTOS/Source/tasks.c **** 		access the lists at the same time. */
2411:FreeRTOS/Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
2412:FreeRTOS/Source/tasks.c **** 		{
2413:FreeRTOS/Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
2414:FreeRTOS/Source/tasks.c **** 			check, and the port reset macro can be called directly. */
2415:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2416:FreeRTOS/Source/tasks.c **** 		}
2417:FreeRTOS/Source/tasks.c **** 		else
2418:FreeRTOS/Source/tasks.c **** 		{
2419:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2420:FreeRTOS/Source/tasks.c **** 		}
2421:FreeRTOS/Source/tasks.c **** 
2422:FreeRTOS/Source/tasks.c **** 		/* If vTaskSuspend() is available then the suspended task list is also
2423:FreeRTOS/Source/tasks.c **** 		available and a task that is blocking indefinitely can enter the
2424:FreeRTOS/Source/tasks.c **** 		suspended state (it is not really suspended as it will re-enter the
2425:FreeRTOS/Source/tasks.c **** 		Ready state when the event it is waiting indefinitely for occurs).
2426:FreeRTOS/Source/tasks.c **** 		Blocking indefinitely is useful when using tickless idle mode as when
2427:FreeRTOS/Source/tasks.c **** 		all tasks are blocked indefinitely all timers can be turned off. */
2428:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_vTaskSuspend == 1 )
2429:FreeRTOS/Source/tasks.c **** 		{
2430:FreeRTOS/Source/tasks.c **** 			if( xWaitIndefinitely == pdTRUE )
2431:FreeRTOS/Source/tasks.c **** 			{
2432:FreeRTOS/Source/tasks.c **** 				/* Add the task to the suspended task list instead of a delayed
2433:FreeRTOS/Source/tasks.c **** 				task list to ensure the task is not woken by a timing event.  It
2434:FreeRTOS/Source/tasks.c **** 				will block indefinitely. */
2435:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
2436:FreeRTOS/Source/tasks.c **** 			}
2437:FreeRTOS/Source/tasks.c **** 			else
2438:FreeRTOS/Source/tasks.c **** 			{
2439:FreeRTOS/Source/tasks.c **** 				/* Calculate the time at which the task should be woken if the
2440:FreeRTOS/Source/tasks.c **** 				event does not occur.  This may overflow but this doesn't
2441:FreeRTOS/Source/tasks.c **** 				matter. */
2442:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToWait;
2443:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
2444:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
2445:FreeRTOS/Source/tasks.c **** 			}
2446:FreeRTOS/Source/tasks.c **** 		}
2447:FreeRTOS/Source/tasks.c **** 		#else
2448:FreeRTOS/Source/tasks.c **** 		{
2449:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
2450:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter. */
2451:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
2452:FreeRTOS/Source/tasks.c **** 			traceTASK_DELAY_UNTIL();
2453:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
2454:FreeRTOS/Source/tasks.c **** 
2455:FreeRTOS/Source/tasks.c **** 			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
2456:FreeRTOS/Source/tasks.c **** 			defined. */
2457:FreeRTOS/Source/tasks.c **** 			( void ) xWaitIndefinitely;
2458:FreeRTOS/Source/tasks.c **** 		}
2459:FreeRTOS/Source/tasks.c **** 		#endif
2460:FreeRTOS/Source/tasks.c **** 	}
2461:FreeRTOS/Source/tasks.c **** 
2462:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
2463:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2464:FreeRTOS/Source/tasks.c **** 
2465:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2466:FreeRTOS/Source/tasks.c **** {
2467:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2468:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2469:FreeRTOS/Source/tasks.c **** 
2470:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2471:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
2472:FreeRTOS/Source/tasks.c **** 
2473:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2474:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2475:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
2476:FreeRTOS/Source/tasks.c **** 
2477:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2478:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2479:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2480:FreeRTOS/Source/tasks.c **** 
2481:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2482:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
2483:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
2484:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2485:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
2486:FreeRTOS/Source/tasks.c **** 
2487:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2488:FreeRTOS/Source/tasks.c **** 	{
2489:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2490:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
2491:FreeRTOS/Source/tasks.c **** 	}
2492:FreeRTOS/Source/tasks.c **** 	else
2493:FreeRTOS/Source/tasks.c **** 	{
2494:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2495:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
2496:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
2497:FreeRTOS/Source/tasks.c **** 	}
2498:FreeRTOS/Source/tasks.c **** 
2499:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2500:FreeRTOS/Source/tasks.c **** 	{
2501:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2502:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
2503:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
2504:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2505:FreeRTOS/Source/tasks.c **** 
2506:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2507:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2508:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2509:FreeRTOS/Source/tasks.c **** 	}
2510:FreeRTOS/Source/tasks.c **** 	else
2511:FreeRTOS/Source/tasks.c **** 	{
2512:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2513:FreeRTOS/Source/tasks.c **** 	}
2514:FreeRTOS/Source/tasks.c **** 
2515:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2516:FreeRTOS/Source/tasks.c **** 	{
2517:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2518:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2519:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2520:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2521:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2522:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2523:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2524:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
2525:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
2526:FreeRTOS/Source/tasks.c **** 	}
2527:FreeRTOS/Source/tasks.c **** 	#endif
2528:FreeRTOS/Source/tasks.c **** 
2529:FreeRTOS/Source/tasks.c **** 	return xReturn;
2530:FreeRTOS/Source/tasks.c **** }
2531:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2532:FreeRTOS/Source/tasks.c **** 
2533:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2534:FreeRTOS/Source/tasks.c **** {
2535:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
2536:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2537:FreeRTOS/Source/tasks.c **** 
2538:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2539:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
2540:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2541:FreeRTOS/Source/tasks.c **** 
2542:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
2543:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
2544:FreeRTOS/Source/tasks.c **** 
2545:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2546:FreeRTOS/Source/tasks.c **** 	event flags. */
2547:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
2548:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2549:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
2550:FreeRTOS/Source/tasks.c **** 
2551:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2552:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2553:FreeRTOS/Source/tasks.c **** 	lists. */
2554:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
2555:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
2556:FreeRTOS/Source/tasks.c **** 
2557:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
2558:FreeRTOS/Source/tasks.c **** 	{
2559:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
2560:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
2561:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
2562:FreeRTOS/Source/tasks.c **** 		switch now. */
2563:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
2564:FreeRTOS/Source/tasks.c **** 
2565:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2566:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2567:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
2568:FreeRTOS/Source/tasks.c **** 	}
2569:FreeRTOS/Source/tasks.c **** 	else
2570:FreeRTOS/Source/tasks.c **** 	{
2571:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
2572:FreeRTOS/Source/tasks.c **** 	}
2573:FreeRTOS/Source/tasks.c **** 
2574:FreeRTOS/Source/tasks.c **** 	return xReturn;
2575:FreeRTOS/Source/tasks.c **** }
2576:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2577:FreeRTOS/Source/tasks.c **** 
2578:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2579:FreeRTOS/Source/tasks.c **** {
2580:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2581:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
2582:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
2583:FreeRTOS/Source/tasks.c **** }
2584:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2585:FreeRTOS/Source/tasks.c **** 
2586:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2587:FreeRTOS/Source/tasks.c **** {
2588:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
2589:FreeRTOS/Source/tasks.c **** 
2590:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
2591:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
2592:FreeRTOS/Source/tasks.c **** 
2593:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
2594:FreeRTOS/Source/tasks.c **** 	{
2595:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2596:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
2597:FreeRTOS/Source/tasks.c **** 
2598:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2599:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2600:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2601:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
2602:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
2603:FreeRTOS/Source/tasks.c **** 			{
2604:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
2605:FreeRTOS/Source/tasks.c **** 			}
2606:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2607:FreeRTOS/Source/tasks.c **** 		#endif
2608:FreeRTOS/Source/tasks.c **** 
2609:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
2610:FreeRTOS/Source/tasks.c **** 		{
2611:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2612:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2613:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2614:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2615:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2616:FreeRTOS/Source/tasks.c **** 		}
2617:FreeRTOS/Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
2618:FreeRTOS/Source/tasks.c **** 		{
2619:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2620:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
2621:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
2622:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
2623:FreeRTOS/Source/tasks.c **** 		}
2624:FreeRTOS/Source/tasks.c **** 		else
2625:FreeRTOS/Source/tasks.c **** 		{
2626:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
2627:FreeRTOS/Source/tasks.c **** 		}
2628:FreeRTOS/Source/tasks.c **** 	}
2629:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
2630:FreeRTOS/Source/tasks.c **** 
2631:FreeRTOS/Source/tasks.c **** 	return xReturn;
2632:FreeRTOS/Source/tasks.c **** }
2633:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2634:FreeRTOS/Source/tasks.c **** 
2635:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
2636:FreeRTOS/Source/tasks.c **** {
2637:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
2638:FreeRTOS/Source/tasks.c **** }
2639:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2640:FreeRTOS/Source/tasks.c **** 
2641:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2642:FreeRTOS/Source/tasks.c **** 
2643:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2644:FreeRTOS/Source/tasks.c **** 	{
2645:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
2646:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2647:FreeRTOS/Source/tasks.c **** 
2648:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2649:FreeRTOS/Source/tasks.c **** 		{
2650:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2651:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
2652:FreeRTOS/Source/tasks.c **** 		}
2653:FreeRTOS/Source/tasks.c **** 		else
2654:FreeRTOS/Source/tasks.c **** 		{
2655:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
2656:FreeRTOS/Source/tasks.c **** 		}
2657:FreeRTOS/Source/tasks.c **** 
2658:FreeRTOS/Source/tasks.c **** 		return uxReturn;
2659:FreeRTOS/Source/tasks.c **** 	}
2660:FreeRTOS/Source/tasks.c **** 
2661:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2662:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2663:FreeRTOS/Source/tasks.c **** 
2664:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2665:FreeRTOS/Source/tasks.c **** 
2666:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2667:FreeRTOS/Source/tasks.c **** 	{
2668:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2669:FreeRTOS/Source/tasks.c **** 
2670:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
2671:FreeRTOS/Source/tasks.c **** 		{
2672:FreeRTOS/Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
2673:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
2674:FreeRTOS/Source/tasks.c **** 		}
2675:FreeRTOS/Source/tasks.c **** 	}
2676:FreeRTOS/Source/tasks.c **** 
2677:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2678:FreeRTOS/Source/tasks.c **** 
2679:FreeRTOS/Source/tasks.c **** /*
2680:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
2681:FreeRTOS/Source/tasks.c ****  * The Idle task.
2682:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
2683:FreeRTOS/Source/tasks.c ****  *
2684:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2685:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2686:FreeRTOS/Source/tasks.c ****  *
2687:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2688:FreeRTOS/Source/tasks.c ****  *
2689:FreeRTOS/Source/tasks.c ****  */
2690:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2691:FreeRTOS/Source/tasks.c **** {
2692:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
2693:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
2694:FreeRTOS/Source/tasks.c **** 
2695:FreeRTOS/Source/tasks.c **** 	for( ;; )
2696:FreeRTOS/Source/tasks.c **** 	{
2697:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
2698:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
2699:FreeRTOS/Source/tasks.c **** 
2700:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2701:FreeRTOS/Source/tasks.c **** 		{
2702:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2703:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
2704:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2705:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
2706:FreeRTOS/Source/tasks.c **** 			taskYIELD();
2707:FreeRTOS/Source/tasks.c **** 		}
2708:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2709:FreeRTOS/Source/tasks.c **** 
2710:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2711:FreeRTOS/Source/tasks.c **** 		{
2712:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2713:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2714:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
2715:FreeRTOS/Source/tasks.c **** 			timeslice.
2716:FreeRTOS/Source/tasks.c **** 
2717:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
2718:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2719:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2720:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2721:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
2722:FreeRTOS/Source/tasks.c **** 			{
2723:FreeRTOS/Source/tasks.c **** 				taskYIELD();
2724:FreeRTOS/Source/tasks.c **** 			}
2725:FreeRTOS/Source/tasks.c **** 			else
2726:FreeRTOS/Source/tasks.c **** 			{
2727:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2728:FreeRTOS/Source/tasks.c **** 			}
2729:FreeRTOS/Source/tasks.c **** 		}
2730:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2731:FreeRTOS/Source/tasks.c **** 
2732:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2733:FreeRTOS/Source/tasks.c **** 		{
2734:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2735:FreeRTOS/Source/tasks.c **** 
2736:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2737:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
2738:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
2739:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2740:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2741:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
2742:FreeRTOS/Source/tasks.c **** 		}
2743:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2744:FreeRTOS/Source/tasks.c **** 
2745:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2746:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2747:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
2748:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2749:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2750:FreeRTOS/Source/tasks.c **** 		{
2751:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
2752:FreeRTOS/Source/tasks.c **** 
2753:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2754:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2755:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
2756:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2757:FreeRTOS/Source/tasks.c **** 			valid. */
2758:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2759:FreeRTOS/Source/tasks.c **** 
2760:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2761:FreeRTOS/Source/tasks.c **** 			{
2762:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
2763:FreeRTOS/Source/tasks.c **** 				{
2764:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2765:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
2766:FreeRTOS/Source/tasks.c **** 					be used. */
2767:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2768:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2769:FreeRTOS/Source/tasks.c **** 
2770:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2771:FreeRTOS/Source/tasks.c **** 					{
2772:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2773:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2774:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2775:FreeRTOS/Source/tasks.c **** 					}
2776:FreeRTOS/Source/tasks.c **** 					else
2777:FreeRTOS/Source/tasks.c **** 					{
2778:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2779:FreeRTOS/Source/tasks.c **** 					}
2780:FreeRTOS/Source/tasks.c **** 				}
2781:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
2782:FreeRTOS/Source/tasks.c **** 			}
2783:FreeRTOS/Source/tasks.c **** 			else
2784:FreeRTOS/Source/tasks.c **** 			{
2785:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2786:FreeRTOS/Source/tasks.c **** 			}
2787:FreeRTOS/Source/tasks.c **** 		}
2788:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2789:FreeRTOS/Source/tasks.c **** 	}
2790:FreeRTOS/Source/tasks.c **** }
2791:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2792:FreeRTOS/Source/tasks.c **** 
2793:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
2794:FreeRTOS/Source/tasks.c **** 
2795:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2796:FreeRTOS/Source/tasks.c **** 	{
2797:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
2798:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
2799:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2800:FreeRTOS/Source/tasks.c **** 
2801:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2802:FreeRTOS/Source/tasks.c **** 		{
2803:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2804:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2805:FreeRTOS/Source/tasks.c **** 		}
2806:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2807:FreeRTOS/Source/tasks.c **** 		{
2808:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2809:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
2810:FreeRTOS/Source/tasks.c **** 		}
2811:FreeRTOS/Source/tasks.c **** 		else
2812:FreeRTOS/Source/tasks.c **** 		{
2813:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
2814:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
2815:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
2816:FreeRTOS/Source/tasks.c **** 			interrupts. */
2817:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
2818:FreeRTOS/Source/tasks.c **** 			{
2819:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
2820:FreeRTOS/Source/tasks.c **** 			}
2821:FreeRTOS/Source/tasks.c **** 			else
2822:FreeRTOS/Source/tasks.c **** 			{
2823:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2824:FreeRTOS/Source/tasks.c **** 			}
2825:FreeRTOS/Source/tasks.c **** 		}
2826:FreeRTOS/Source/tasks.c **** 
2827:FreeRTOS/Source/tasks.c **** 		return eReturn;
2828:FreeRTOS/Source/tasks.c **** 	}
2829:FreeRTOS/Source/tasks.c **** 
2830:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2831:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2832:FreeRTOS/Source/tasks.c **** 
2833:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t 
2834:FreeRTOS/Source/tasks.c **** {
2835:FreeRTOS/Source/tasks.c **** UBaseType_t x;
2836:FreeRTOS/Source/tasks.c **** 
2837:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
2838:FreeRTOS/Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2839:FreeRTOS/Source/tasks.c **** 	{
2840:FreeRTOS/Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
2841:FreeRTOS/Source/tasks.c **** 
2842:FreeRTOS/Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2843:FreeRTOS/Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2844:FreeRTOS/Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2845:FreeRTOS/Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
2846:FreeRTOS/Source/tasks.c **** 		{
2847:FreeRTOS/Source/tasks.c **** 			break;
2848:FreeRTOS/Source/tasks.c **** 		}
2849:FreeRTOS/Source/tasks.c **** 		else
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2852:FreeRTOS/Source/tasks.c **** 		}
2853:FreeRTOS/Source/tasks.c **** 	}
2854:FreeRTOS/Source/tasks.c **** 
2855:FreeRTOS/Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2856:FreeRTOS/Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2857:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
2858:FreeRTOS/Source/tasks.c **** 
2859:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2860:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
2861:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
2862:FreeRTOS/Source/tasks.c **** 	{
2863:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
2864:FreeRTOS/Source/tasks.c **** 	}
2865:FreeRTOS/Source/tasks.c **** 	else
2866:FreeRTOS/Source/tasks.c **** 	{
2867:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
2868:FreeRTOS/Source/tasks.c **** 	}
2869:FreeRTOS/Source/tasks.c **** 
2870:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2871:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2872:FreeRTOS/Source/tasks.c **** 	{
2873:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2874:FreeRTOS/Source/tasks.c **** 		pxTCB->uxMutexesHeld = 0;
2875:FreeRTOS/Source/tasks.c **** 	}
2876:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2877:FreeRTOS/Source/tasks.c **** 
2878:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2879:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2880:FreeRTOS/Source/tasks.c **** 
2881:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2882:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2883:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2886:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickT
2887:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2888:FreeRTOS/Source/tasks.c **** 
2889:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2890:FreeRTOS/Source/tasks.c **** 	{
2891:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2892:FreeRTOS/Source/tasks.c **** 	}
2893:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2894:FreeRTOS/Source/tasks.c **** 
2895:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2896:FreeRTOS/Source/tasks.c **** 	{
2897:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2898:FreeRTOS/Source/tasks.c **** 	}
2899:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2900:FreeRTOS/Source/tasks.c **** 
2901:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2902:FreeRTOS/Source/tasks.c **** 	{
2903:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2904:FreeRTOS/Source/tasks.c **** 	}
2905:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2906:FreeRTOS/Source/tasks.c **** 
2907:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2908:FreeRTOS/Source/tasks.c **** 	{
2909:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2910:FreeRTOS/Source/tasks.c **** 	}
2911:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2912:FreeRTOS/Source/tasks.c **** 	{
2913:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2914:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2915:FreeRTOS/Source/tasks.c **** 	}
2916:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2917:FreeRTOS/Source/tasks.c **** 
2918:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2919:FreeRTOS/Source/tasks.c **** 	{
2920:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
2921:FreeRTOS/Source/tasks.c **** 		{
2922:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
2923:FreeRTOS/Source/tasks.c **** 		}
2924:FreeRTOS/Source/tasks.c **** 	}
2925:FreeRTOS/Source/tasks.c **** 	#endif
2926:FreeRTOS/Source/tasks.c **** 
2927:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
2928:FreeRTOS/Source/tasks.c **** 	{
2929:FreeRTOS/Source/tasks.c **** 		pxTCB->ulNotifiedValue = 0;
2930:FreeRTOS/Source/tasks.c **** 		pxTCB->eNotifyState = eNotWaitingNotification;
2931:FreeRTOS/Source/tasks.c **** 	}
2932:FreeRTOS/Source/tasks.c **** 	#endif
2933:FreeRTOS/Source/tasks.c **** 
2934:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2935:FreeRTOS/Source/tasks.c **** 	{
2936:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2937:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2938:FreeRTOS/Source/tasks.c **** 	}
2939:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2940:FreeRTOS/Source/tasks.c **** }
2941:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2944:FreeRTOS/Source/tasks.c **** 
2945:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
2946:FreeRTOS/Source/tasks.c **** 	{
2947:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2948:FreeRTOS/Source/tasks.c **** 
2949:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2950:FreeRTOS/Source/tasks.c **** 		{
2951:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
2952:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
2953:FreeRTOS/Source/tasks.c **** 		}
2954:FreeRTOS/Source/tasks.c **** 	}
2955:FreeRTOS/Source/tasks.c **** 
2956:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2957:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2958:FreeRTOS/Source/tasks.c **** 
2959:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
2960:FreeRTOS/Source/tasks.c **** 
2961:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
2962:FreeRTOS/Source/tasks.c **** 	{
2963:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
2964:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2965:FreeRTOS/Source/tasks.c **** 
2966:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
2967:FreeRTOS/Source/tasks.c **** 		{
2968:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2969:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
2970:FreeRTOS/Source/tasks.c **** 		}
2971:FreeRTOS/Source/tasks.c **** 		else
2972:FreeRTOS/Source/tasks.c **** 		{
2973:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
2974:FreeRTOS/Source/tasks.c **** 		}
2975:FreeRTOS/Source/tasks.c **** 
2976:FreeRTOS/Source/tasks.c **** 		return pvReturn;
2977:FreeRTOS/Source/tasks.c **** 	}
2978:FreeRTOS/Source/tasks.c **** 
2979:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
2980:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2981:FreeRTOS/Source/tasks.c **** 
2982:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2983:FreeRTOS/Source/tasks.c **** 
2984:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2985:FreeRTOS/Source/tasks.c **** 	{
2986:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2987:FreeRTOS/Source/tasks.c **** 
2988:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
2989:FreeRTOS/Source/tasks.c **** 		the calling task. */
2990:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2991:FreeRTOS/Source/tasks.c **** 
2992:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2993:FreeRTOS/Source/tasks.c **** 	}
2994:FreeRTOS/Source/tasks.c **** 
2995:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2996:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2997:FreeRTOS/Source/tasks.c **** 
2998:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2999:FreeRTOS/Source/tasks.c **** {
3000:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3001:FreeRTOS/Source/tasks.c **** 
3002:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
3003:FreeRTOS/Source/tasks.c **** 	{
3004:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3005:FreeRTOS/Source/tasks.c **** 	}
3006:FreeRTOS/Source/tasks.c **** 
3007:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
3008:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
3009:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
3010:FreeRTOS/Source/tasks.c **** 
3011:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3012:FreeRTOS/Source/tasks.c **** 	{
3013:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
3014:FreeRTOS/Source/tasks.c **** 	}
3015:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3016:FreeRTOS/Source/tasks.c **** 
3017:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3018:FreeRTOS/Source/tasks.c **** 	{
3019:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
3020:FreeRTOS/Source/tasks.c **** 	}
3021:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3022:FreeRTOS/Source/tasks.c **** 
3023:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3024:FreeRTOS/Source/tasks.c **** 	using list2. */
3025:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
3026:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
3027:FreeRTOS/Source/tasks.c **** }
3028:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3029:FreeRTOS/Source/tasks.c **** 
3030:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3031:FreeRTOS/Source/tasks.c **** {
3032:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3033:FreeRTOS/Source/tasks.c **** 	{
3034:FreeRTOS/Source/tasks.c **** 		BaseType_t xListIsEmpty;
3035:FreeRTOS/Source/tasks.c **** 
3036:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3037:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
3038:FreeRTOS/Source/tasks.c **** 		while( uxTasksDeleted > ( UBaseType_t ) 0U )
3039:FreeRTOS/Source/tasks.c **** 		{
3040:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
3041:FreeRTOS/Source/tasks.c **** 			{
3042:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
3043:FreeRTOS/Source/tasks.c **** 			}
3044:FreeRTOS/Source/tasks.c **** 			( void ) xTaskResumeAll();
3045:FreeRTOS/Source/tasks.c **** 
3046:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
3047:FreeRTOS/Source/tasks.c **** 			{
3048:FreeRTOS/Source/tasks.c **** 				TCB_t *pxTCB;
3049:FreeRTOS/Source/tasks.c **** 
3050:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
3051:FreeRTOS/Source/tasks.c **** 				{
3052:FreeRTOS/Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
3053:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
3054:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
3055:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
3056:FreeRTOS/Source/tasks.c **** 				}
3057:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
3058:FreeRTOS/Source/tasks.c **** 
3059:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
3060:FreeRTOS/Source/tasks.c **** 			}
3061:FreeRTOS/Source/tasks.c **** 			else
3062:FreeRTOS/Source/tasks.c **** 			{
3063:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3064:FreeRTOS/Source/tasks.c **** 			}
3065:FreeRTOS/Source/tasks.c **** 		}
3066:FreeRTOS/Source/tasks.c **** 	}
3067:FreeRTOS/Source/tasks.c **** 	#endif /* vTaskDelete */
3068:FreeRTOS/Source/tasks.c **** }
3069:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3070:FreeRTOS/Source/tasks.c **** 
3071:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
3072:FreeRTOS/Source/tasks.c **** {
3073:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
3074:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
3075:FreeRTOS/Source/tasks.c **** 
3076:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
3077:FreeRTOS/Source/tasks.c **** 	{
3078:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
3079:FreeRTOS/Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3080:FreeRTOS/Source/tasks.c **** 	}
3081:FreeRTOS/Source/tasks.c **** 	else
3082:FreeRTOS/Source/tasks.c **** 	{
3083:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so the current block list is used. */
3084:FreeRTOS/Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3085:FreeRTOS/Source/tasks.c **** 
3086:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
3087:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
3088:FreeRTOS/Source/tasks.c **** 		too. */
3089:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
3090:FreeRTOS/Source/tasks.c **** 		{
3091:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
3092:FreeRTOS/Source/tasks.c **** 		}
3093:FreeRTOS/Source/tasks.c **** 		else
3094:FreeRTOS/Source/tasks.c **** 		{
3095:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3096:FreeRTOS/Source/tasks.c **** 		}
3097:FreeRTOS/Source/tasks.c **** 	}
3098:FreeRTOS/Source/tasks.c **** }
3099:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3100:FreeRTOS/Source/tasks.c **** 
3101:FreeRTOS/Source/tasks.c **** static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuff
3102:FreeRTOS/Source/tasks.c **** {
3103:FreeRTOS/Source/tasks.c **** TCB_t *pxNewTCB;
3104:FreeRTOS/Source/tasks.c **** 
3105:FreeRTOS/Source/tasks.c **** 	/* If the stack grows down then allocate the stack then the TCB so the stack
3106:FreeRTOS/Source/tasks.c **** 	does not grow into the TCB.  Likewise if the stack grows up then allocate
3107:FreeRTOS/Source/tasks.c **** 	the TCB then the stack. */
3108:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH > 0 )
3109:FreeRTOS/Source/tasks.c **** 	{
3110:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the TCB.  Where the memory comes from depends on
3111:FreeRTOS/Source/tasks.c **** 		the implementation of the port malloc function. */
3112:FreeRTOS/Source/tasks.c **** 		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3113:FreeRTOS/Source/tasks.c **** 
3114:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
3115:FreeRTOS/Source/tasks.c **** 		{
3116:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created.
3117:FreeRTOS/Source/tasks.c **** 			The base of the stack memory stored in the TCB so the task can
3118:FreeRTOS/Source/tasks.c **** 			be deleted later if required. */
3119:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeo
3120:FreeRTOS/Source/tasks.c **** 
3121:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->pxStack == NULL )
3122:FreeRTOS/Source/tasks.c **** 			{
3123:FreeRTOS/Source/tasks.c **** 				/* Could not allocate the stack.  Delete the allocated TCB. */
3124:FreeRTOS/Source/tasks.c **** 				vPortFree( pxNewTCB );
3125:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
3126:FreeRTOS/Source/tasks.c **** 			}
3127:FreeRTOS/Source/tasks.c **** 		}
3128:FreeRTOS/Source/tasks.c **** 	}
3129:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
3130:FreeRTOS/Source/tasks.c **** 	{
3131:FreeRTOS/Source/tasks.c **** 	StackType_t *pxStack;
3132:FreeRTOS/Source/tasks.c **** 
3133:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created. */
3134:FreeRTOS/Source/tasks.c **** 		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackTyp
3135:FreeRTOS/Source/tasks.c **** 
3136:FreeRTOS/Source/tasks.c **** 		if( pxStack != NULL )
3137:FreeRTOS/Source/tasks.c **** 		{
3138:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
3139:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function. */
3140:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
3141:FreeRTOS/Source/tasks.c **** 
3142:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
3143:FreeRTOS/Source/tasks.c **** 			{
3144:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
3145:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxStack;
3146:FreeRTOS/Source/tasks.c **** 			}
3147:FreeRTOS/Source/tasks.c **** 			else
3148:FreeRTOS/Source/tasks.c **** 			{
3149:FreeRTOS/Source/tasks.c **** 				/* The stack cannot be used as the TCB was not created.  Free it
3150:FreeRTOS/Source/tasks.c **** 				again. */
3151:FreeRTOS/Source/tasks.c **** 				vPortFree( pxStack );
3152:FreeRTOS/Source/tasks.c **** 			}
3153:FreeRTOS/Source/tasks.c **** 		}
3154:FreeRTOS/Source/tasks.c **** 		else
3155:FreeRTOS/Source/tasks.c **** 		{
3156:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
3157:FreeRTOS/Source/tasks.c **** 		}
3158:FreeRTOS/Source/tasks.c **** 	}
3159:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
3160:FreeRTOS/Source/tasks.c **** 
3161:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
3162:FreeRTOS/Source/tasks.c **** 	{
3163:FreeRTOS/Source/tasks.c **** 		/* Avoid dependency on memset() if it is not required. */
3164:FreeRTOS/Source/tasks.c **** 		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxT
3165:FreeRTOS/Source/tasks.c **** 		{
3166:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
3167:FreeRTOS/Source/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
3168:FreeRTOS/Source/tasks.c **** 		}
3169:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( IN
3170:FreeRTOS/Source/tasks.c **** 	}
3171:FreeRTOS/Source/tasks.c **** 
3172:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
3173:FreeRTOS/Source/tasks.c **** }
3174:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3175:FreeRTOS/Source/tasks.c **** 
3176:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3177:FreeRTOS/Source/tasks.c **** 
3178:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, e
3179:FreeRTOS/Source/tasks.c **** 	{
3180:FreeRTOS/Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3181:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3182:FreeRTOS/Source/tasks.c **** 
3183:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3184:FreeRTOS/Source/tasks.c **** 		{
3185:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3186:FreeRTOS/Source/tasks.c **** 
3187:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3188:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3189:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3190:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3191:FreeRTOS/Source/tasks.c **** 			do
3192:FreeRTOS/Source/tasks.c **** 			{
3193:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3194:FreeRTOS/Source/tasks.c **** 
3195:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
3196:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
3197:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
3198:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
3199:FreeRTOS/Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
3200:FreeRTOS/Source/tasks.c **** 
3201:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3202:FreeRTOS/Source/tasks.c **** 				{
3203:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a chance
3204:FreeRTOS/Source/tasks.c **** 					it is actually just blocked indefinitely - so really it should
3205:FreeRTOS/Source/tasks.c **** 					be reported as being in the Blocked state. */
3206:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3207:FreeRTOS/Source/tasks.c **** 					{
3208:FreeRTOS/Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
3209:FreeRTOS/Source/tasks.c **** 						{
3210:FreeRTOS/Source/tasks.c **** 							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
3211:FreeRTOS/Source/tasks.c **** 						}
3212:FreeRTOS/Source/tasks.c **** 					}
3213:FreeRTOS/Source/tasks.c **** 				}
3214:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3215:FreeRTOS/Source/tasks.c **** 
3216:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
3217:FreeRTOS/Source/tasks.c **** 				{
3218:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
3219:FreeRTOS/Source/tasks.c **** 				}
3220:FreeRTOS/Source/tasks.c **** 				#else
3221:FreeRTOS/Source/tasks.c **** 				{
3222:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
3223:FreeRTOS/Source/tasks.c **** 				}
3224:FreeRTOS/Source/tasks.c **** 				#endif
3225:FreeRTOS/Source/tasks.c **** 
3226:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
3227:FreeRTOS/Source/tasks.c **** 				{
3228:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
3229:FreeRTOS/Source/tasks.c **** 				}
3230:FreeRTOS/Source/tasks.c **** 				#else
3231:FreeRTOS/Source/tasks.c **** 				{
3232:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
3233:FreeRTOS/Source/tasks.c **** 				}
3234:FreeRTOS/Source/tasks.c **** 				#endif
3235:FreeRTOS/Source/tasks.c **** 
3236:FreeRTOS/Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
3237:FreeRTOS/Source/tasks.c **** 				{
3238:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3239:FreeRTOS/Source/tasks.c **** 				}
3240:FreeRTOS/Source/tasks.c **** 				#else
3241:FreeRTOS/Source/tasks.c **** 				{
3242:FreeRTOS/Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) p
3243:FreeRTOS/Source/tasks.c **** 				}
3244:FreeRTOS/Source/tasks.c **** 				#endif
3245:FreeRTOS/Source/tasks.c **** 
3246:FreeRTOS/Source/tasks.c **** 				uxTask++;
3247:FreeRTOS/Source/tasks.c **** 
3248:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3249:FreeRTOS/Source/tasks.c **** 		}
3250:FreeRTOS/Source/tasks.c **** 		else
3251:FreeRTOS/Source/tasks.c **** 		{
3252:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3253:FreeRTOS/Source/tasks.c **** 		}
3254:FreeRTOS/Source/tasks.c **** 
3255:FreeRTOS/Source/tasks.c **** 		return uxTask;
3256:FreeRTOS/Source/tasks.c **** 	}
3257:FreeRTOS/Source/tasks.c **** 
3258:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3259:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3260:FreeRTOS/Source/tasks.c **** 
3261:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3262:FreeRTOS/Source/tasks.c **** 
3263:FreeRTOS/Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3264:FreeRTOS/Source/tasks.c **** 	{
3265:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3266:FreeRTOS/Source/tasks.c **** 
3267:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3268:FreeRTOS/Source/tasks.c **** 		{
3269:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3270:FreeRTOS/Source/tasks.c **** 			ulCount++;
3271:FreeRTOS/Source/tasks.c **** 		}
3272:FreeRTOS/Source/tasks.c **** 
3273:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3274:FreeRTOS/Source/tasks.c **** 
3275:FreeRTOS/Source/tasks.c **** 		return ( uint16_t ) ulCount;
3276:FreeRTOS/Source/tasks.c **** 	}
3277:FreeRTOS/Source/tasks.c **** 
3278:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3279:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3280:FreeRTOS/Source/tasks.c **** 
3281:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3282:FreeRTOS/Source/tasks.c **** 
3283:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3284:FreeRTOS/Source/tasks.c **** 	{
3285:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3286:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3287:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3288:FreeRTOS/Source/tasks.c **** 
3289:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3290:FreeRTOS/Source/tasks.c **** 
3291:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3292:FreeRTOS/Source/tasks.c **** 		{
3293:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3294:FreeRTOS/Source/tasks.c **** 		}
3295:FreeRTOS/Source/tasks.c **** 		#else
3296:FreeRTOS/Source/tasks.c **** 		{
3297:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3298:FreeRTOS/Source/tasks.c **** 		}
3299:FreeRTOS/Source/tasks.c **** 		#endif
3300:FreeRTOS/Source/tasks.c **** 
3301:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3302:FreeRTOS/Source/tasks.c **** 
3303:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3304:FreeRTOS/Source/tasks.c **** 	}
3305:FreeRTOS/Source/tasks.c **** 
3306:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3307:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3308:FreeRTOS/Source/tasks.c **** 
3309:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3310:FreeRTOS/Source/tasks.c **** 
3311:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3312:FreeRTOS/Source/tasks.c **** 	{
3313:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3314:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3315:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3316:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3317:FreeRTOS/Source/tasks.c **** 
3318:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3319:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3320:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3321:FreeRTOS/Source/tasks.c **** 		{
3322:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3323:FreeRTOS/Source/tasks.c **** 		}
3324:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3325:FreeRTOS/Source/tasks.c **** 
3326:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
3327:FreeRTOS/Source/tasks.c **** 		{
3328:FreeRTOS/Source/tasks.c **** 			/* Only free the stack if it was allocated dynamically in the first
3329:FreeRTOS/Source/tasks.c **** 			place. */
3330:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
3331:FreeRTOS/Source/tasks.c **** 			{
3332:FreeRTOS/Source/tasks.c **** 				vPortFreeAligned( pxTCB->pxStack );
3333:FreeRTOS/Source/tasks.c **** 			}
3334:FreeRTOS/Source/tasks.c **** 		}
3335:FreeRTOS/Source/tasks.c **** 		#else
3336:FreeRTOS/Source/tasks.c **** 		{
3337:FreeRTOS/Source/tasks.c **** 			vPortFreeAligned( pxTCB->pxStack );
3338:FreeRTOS/Source/tasks.c **** 		}
3339:FreeRTOS/Source/tasks.c **** 		#endif
3340:FreeRTOS/Source/tasks.c **** 
3341:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
3342:FreeRTOS/Source/tasks.c **** 	}
3343:FreeRTOS/Source/tasks.c **** 
3344:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3345:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3346:FreeRTOS/Source/tasks.c **** 
3347:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3348:FreeRTOS/Source/tasks.c **** {
  27              		.loc 1 3348 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
3349:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3350:FreeRTOS/Source/tasks.c **** 
3351:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  32              		.loc 1 3351 0
  33 0000 074B     		ldr	r3, .L7
  34 0002 1A68     		ldr	r2, [r3]
  35 0004 1268     		ldr	r2, [r2]
  36 0006 22B9     		cbnz	r2, .L5
3352:FreeRTOS/Source/tasks.c **** 	{
3353:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3354:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3355:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3356:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3357:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
  37              		.loc 1 3357 0
  38 0008 064B     		ldr	r3, .L7+4
  39 000a 4FF0FF32 		mov	r2, #-1
  40 000e 1A60     		str	r2, [r3]
  41 0010 7047     		bx	lr
  42              	.L5:
  43              	.LBB27:
  44              	.LBB28:
3358:FreeRTOS/Source/tasks.c **** 	}
3359:FreeRTOS/Source/tasks.c **** 	else
3360:FreeRTOS/Source/tasks.c **** 	{
3361:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3362:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3363:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3364:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3365:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  45              		.loc 1 3365 0
  46 0012 1A68     		ldr	r2, [r3]
  47              	.LVL0:
3366:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
  48              		.loc 1 3366 0
  49 0014 034B     		ldr	r3, .L7+4
3365:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
  50              		.loc 1 3365 0
  51 0016 D268     		ldr	r2, [r2, #12]
  52              	.LVL1:
  53              		.loc 1 3366 0
  54 0018 D268     		ldr	r2, [r2, #12]
  55              	.LVL2:
  56 001a 5268     		ldr	r2, [r2, #4]
  57              	.LVL3:
  58 001c 1A60     		str	r2, [r3]
  59 001e 7047     		bx	lr
  60              	.L8:
  61              		.align	2
  62              	.L7:
  63 0020 00000000 		.word	.LANCHOR0
  64 0024 00000000 		.word	.LANCHOR1
  65              	.LBE28:
  66              	.LBE27:
  67              		.cfi_endproc
  68              	.LFE150:
  70              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
  71              		.align	2
  72              		.thumb
  73              		.thumb_func
  75              	prvAddCurrentTaskToDelayedList:
  76              	.LFB145:
3072:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
  77              		.loc 1 3072 0
  78              		.cfi_startproc
  79              		@ args = 0, pretend = 0, frame = 0
  80              		@ frame_needed = 0, uses_anonymous_args = 0
  81              	.LVL4:
3074:FreeRTOS/Source/tasks.c **** 
  82              		.loc 1 3074 0
  83 0000 0D4B     		ldr	r3, .L14
3076:FreeRTOS/Source/tasks.c **** 	{
  84              		.loc 1 3076 0
  85 0002 0E4A     		ldr	r2, .L14+4
3074:FreeRTOS/Source/tasks.c **** 
  86              		.loc 1 3074 0
  87 0004 1968     		ldr	r1, [r3]
3076:FreeRTOS/Source/tasks.c **** 	{
  88              		.loc 1 3076 0
  89 0006 1268     		ldr	r2, [r2]
3074:FreeRTOS/Source/tasks.c **** 
  90              		.loc 1 3074 0
  91 0008 4860     		str	r0, [r1, #4]
3076:FreeRTOS/Source/tasks.c **** 	{
  92              		.loc 1 3076 0
  93 000a 9042     		cmp	r0, r2
  94 000c 0DD3     		bcc	.L13
3084:FreeRTOS/Source/tasks.c **** 
  95              		.loc 1 3084 0
  96 000e 0C4A     		ldr	r2, .L14+8
3072:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
  97              		.loc 1 3072 0
  98 0010 10B5     		push	{r4, lr}
  99              	.LCFI0:
 100              		.cfi_def_cfa_offset 8
 101              		.cfi_offset 4, -8
 102              		.cfi_offset 14, -4
 103 0012 0446     		mov	r4, r0
3084:FreeRTOS/Source/tasks.c **** 
 104              		.loc 1 3084 0
 105 0014 1068     		ldr	r0, [r2]
 106              	.LVL5:
 107 0016 1968     		ldr	r1, [r3]
 108 0018 0431     		adds	r1, r1, #4
 109 001a FFF7FEFF 		bl	vListInsert
 110              	.LVL6:
3089:FreeRTOS/Source/tasks.c **** 		{
 111              		.loc 1 3089 0
 112 001e 094B     		ldr	r3, .L14+12
 113 0020 1A68     		ldr	r2, [r3]
 114 0022 9442     		cmp	r4, r2
3091:FreeRTOS/Source/tasks.c **** 		}
 115              		.loc 1 3091 0
 116 0024 38BF     		it	cc
 117 0026 1C60     		strcc	r4, [r3]
 118 0028 10BD     		pop	{r4, pc}
 119              	.LVL7:
 120              	.L13:
 121              	.LCFI1:
 122              		.cfi_def_cfa_offset 0
 123              		.cfi_restore 4
 124              		.cfi_restore 14
 125              	.LBB31:
 126              	.LBB32:
3079:FreeRTOS/Source/tasks.c **** 	}
 127              		.loc 1 3079 0
 128 002a 074A     		ldr	r2, .L14+16
 129 002c 1068     		ldr	r0, [r2]
 130              	.LVL8:
 131 002e 1968     		ldr	r1, [r3]
 132              	.LVL9:
 133 0030 0431     		adds	r1, r1, #4
 134 0032 FFF7FEBF 		b	vListInsert
 135              	.LVL10:
 136              	.L15:
 137 0036 00BF     		.align	2
 138              	.L14:
 139 0038 00000000 		.word	.LANCHOR2
 140 003c 00000000 		.word	.LANCHOR3
 141 0040 00000000 		.word	.LANCHOR0
 142 0044 00000000 		.word	.LANCHOR1
 143 0048 00000000 		.word	.LANCHOR4
 144              	.LBE32:
 145              	.LBE31:
 146              		.cfi_endproc
 147              	.LFE145:
 149              		.section	.text.vTaskSwitchContext.part.4,"ax",%progbits
 150              		.align	2
 151              		.thumb
 152              		.thumb_func
 154              	vTaskSwitchContext.part.4:
 155              	.LFB166:
2203:FreeRTOS/Source/tasks.c **** {
 156              		.loc 1 2203 0
 157              		.cfi_startproc
 158              		@ args = 0, pretend = 0, frame = 0
 159              		@ frame_needed = 0, uses_anonymous_args = 0
 160 0000 38B5     		push	{r3, r4, r5, lr}
 161              	.LCFI2:
 162              		.cfi_def_cfa_offset 16
 163              		.cfi_offset 3, -16
 164              		.cfi_offset 4, -12
 165              		.cfi_offset 5, -8
 166              		.cfi_offset 14, -4
2213:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 167              		.loc 1 2213 0
 168 0002 1D4B     		ldr	r3, .L31
2231:FreeRTOS/Source/tasks.c **** 				{
 169              		.loc 1 2231 0
 170 0004 1D4D     		ldr	r5, .L31+4
2233:FreeRTOS/Source/tasks.c **** 				}
 171              		.loc 1 2233 0
 172 0006 1E4C     		ldr	r4, .L31+8
2213:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 173              		.loc 1 2213 0
 174 0008 0022     		movs	r2, #0
 175 000a 1A60     		str	r2, [r3]
2221:FreeRTOS/Source/tasks.c **** 				#endif
 176              		.loc 1 2221 0
 177 000c FFF7FEFF 		bl	get_us_time
 178              	.LVL11:
2231:FreeRTOS/Source/tasks.c **** 				{
 179              		.loc 1 2231 0
 180 0010 2A68     		ldr	r2, [r5]
2221:FreeRTOS/Source/tasks.c **** 				#endif
 181              		.loc 1 2221 0
 182 0012 1C4B     		ldr	r3, .L31+12
2231:FreeRTOS/Source/tasks.c **** 				{
 183              		.loc 1 2231 0
 184 0014 9042     		cmp	r0, r2
2221:FreeRTOS/Source/tasks.c **** 				#endif
 185              		.loc 1 2221 0
 186 0016 1860     		str	r0, [r3]
2231:FreeRTOS/Source/tasks.c **** 				{
 187              		.loc 1 2231 0
 188 0018 04D9     		bls	.L17
2233:FreeRTOS/Source/tasks.c **** 				}
 189              		.loc 1 2233 0
 190 001a 2168     		ldr	r1, [r4]
 191 001c 0B6D     		ldr	r3, [r1, #80]
 192 001e 9B1A     		subs	r3, r3, r2
 193 0020 0344     		add	r3, r3, r0
 194 0022 0B65     		str	r3, [r1, #80]
 195              	.L17:
2248:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 196              		.loc 1 2248 0
 197 0024 184A     		ldr	r2, .L31+16
 198 0026 1949     		ldr	r1, .L31+20
 199 0028 1368     		ldr	r3, [r2]
2239:FreeRTOS/Source/tasks.c **** 		}
 200              		.loc 1 2239 0
 201 002a 2860     		str	r0, [r5]
2248:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 202              		.loc 1 2248 0
 203 002c 03EB8303 		add	r3, r3, r3, lsl #2
 204 0030 51F82330 		ldr	r3, [r1, r3, lsl #2]
 205 0034 4BB9     		cbnz	r3, .L21
 206              	.L18:
 207 0036 1368     		ldr	r3, [r2]
 208 0038 013B     		subs	r3, r3, #1
 209 003a 1360     		str	r3, [r2]
 210 003c 1368     		ldr	r3, [r2]
 211 003e 03EB8303 		add	r3, r3, r3, lsl #2
 212 0042 51F82330 		ldr	r3, [r1, r3, lsl #2]
 213 0046 002B     		cmp	r3, #0
 214 0048 F5D0     		beq	.L18
 215              	.L21:
 216              	.LBB33:
 217 004a 1368     		ldr	r3, [r2]
 218              	.LVL12:
 219 004c 03EB8303 		add	r3, r3, r3, lsl #2
 220              	.LVL13:
 221 0050 9B00     		lsls	r3, r3, #2
 222 0052 C818     		adds	r0, r1, r3
 223 0054 0833     		adds	r3, r3, #8
 224 0056 4268     		ldr	r2, [r0, #4]
 225 0058 5268     		ldr	r2, [r2, #4]
 226 005a 4260     		str	r2, [r0, #4]
 227 005c 1944     		add	r1, r1, r3
 228 005e 8A42     		cmp	r2, r1
 229 0060 06D0     		beq	.L30
 230              	.L20:
 231 0062 D368     		ldr	r3, [r2, #12]
 232 0064 2360     		str	r3, [r4]
 233              	.LBE33:
2249:FreeRTOS/Source/tasks.c **** 
 234              		.loc 1 2249 0
 235 0066 2268     		ldr	r2, [r4]
 236 0068 094B     		ldr	r3, .L31+24
 237 006a D26C     		ldr	r2, [r2, #76]
 238 006c DA60     		str	r2, [r3, #12]
 239 006e 38BD     		pop	{r3, r4, r5, pc}
 240              	.L30:
 241              	.LBB34:
2248:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 242              		.loc 1 2248 0
 243 0070 5268     		ldr	r2, [r2, #4]
 244 0072 4260     		str	r2, [r0, #4]
 245 0074 F5E7     		b	.L20
 246              	.L32:
 247 0076 00BF     		.align	2
 248              	.L31:
 249 0078 00000000 		.word	.LANCHOR5
 250 007c 00000000 		.word	.LANCHOR7
 251 0080 00000000 		.word	.LANCHOR2
 252 0084 00000000 		.word	.LANCHOR6
 253 0088 00000000 		.word	.LANCHOR8
 254 008c 00000000 		.word	.LANCHOR9
 255 0090 00740040 		.word	1073771520
 256              	.LBE34:
 257              		.cfi_endproc
 258              	.LFE166:
 260              		.section	.text.xTaskGenericCreate,"ax",%progbits
 261              		.align	2
 262              		.global	xTaskGenericCreate
 263              		.thumb
 264              		.thumb_func
 266              	xTaskGenericCreate:
 267              	.LFB110:
 552:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 268              		.loc 1 552 0
 269              		.cfi_startproc
 270              		@ args = 16, pretend = 0, frame = 0
 271              		@ frame_needed = 0, uses_anonymous_args = 0
 272              	.LVL14:
 273 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 274              	.LCFI3:
 275              		.cfi_def_cfa_offset 40
 276              		.cfi_offset 3, -40
 277              		.cfi_offset 4, -36
 278              		.cfi_offset 5, -32
 279              		.cfi_offset 6, -28
 280              		.cfi_offset 7, -24
 281              		.cfi_offset 8, -20
 282              		.cfi_offset 9, -16
 283              		.cfi_offset 10, -12
 284              		.cfi_offset 11, -8
 285              		.cfi_offset 14, -4
 552:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 286              		.loc 1 552 0
 287 0004 0C9D     		ldr	r5, [sp, #48]
 288 0006 0B9E     		ldr	r6, [sp, #44]
 289 0008 8146     		mov	r9, r0
 290 000a 8A46     		mov	r10, r1
 291 000c 9346     		mov	fp, r2
 292              	.LVL15:
 293 000e 9846     		mov	r8, r3
 294              	.LBB42:
 295              	.LBB43:
 296              	.LBB44:
3134:FreeRTOS/Source/tasks.c **** 
 297              		.loc 1 3134 0
 298 0010 002D     		cmp	r5, #0
 299 0012 00F08980 		beq	.L67
 300              	.LVL16:
 301              	.L34:
3140:FreeRTOS/Source/tasks.c **** 
 302              		.loc 1 3140 0
 303 0016 5C20     		movs	r0, #92
 304 0018 FFF7FEFF 		bl	malloc
 305              	.LVL17:
3142:FreeRTOS/Source/tasks.c **** 			{
 306              		.loc 1 3142 0
 307 001c 0446     		mov	r4, r0
 308 001e 0028     		cmp	r0, #0
 309 0020 00F08D80 		beq	.L36
 310              	.LBE44:
3167:FreeRTOS/Source/tasks.c **** 		}
 311              		.loc 1 3167 0
 312 0024 4FEA8B0B 		lsl	fp, fp, #2
 313 0028 5A46     		mov	r2, fp
 314              	.LBE43:
 315              	.LBE42:
 600:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINT
 316              		.loc 1 600 0
 317 002a ABF1040B 		sub	fp, fp, #4
 318              	.LBB52:
 319              	.LBB48:
 320              	.LBB45:
3145:FreeRTOS/Source/tasks.c **** 			}
 321              		.loc 1 3145 0
 322 002e 0563     		str	r5, [r0, #48]
 323              	.LBE45:
3167:FreeRTOS/Source/tasks.c **** 		}
 324              		.loc 1 3167 0
 325 0030 A521     		movs	r1, #165
 326 0032 2846     		mov	r0, r5
 327              	.LVL18:
 328              	.LBE48:
 329              	.LBE52:
 600:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINT
 330              		.loc 1 600 0
 331 0034 5D44     		add	r5, r5, fp
 332              	.LVL19:
 333              	.LBB53:
 334              	.LBB49:
3167:FreeRTOS/Source/tasks.c **** 		}
 335              		.loc 1 3167 0
 336 0036 FFF7FEFF 		bl	memset
 337              	.LVL20:
 338              	.LBE49:
 339              	.LBE53:
 601:FreeRTOS/Source/tasks.c **** 
 340              		.loc 1 601 0
 341 003a 25F00705 		bic	r5, r5, #7
 342              	.LVL21:
 343 003e 0AF1FF33 		add	r3, r10, #-1
 344 0042 0AF10F01 		add	r1, r10, #15
 345 0046 04F13300 		add	r0, r4, #51
 346              	.LVL22:
 347              	.L37:
 348              	.LBB54:
 349              	.LBB55:
2840:FreeRTOS/Source/tasks.c **** 
 350              		.loc 1 2840 0
 351 004a 13F8012F 		ldrb	r2, [r3, #1]!	@ zero_extendqisi2
 352              	.LVL23:
 353 004e 00F8012F 		strb	r2, [r0, #1]!
2845:FreeRTOS/Source/tasks.c **** 		{
 354              		.loc 1 2845 0
 355 0052 0AB1     		cbz	r2, .L38
2838:FreeRTOS/Source/tasks.c **** 	{
 356              		.loc 1 2838 0
 357 0054 8B42     		cmp	r3, r1
 358 0056 F8D1     		bne	.L37
 359              	.L38:
 360 0058 0A9B     		ldr	r3, [sp, #40]
 361              	.LVL24:
 362 005a 042B     		cmp	r3, #4
 363 005c 28BF     		it	cs
 364 005e 0423     		movcs	r3, #4
2857:FreeRTOS/Source/tasks.c **** 
 365              		.loc 1 2857 0
 366 0060 0027     		movs	r7, #0
2878:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 367              		.loc 1 2878 0
 368 0062 04F1040B 		add	fp, r4, #4
2870:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 369              		.loc 1 2870 0
 370 0066 E362     		str	r3, [r4, #44]
2873:FreeRTOS/Source/tasks.c **** 		pxTCB->uxMutexesHeld = 0;
 371              		.loc 1 2873 0
 372 0068 6364     		str	r3, [r4, #68]
2878:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 373              		.loc 1 2878 0
 374 006a 5846     		mov	r0, fp
2857:FreeRTOS/Source/tasks.c **** 
 375              		.loc 1 2857 0
 376 006c 84F84370 		strb	r7, [r4, #67]
2874:FreeRTOS/Source/tasks.c **** 	}
 377              		.loc 1 2874 0
 378 0070 A764     		str	r7, [r4, #72]
 379 0072 9A46     		mov	r10, r3
 380              	.LVL25:
2878:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 381              		.loc 1 2878 0
 382 0074 FFF7FEFF 		bl	vListInitialiseItem
 383              	.LVL26:
2879:FreeRTOS/Source/tasks.c **** 
 384              		.loc 1 2879 0
 385 0078 04F11800 		add	r0, r4, #24
 386 007c FFF7FEFF 		bl	vListInitialiseItem
 387              	.LVL27:
2886:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 388              		.loc 1 2886 0
 389 0080 CAF10503 		rsb	r3, r10, #5
2929:FreeRTOS/Source/tasks.c **** 		pxTCB->eNotifyState = eNotWaitingNotification;
 390              		.loc 1 2929 0
 391 0084 6765     		str	r7, [r4, #84]
2886:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 392              		.loc 1 2886 0
 393 0086 A361     		str	r3, [r4, #24]
2897:FreeRTOS/Source/tasks.c **** 	}
 394              		.loc 1 2897 0
 395 0088 E764     		str	r7, [r4, #76]
2903:FreeRTOS/Source/tasks.c **** 	}
 396              		.loc 1 2903 0
 397 008a 2765     		str	r7, [r4, #80]
2930:FreeRTOS/Source/tasks.c **** 	}
 398              		.loc 1 2930 0
 399 008c 84F85870 		strb	r7, [r4, #88]
2883:FreeRTOS/Source/tasks.c **** 
 400              		.loc 1 2883 0
 401 0090 2461     		str	r4, [r4, #16]
2887:FreeRTOS/Source/tasks.c **** 
 402              		.loc 1 2887 0
 403 0092 6462     		str	r4, [r4, #36]
 404              	.LBE55:
 405              	.LBE54:
 633:FreeRTOS/Source/tasks.c **** 		}
 406              		.loc 1 633 0
 407 0094 2846     		mov	r0, r5
 408 0096 4946     		mov	r1, r9
 409 0098 4246     		mov	r2, r8
 410 009a FFF7FEFF 		bl	pxPortInitialiseStack
 411              	.LVL28:
 412 009e 2060     		str	r0, [r4]
 637:FreeRTOS/Source/tasks.c **** 		{
 413              		.loc 1 637 0
 414 00a0 06B1     		cbz	r6, .L39
 642:FreeRTOS/Source/tasks.c **** 		}
 415              		.loc 1 642 0
 416 00a2 3460     		str	r4, [r6]
 417              	.L39:
 651:FreeRTOS/Source/tasks.c **** 		{
 418              		.loc 1 651 0
 419 00a4 FFF7FEFF 		bl	vPortEnterCritical
 420              	.LVL29:
 653:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 421              		.loc 1 653 0
 422 00a8 394A     		ldr	r2, .L70
 654:FreeRTOS/Source/tasks.c **** 			{
 423              		.loc 1 654 0
 424 00aa 3A4D     		ldr	r5, .L70+4
 425              	.LVL30:
 653:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 426              		.loc 1 653 0
 427 00ac 1368     		ldr	r3, [r2]
 428 00ae 0133     		adds	r3, r3, #1
 429 00b0 1360     		str	r3, [r2]
 654:FreeRTOS/Source/tasks.c **** 			{
 430              		.loc 1 654 0
 431 00b2 2B68     		ldr	r3, [r5]
 432 00b4 002B     		cmp	r3, #0
 433 00b6 2FD0     		beq	.L68
 677:FreeRTOS/Source/tasks.c **** 				{
 434              		.loc 1 677 0
 435 00b8 374E     		ldr	r6, .L70+8
 436 00ba 3368     		ldr	r3, [r6]
 437 00bc F3B1     		cbz	r3, .L63
 438 00be DFF8F880 		ldr	r8, .L70+40
 439              	.LVL31:
 440              	.L42:
 704:FreeRTOS/Source/tasks.c **** 
 441              		.loc 1 704 0
 442 00c2 3649     		ldr	r1, .L70+12
 443 00c4 E06A     		ldr	r0, [r4, #44]
 694:FreeRTOS/Source/tasks.c **** 
 444              		.loc 1 694 0
 445 00c6 364A     		ldr	r2, .L70+16
 704:FreeRTOS/Source/tasks.c **** 
 446              		.loc 1 704 0
 447 00c8 0C68     		ldr	r4, [r1]
 448              	.LVL32:
 694:FreeRTOS/Source/tasks.c **** 
 449              		.loc 1 694 0
 450 00ca 1368     		ldr	r3, [r2]
 704:FreeRTOS/Source/tasks.c **** 
 451              		.loc 1 704 0
 452 00cc A042     		cmp	r0, r4
 453 00ce 88BF     		it	hi
 454 00d0 0860     		strhi	r0, [r1]
 455 00d2 00EB8000 		add	r0, r0, r0, lsl #2
 694:FreeRTOS/Source/tasks.c **** 
 456              		.loc 1 694 0
 457 00d6 0133     		adds	r3, r3, #1
 704:FreeRTOS/Source/tasks.c **** 
 458              		.loc 1 704 0
 459 00d8 08EB8000 		add	r0, r8, r0, lsl #2
 460 00dc 5946     		mov	r1, fp
 694:FreeRTOS/Source/tasks.c **** 
 461              		.loc 1 694 0
 462 00de 1360     		str	r3, [r2]
 704:FreeRTOS/Source/tasks.c **** 
 463              		.loc 1 704 0
 464 00e0 FFF7FEFF 		bl	vListInsertEnd
 465              	.LVL33:
 709:FreeRTOS/Source/tasks.c **** 	}
 466              		.loc 1 709 0
 467 00e4 FFF7FEFF 		bl	vPortExitCritical
 468              	.LVL34:
 719:FreeRTOS/Source/tasks.c **** 		{
 469              		.loc 1 719 0
 470 00e8 3368     		ldr	r3, [r6]
 471 00ea 23B1     		cbz	r3, .L49
 723:FreeRTOS/Source/tasks.c **** 			{
 472              		.loc 1 723 0
 473 00ec 2B68     		ldr	r3, [r5]
 474 00ee 0A9A     		ldr	r2, [sp, #40]
 475 00f0 DB6A     		ldr	r3, [r3, #44]
 476 00f2 9A42     		cmp	r2, r3
 477 00f4 0BD8     		bhi	.L69
 478              	.L49:
 479 00f6 0120     		movs	r0, #1
 480 00f8 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 481              	.LVL35:
 482              	.L63:
 679:FreeRTOS/Source/tasks.c **** 					{
 483              		.loc 1 679 0
 484 00fc 2B68     		ldr	r3, [r5]
 485 00fe 0A9A     		ldr	r2, [sp, #40]
 486 0100 DB6A     		ldr	r3, [r3, #44]
 487 0102 DFF8B480 		ldr	r8, .L70+40
 488              	.LVL36:
 489 0106 9A42     		cmp	r2, r3
 681:FreeRTOS/Source/tasks.c **** 					}
 490              		.loc 1 681 0
 491 0108 28BF     		it	cs
 492 010a 2C60     		strcs	r4, [r5]
 493 010c D9E7     		b	.L42
 494              	.LVL37:
 495              	.L69:
 725:FreeRTOS/Source/tasks.c **** 			}
 496              		.loc 1 725 0
 497 010e FFF7FEFF 		bl	vPortYieldFromISR
 498              	.LVL38:
 499 0112 0120     		movs	r0, #1
 500 0114 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 501              	.LVL39:
 502              	.L68:
 658:FreeRTOS/Source/tasks.c **** 
 503              		.loc 1 658 0
 504 0118 2C60     		str	r4, [r5]
 660:FreeRTOS/Source/tasks.c **** 				{
 505              		.loc 1 660 0
 506 011a 1368     		ldr	r3, [r2]
 507 011c DFF89880 		ldr	r8, .L70+40
 508              	.LVL40:
 509 0120 012B     		cmp	r3, #1
 510 0122 10D0     		beq	.L41
 511 0124 1C4E     		ldr	r6, .L70+8
 512 0126 CCE7     		b	.L42
 513              	.LVL41:
 514              	.L67:
 515              	.LBB56:
 516              	.LBB50:
 517              	.LBB46:
3134:FreeRTOS/Source/tasks.c **** 
 518              		.loc 1 3134 0
 519 0128 9000     		lsls	r0, r2, #2
 520              	.LVL42:
 521 012a FFF7FEFF 		bl	malloc
 522              	.LVL43:
3136:FreeRTOS/Source/tasks.c **** 		{
 523              		.loc 1 3136 0
 524 012e 0546     		mov	r5, r0
 525              	.LVL44:
 526 0130 0028     		cmp	r0, #0
 527 0132 7FF470AF 		bne	.L34
 528              	.LVL45:
 529              	.L35:
 530              	.LBE46:
 531              	.LBE50:
 532              	.LBE56:
 713:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 533              		.loc 1 713 0
 534 0136 4FF0FF30 		mov	r0, #-1
 739:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 535              		.loc 1 739 0
 536 013a BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 537              	.LVL46:
 538              	.L36:
 539              	.LBB57:
 540              	.LBB51:
 541              	.LBB47:
3151:FreeRTOS/Source/tasks.c **** 			}
 542              		.loc 1 3151 0
 543 013e 2846     		mov	r0, r5
 544              	.LVL47:
 545 0140 FFF7FEFF 		bl	free
 546              	.LVL48:
 547 0144 F7E7     		b	.L35
 548              	.LVL49:
 549              	.L41:
 550 0146 4646     		mov	r6, r8
 551 0148 08F16409 		add	r9, r8, #100
 552              	.LVL50:
 553              	.L43:
 554              	.LBE47:
 555              	.LBE51:
 556              	.LBE57:
 557              	.LBB58:
 558              	.LBB59:
3004:FreeRTOS/Source/tasks.c **** 	}
 559              		.loc 1 3004 0
 560 014c 3046     		mov	r0, r6
 561 014e 1436     		adds	r6, r6, #20
 562 0150 FFF7FEFF 		bl	vListInitialise
 563              	.LVL51:
3002:FreeRTOS/Source/tasks.c **** 	{
 564              		.loc 1 3002 0
 565 0154 4E45     		cmp	r6, r9
 566 0156 F9D1     		bne	.L43
3007:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 567              		.loc 1 3007 0
 568 0158 DFF860A0 		ldr	r10, .L70+44
 569              	.LVL52:
3008:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 570              		.loc 1 3008 0
 571 015c DFF86090 		ldr	r9, .L70+48
 572 0160 0D4E     		ldr	r6, .L70+8
3007:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 573              		.loc 1 3007 0
 574 0162 5046     		mov	r0, r10
 575 0164 FFF7FEFF 		bl	vListInitialise
 576              	.LVL53:
3008:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 577              		.loc 1 3008 0
 578 0168 4846     		mov	r0, r9
 579 016a FFF7FEFF 		bl	vListInitialise
 580              	.LVL54:
3009:FreeRTOS/Source/tasks.c **** 
 581              		.loc 1 3009 0
 582 016e 0D48     		ldr	r0, .L70+20
 583 0170 FFF7FEFF 		bl	vListInitialise
 584              	.LVL55:
3013:FreeRTOS/Source/tasks.c **** 	}
 585              		.loc 1 3013 0
 586 0174 0C48     		ldr	r0, .L70+24
 587 0176 FFF7FEFF 		bl	vListInitialise
 588              	.LVL56:
3019:FreeRTOS/Source/tasks.c **** 	}
 589              		.loc 1 3019 0
 590 017a 0C48     		ldr	r0, .L70+28
 591 017c FFF7FEFF 		bl	vListInitialise
 592              	.LVL57:
3025:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 593              		.loc 1 3025 0
 594 0180 0B4A     		ldr	r2, .L70+32
3026:FreeRTOS/Source/tasks.c **** }
 595              		.loc 1 3026 0
 596 0182 0C4B     		ldr	r3, .L70+36
3025:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 597              		.loc 1 3025 0
 598 0184 C2F800A0 		str	r10, [r2]
3026:FreeRTOS/Source/tasks.c **** }
 599              		.loc 1 3026 0
 600 0188 C3F80090 		str	r9, [r3]
 601 018c 99E7     		b	.L42
 602              	.L71:
 603 018e 00BF     		.align	2
 604              	.L70:
 605 0190 00000000 		.word	.LANCHOR10
 606 0194 00000000 		.word	.LANCHOR2
 607 0198 00000000 		.word	.LANCHOR16
 608 019c 00000000 		.word	.LANCHOR8
 609 01a0 00000000 		.word	.LANCHOR17
 610 01a4 00000000 		.word	.LANCHOR13
 611 01a8 00000000 		.word	.LANCHOR14
 612 01ac 00000000 		.word	.LANCHOR15
 613 01b0 00000000 		.word	.LANCHOR0
 614 01b4 00000000 		.word	.LANCHOR4
 615 01b8 00000000 		.word	.LANCHOR9
 616 01bc 00000000 		.word	.LANCHOR11
 617 01c0 00000000 		.word	.LANCHOR12
 618              	.LBE59:
 619              	.LBE58:
 620              		.cfi_endproc
 621              	.LFE110:
 623              		.section	.text.vTaskDelete,"ax",%progbits
 624              		.align	2
 625              		.global	vTaskDelete
 626              		.thumb
 627              		.thumb_func
 629              	vTaskDelete:
 630              	.LFB111:
 745:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 631              		.loc 1 745 0
 632              		.cfi_startproc
 633              		@ args = 0, pretend = 0, frame = 0
 634              		@ frame_needed = 0, uses_anonymous_args = 0
 635              	.LVL58:
 636 0000 38B5     		push	{r3, r4, r5, lr}
 637              	.LCFI4:
 638              		.cfi_def_cfa_offset 16
 639              		.cfi_offset 3, -16
 640              		.cfi_offset 4, -12
 641              		.cfi_offset 5, -8
 642              		.cfi_offset 14, -4
 745:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 643              		.loc 1 745 0
 644 0002 0446     		mov	r4, r0
 748:FreeRTOS/Source/tasks.c **** 		{
 645              		.loc 1 748 0
 646 0004 FFF7FEFF 		bl	vPortEnterCritical
 647              	.LVL59:
 752:FreeRTOS/Source/tasks.c **** 
 648              		.loc 1 752 0
 649 0008 3CB3     		cbz	r4, .L81
 650              	.LVL60:
 651              	.L73:
 758:FreeRTOS/Source/tasks.c **** 			{
 652              		.loc 1 758 0 discriminator 4
 653 000a 251D     		adds	r5, r4, #4
 654 000c 2846     		mov	r0, r5
 655 000e FFF7FEFF 		bl	uxListRemove
 656              	.LVL61:
 768:FreeRTOS/Source/tasks.c **** 			{
 657              		.loc 1 768 0 discriminator 4
 658 0012 A36A     		ldr	r3, [r4, #40]
 659 0014 1BB1     		cbz	r3, .L74
 770:FreeRTOS/Source/tasks.c **** 			}
 660              		.loc 1 770 0
 661 0016 04F11800 		add	r0, r4, #24
 662 001a FFF7FEFF 		bl	uxListRemove
 663              	.LVL62:
 664              	.L74:
 777:FreeRTOS/Source/tasks.c **** 
 665              		.loc 1 777 0
 666 001e 2946     		mov	r1, r5
 667 0020 1148     		ldr	r0, .L83
 668 0022 FFF7FEFF 		bl	vListInsertEnd
 669              	.LVL63:
 782:FreeRTOS/Source/tasks.c **** 
 670              		.loc 1 782 0
 671 0026 1148     		ldr	r0, .L83+4
 786:FreeRTOS/Source/tasks.c **** 
 672              		.loc 1 786 0
 673 0028 1149     		ldr	r1, .L83+8
 782:FreeRTOS/Source/tasks.c **** 
 674              		.loc 1 782 0
 675 002a 0268     		ldr	r2, [r0]
 786:FreeRTOS/Source/tasks.c **** 
 676              		.loc 1 786 0
 677 002c 0B68     		ldr	r3, [r1]
 782:FreeRTOS/Source/tasks.c **** 
 678              		.loc 1 782 0
 679 002e 0132     		adds	r2, r2, #1
 786:FreeRTOS/Source/tasks.c **** 
 680              		.loc 1 786 0
 681 0030 0133     		adds	r3, r3, #1
 682 0032 0B60     		str	r3, [r1]
 782:FreeRTOS/Source/tasks.c **** 
 683              		.loc 1 782 0
 684 0034 0260     		str	r2, [r0]
 790:FreeRTOS/Source/tasks.c **** 
 685              		.loc 1 790 0
 686 0036 FFF7FEFF 		bl	vPortExitCritical
 687              	.LVL64:
 794:FreeRTOS/Source/tasks.c **** 		{
 688              		.loc 1 794 0
 689 003a 0E4B     		ldr	r3, .L83+12
 690 003c 1B68     		ldr	r3, [r3]
 691 003e 5BB1     		cbz	r3, .L72
 796:FreeRTOS/Source/tasks.c **** 			{
 692              		.loc 1 796 0
 693 0040 0D4B     		ldr	r3, .L83+16
 694 0042 1B68     		ldr	r3, [r3]
 695 0044 9C42     		cmp	r4, r3
 696 0046 0BD0     		beq	.L82
 812:FreeRTOS/Source/tasks.c **** 				{
 697              		.loc 1 812 0
 698 0048 FFF7FEFF 		bl	vPortEnterCritical
 699              	.LVL65:
 814:FreeRTOS/Source/tasks.c **** 				}
 700              		.loc 1 814 0
 701 004c FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 702              	.LVL66:
 819:FreeRTOS/Source/tasks.c **** 
 703              		.loc 1 819 0
 704 0050 BDE83840 		pop	{r3, r4, r5, lr}
 705              	.LCFI5:
 706              		.cfi_remember_state
 707              		.cfi_restore 14
 708              		.cfi_restore 5
 709              		.cfi_restore 4
 710              		.cfi_restore 3
 711              		.cfi_def_cfa_offset 0
 712              	.LVL67:
 816:FreeRTOS/Source/tasks.c **** 			}
 713              		.loc 1 816 0
 714 0054 FFF7FEBF 		b	vPortExitCritical
 715              	.LVL68:
 716              	.L72:
 717              	.LCFI6:
 718              		.cfi_restore_state
 719 0058 38BD     		pop	{r3, r4, r5, pc}
 720              	.LVL69:
 721              	.L81:
 752:FreeRTOS/Source/tasks.c **** 
 722              		.loc 1 752 0 discriminator 1
 723 005a 074B     		ldr	r3, .L83+16
 724 005c 1C68     		ldr	r4, [r3]
 725              	.LVL70:
 726 005e D4E7     		b	.L73
 727              	.LVL71:
 728              	.L82:
 819:FreeRTOS/Source/tasks.c **** 
 729              		.loc 1 819 0
 730 0060 BDE83840 		pop	{r3, r4, r5, lr}
 731              	.LCFI7:
 732              		.cfi_restore 14
 733              		.cfi_restore 5
 734              		.cfi_restore 4
 735              		.cfi_restore 3
 736              		.cfi_def_cfa_offset 0
 737              	.LVL72:
 806:FreeRTOS/Source/tasks.c **** 			}
 738              		.loc 1 806 0
 739 0064 FFF7FEBF 		b	vPortYieldFromISR
 740              	.LVL73:
 741              	.L84:
 742              		.align	2
 743              	.L83:
 744 0068 00000000 		.word	.LANCHOR14
 745 006c 00000000 		.word	.LANCHOR18
 746 0070 00000000 		.word	.LANCHOR17
 747 0074 00000000 		.word	.LANCHOR16
 748 0078 00000000 		.word	.LANCHOR2
 749              		.cfi_endproc
 750              	.LFE111:
 752              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 753              		.align	2
 754              		.global	uxTaskPriorityGet
 755              		.thumb
 756              		.thumb_func
 758              	uxTaskPriorityGet:
 759              	.LFB114:
1059:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 760              		.loc 1 1059 0
 761              		.cfi_startproc
 762              		@ args = 0, pretend = 0, frame = 0
 763              		@ frame_needed = 0, uses_anonymous_args = 0
 764              	.LVL74:
 765 0000 10B5     		push	{r4, lr}
 766              	.LCFI8:
 767              		.cfi_def_cfa_offset 8
 768              		.cfi_offset 4, -8
 769              		.cfi_offset 14, -4
1059:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 770              		.loc 1 1059 0
 771 0002 0446     		mov	r4, r0
1063:FreeRTOS/Source/tasks.c **** 		{
 772              		.loc 1 1063 0
 773 0004 FFF7FEFF 		bl	vPortEnterCritical
 774              	.LVL75:
1067:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 775              		.loc 1 1067 0
 776 0008 24B1     		cbz	r4, .L88
 777              	.LVL76:
1068:FreeRTOS/Source/tasks.c **** 		}
 778              		.loc 1 1068 0 discriminator 4
 779 000a E46A     		ldr	r4, [r4, #44]
 780              	.LVL77:
1070:FreeRTOS/Source/tasks.c **** 
 781              		.loc 1 1070 0 discriminator 4
 782 000c FFF7FEFF 		bl	vPortExitCritical
 783              	.LVL78:
1073:FreeRTOS/Source/tasks.c **** 
 784              		.loc 1 1073 0 discriminator 4
 785 0010 2046     		mov	r0, r4
 786 0012 10BD     		pop	{r4, pc}
 787              	.LVL79:
 788              	.L88:
1067:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 789              		.loc 1 1067 0 discriminator 1
 790 0014 034B     		ldr	r3, .L89
 791 0016 1C68     		ldr	r4, [r3]
 792              	.LVL80:
1068:FreeRTOS/Source/tasks.c **** 		}
 793              		.loc 1 1068 0 discriminator 1
 794 0018 E46A     		ldr	r4, [r4, #44]
 795              	.LVL81:
1070:FreeRTOS/Source/tasks.c **** 
 796              		.loc 1 1070 0 discriminator 1
 797 001a FFF7FEFF 		bl	vPortExitCritical
 798              	.LVL82:
1073:FreeRTOS/Source/tasks.c **** 
 799              		.loc 1 1073 0 discriminator 1
 800 001e 2046     		mov	r0, r4
 801 0020 10BD     		pop	{r4, pc}
 802              	.LVL83:
 803              	.L90:
 804 0022 00BF     		.align	2
 805              	.L89:
 806 0024 00000000 		.word	.LANCHOR2
 807              		.cfi_endproc
 808              	.LFE114:
 810              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 811              		.align	2
 812              		.global	uxTaskPriorityGetFromISR
 813              		.thumb
 814              		.thumb_func
 816              	uxTaskPriorityGetFromISR:
 817              	.LFB115:
1081:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 818              		.loc 1 1081 0
 819              		.cfi_startproc
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              		@ link register save eliminated.
 823              	.LVL84:
1081:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 824              		.loc 1 1081 0
 825 0000 0346     		mov	r3, r0
1103:FreeRTOS/Source/tasks.c **** 		{
 826              		.loc 1 1103 0
 827              	@ 1103 "FreeRTOS/Source/tasks.c" 1
 828 0002 4FF0BF00 			mov r0, #191								
 829 0006 80F31188 		msr basepri, r0							
 830              	
 831              	@ 0 "" 2
 832              	.LVL85:
1107:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 833              		.loc 1 1107 0
 834              		.thumb
 835 000a 2BB1     		cbz	r3, .L93
 836              	.LVL86:
 837              	.L92:
1110:FreeRTOS/Source/tasks.c **** 
 838              		.loc 1 1110 0 discriminator 4
 839              	@ 1110 "FreeRTOS/Source/tasks.c" 1
 840 000c 4FF00000 			mov r0, #0					
 841 0010 80F31188 		msr basepri, r0				
 842              	
 843              	@ 0 "" 2
1113:FreeRTOS/Source/tasks.c **** 
 844              		.loc 1 1113 0 discriminator 4
 845              		.thumb
 846 0014 D86A     		ldr	r0, [r3, #44]
 847 0016 7047     		bx	lr
 848              	.LVL87:
 849              	.L93:
1107:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 850              		.loc 1 1107 0 discriminator 1
 851 0018 014B     		ldr	r3, .L94
 852              	.LVL88:
 853 001a 1B68     		ldr	r3, [r3]
 854              	.LVL89:
 855 001c F6E7     		b	.L92
 856              	.L95:
 857 001e 00BF     		.align	2
 858              	.L94:
 859 0020 00000000 		.word	.LANCHOR2
 860              		.cfi_endproc
 861              	.LFE115:
 863              		.section	.text.vTaskPrioritySet,"ax",%progbits
 864              		.align	2
 865              		.global	vTaskPrioritySet
 866              		.thumb
 867              		.thumb_func
 869              	vTaskPrioritySet:
 870              	.LFB116:
1121:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 871              		.loc 1 1121 0
 872              		.cfi_startproc
 873              		@ args = 0, pretend = 0, frame = 0
 874              		@ frame_needed = 0, uses_anonymous_args = 0
 875              	.LVL90:
 876 0000 0429     		cmp	r1, #4
 877 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 878              	.LCFI9:
 879              		.cfi_def_cfa_offset 24
 880              		.cfi_offset 3, -24
 881              		.cfi_offset 4, -20
 882              		.cfi_offset 5, -16
 883              		.cfi_offset 6, -12
 884              		.cfi_offset 7, -8
 885              		.cfi_offset 14, -4
 886 0004 28BF     		it	cs
 887 0006 0421     		movcs	r1, #4
 888              	.LVL91:
1121:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 889              		.loc 1 1121 0
 890 0008 0446     		mov	r4, r0
 891 000a 0D46     		mov	r5, r1
 892              	.LVL92:
1138:FreeRTOS/Source/tasks.c **** 		{
 893              		.loc 1 1138 0
 894 000c FFF7FEFF 		bl	vPortEnterCritical
 895              	.LVL93:
1142:FreeRTOS/Source/tasks.c **** 
 896              		.loc 1 1142 0
 897 0010 002C     		cmp	r4, #0
 898 0012 3ED0     		beq	.L112
 899              	.LVL94:
 900              	.L97:
1148:FreeRTOS/Source/tasks.c **** 			}
 901              		.loc 1 1148 0 discriminator 4
 902 0014 626C     		ldr	r2, [r4, #68]
 903              	.LVL95:
1156:FreeRTOS/Source/tasks.c **** 			{
 904              		.loc 1 1156 0 discriminator 4
 905 0016 AA42     		cmp	r2, r5
 906 0018 37D0     		beq	.L99
1162:FreeRTOS/Source/tasks.c **** 					{
 907              		.loc 1 1162 0
 908 001a 204B     		ldr	r3, .L113
1160:FreeRTOS/Source/tasks.c **** 				{
 909              		.loc 1 1160 0
 910 001c 09D2     		bcs	.L100
1162:FreeRTOS/Source/tasks.c **** 					{
 911              		.loc 1 1162 0
 912 001e 1968     		ldr	r1, [r3]
 913 0020 8C42     		cmp	r4, r1
 914 0022 39D0     		beq	.L109
1167:FreeRTOS/Source/tasks.c **** 						{
 915              		.loc 1 1167 0
 916 0024 1B68     		ldr	r3, [r3]
 917 0026 DE6A     		ldr	r6, [r3, #44]
 918 0028 AE42     		cmp	r6, r5
 919 002a 8CBF     		ite	hi
 920 002c 0026     		movhi	r6, #0
 921 002e 0126     		movls	r6, #1
 922 0030 04E0     		b	.L101
 923              	.L100:
1183:FreeRTOS/Source/tasks.c **** 				{
 924              		.loc 1 1183 0
 925 0032 1E68     		ldr	r6, [r3]
 926 0034 A61B     		subs	r6, r4, r6
 927 0036 B6FA86F6 		clz	r6, r6
 928 003a 7609     		lsrs	r6, r6, #5
 929              	.L101:
 930              	.LVL96:
1200:FreeRTOS/Source/tasks.c **** 
 931              		.loc 1 1200 0
 932 003c E36A     		ldr	r3, [r4, #44]
 933              	.LVL97:
1216:FreeRTOS/Source/tasks.c **** 				}
 934              		.loc 1 1216 0
 935 003e 6564     		str	r5, [r4, #68]
1206:FreeRTOS/Source/tasks.c **** 					{
 936              		.loc 1 1206 0
 937 0040 9A42     		cmp	r2, r3
1226:FreeRTOS/Source/tasks.c **** 				{
 938              		.loc 1 1226 0
 939 0042 A269     		ldr	r2, [r4, #24]
 940              	.LVL98:
1208:FreeRTOS/Source/tasks.c **** 					}
 941              		.loc 1 1208 0
 942 0044 08BF     		it	eq
 943 0046 E562     		streq	r5, [r4, #44]
1226:FreeRTOS/Source/tasks.c **** 				{
 944              		.loc 1 1226 0
 945 0048 002A     		cmp	r2, #0
1228:FreeRTOS/Source/tasks.c **** 				}
 946              		.loc 1 1228 0
 947 004a A4BF     		itt	ge
 948 004c C5F10505 		rsbge	r5, r5, #5
 949              	.LVL99:
 950 0050 A561     		strge	r5, [r4, #24]
1239:FreeRTOS/Source/tasks.c **** 				{
 951              		.loc 1 1239 0
 952 0052 134D     		ldr	r5, .L113+4
 953 0054 6269     		ldr	r2, [r4, #20]
 954 0056 03EB8303 		add	r3, r3, r3, lsl #2
 955              	.LVL100:
 956 005a 05EB8303 		add	r3, r5, r3, lsl #2
 957 005e 9A42     		cmp	r2, r3
 958 0060 10D1     		bne	.L105
1244:FreeRTOS/Source/tasks.c **** 					{
 959              		.loc 1 1244 0
 960 0062 271D     		adds	r7, r4, #4
 961 0064 3846     		mov	r0, r7
 962 0066 FFF7FEFF 		bl	uxListRemove
 963              	.LVL101:
1255:FreeRTOS/Source/tasks.c **** 				}
 964              		.loc 1 1255 0
 965 006a 0E4B     		ldr	r3, .L113+8
 966 006c E06A     		ldr	r0, [r4, #44]
 967 006e 1A68     		ldr	r2, [r3]
 968 0070 9042     		cmp	r0, r2
 969 0072 00D9     		bls	.L108
1255:FreeRTOS/Source/tasks.c **** 				}
 970              		.loc 1 1255 0 is_stmt 0 discriminator 1
 971 0074 1860     		str	r0, [r3]
 972              	.L108:
1255:FreeRTOS/Source/tasks.c **** 				}
 973              		.loc 1 1255 0 discriminator 3
 974 0076 00EB8000 		add	r0, r0, r0, lsl #2
 975 007a 05EB8000 		add	r0, r5, r0, lsl #2
 976 007e 3946     		mov	r1, r7
 977 0080 FFF7FEFF 		bl	vListInsertEnd
 978              	.LVL102:
 979              	.L105:
1262:FreeRTOS/Source/tasks.c **** 				{
 980              		.loc 1 1262 0 is_stmt 1
 981 0084 0EB1     		cbz	r6, .L99
1264:FreeRTOS/Source/tasks.c **** 				}
 982              		.loc 1 1264 0
 983 0086 FFF7FEFF 		bl	vPortYieldFromISR
 984              	.LVL103:
 985              	.L99:
1277:FreeRTOS/Source/tasks.c **** 
 986              		.loc 1 1277 0
 987 008a BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 988              	.LCFI10:
 989              		.cfi_remember_state
 990              		.cfi_restore 14
 991              		.cfi_restore 7
 992              		.cfi_restore 6
 993              		.cfi_restore 5
 994              		.cfi_restore 4
 995              		.cfi_restore 3
 996              		.cfi_def_cfa_offset 0
 997              	.LVL104:
1276:FreeRTOS/Source/tasks.c **** 	}
 998              		.loc 1 1276 0
 999 008e FFF7FEBF 		b	vPortExitCritical
 1000              	.LVL105:
 1001              	.L112:
 1002              	.LCFI11:
 1003              		.cfi_restore_state
1142:FreeRTOS/Source/tasks.c **** 
 1004              		.loc 1 1142 0 discriminator 1
 1005 0092 024B     		ldr	r3, .L113
 1006 0094 1C68     		ldr	r4, [r3]
 1007              	.LVL106:
 1008 0096 BDE7     		b	.L97
 1009              	.LVL107:
 1010              	.L109:
1124:FreeRTOS/Source/tasks.c **** 
 1011              		.loc 1 1124 0
 1012 0098 0026     		movs	r6, #0
 1013 009a CFE7     		b	.L101
 1014              	.L114:
 1015              		.align	2
 1016              	.L113:
 1017 009c 00000000 		.word	.LANCHOR2
 1018 00a0 00000000 		.word	.LANCHOR9
 1019 00a4 00000000 		.word	.LANCHOR8
 1020              		.cfi_endproc
 1021              	.LFE116:
 1023              		.section	.text.vTaskSuspend,"ax",%progbits
 1024              		.align	2
 1025              		.global	vTaskSuspend
 1026              		.thumb
 1027              		.thumb_func
 1029              	vTaskSuspend:
 1030              	.LFB117:
1285:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 1031              		.loc 1 1285 0
 1032              		.cfi_startproc
 1033              		@ args = 0, pretend = 0, frame = 0
 1034              		@ frame_needed = 0, uses_anonymous_args = 0
 1035              	.LVL108:
 1036 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1037              	.LCFI12:
 1038              		.cfi_def_cfa_offset 24
 1039              		.cfi_offset 3, -24
 1040              		.cfi_offset 4, -20
 1041              		.cfi_offset 5, -16
 1042              		.cfi_offset 6, -12
 1043              		.cfi_offset 7, -8
 1044              		.cfi_offset 14, -4
1285:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 1045              		.loc 1 1285 0
 1046 0002 0446     		mov	r4, r0
1292:FreeRTOS/Source/tasks.c **** 
 1047              		.loc 1 1292 0
 1048 0004 1E4E     		ldr	r6, .L137
1288:FreeRTOS/Source/tasks.c **** 		{
 1049              		.loc 1 1288 0
 1050 0006 FFF7FEFF 		bl	vPortEnterCritical
 1051              	.LVL109:
1292:FreeRTOS/Source/tasks.c **** 
 1052              		.loc 1 1292 0
 1053 000a 6CB3     		cbz	r4, .L132
 1054              	.LVL110:
 1055              	.L116:
1298:FreeRTOS/Source/tasks.c **** 			{
 1056              		.loc 1 1298 0 discriminator 4
 1057 000c 251D     		adds	r5, r4, #4
 1058 000e 2846     		mov	r0, r5
 1059 0010 FFF7FEFF 		bl	uxListRemove
 1060              	.LVL111:
1308:FreeRTOS/Source/tasks.c **** 			{
 1061              		.loc 1 1308 0 discriminator 4
 1062 0014 A36A     		ldr	r3, [r4, #40]
 1063 0016 1BB1     		cbz	r3, .L117
1310:FreeRTOS/Source/tasks.c **** 			}
 1064              		.loc 1 1310 0
 1065 0018 04F11800 		add	r0, r4, #24
 1066 001c FFF7FEFF 		bl	uxListRemove
 1067              	.LVL112:
 1068              	.L117:
1317:FreeRTOS/Source/tasks.c **** 		}
 1069              		.loc 1 1317 0
 1070 0020 184F     		ldr	r7, .L137+4
 1071 0022 2946     		mov	r1, r5
 1072 0024 3846     		mov	r0, r7
 1073 0026 FFF7FEFF 		bl	vListInsertEnd
 1074              	.LVL113:
1319:FreeRTOS/Source/tasks.c **** 
 1075              		.loc 1 1319 0
 1076 002a FFF7FEFF 		bl	vPortExitCritical
 1077              	.LVL114:
1321:FreeRTOS/Source/tasks.c **** 		{
 1078              		.loc 1 1321 0
 1079 002e 3368     		ldr	r3, [r6]
 1080 0030 134A     		ldr	r2, .L137
 1081 0032 9C42     		cmp	r4, r3
1323:FreeRTOS/Source/tasks.c **** 			{
 1082              		.loc 1 1323 0
 1083 0034 144B     		ldr	r3, .L137+8
 1084 0036 1B68     		ldr	r3, [r3]
1321:FreeRTOS/Source/tasks.c **** 		{
 1085              		.loc 1 1321 0
 1086 0038 09D0     		beq	.L133
1350:FreeRTOS/Source/tasks.c **** 			{
 1087              		.loc 1 1350 0
 1088 003a 03B9     		cbnz	r3, .L134
 1089 003c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1090              	.LVL115:
 1091              	.L134:
1355:FreeRTOS/Source/tasks.c **** 				{
 1092              		.loc 1 1355 0
 1093 003e FFF7FEFF 		bl	vPortEnterCritical
 1094              	.LVL116:
1357:FreeRTOS/Source/tasks.c **** 				}
 1095              		.loc 1 1357 0
 1096 0042 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1097              	.LVL117:
1366:FreeRTOS/Source/tasks.c **** 
 1098              		.loc 1 1366 0
 1099 0046 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1100              	.LCFI13:
 1101              		.cfi_remember_state
 1102              		.cfi_restore 14
 1103              		.cfi_restore 7
 1104              		.cfi_restore 6
 1105              		.cfi_restore 5
 1106              		.cfi_restore 4
 1107              		.cfi_restore 3
 1108              		.cfi_def_cfa_offset 0
 1109              	.LVL118:
1359:FreeRTOS/Source/tasks.c **** 			}
 1110              		.loc 1 1359 0
 1111 004a FFF7FEBF 		b	vPortExitCritical
 1112              	.LVL119:
 1113              	.L133:
 1114              	.LCFI14:
 1115              		.cfi_restore_state
1323:FreeRTOS/Source/tasks.c **** 			{
 1116              		.loc 1 1323 0
 1117 004e 6BB9     		cbnz	r3, .L135
1334:FreeRTOS/Source/tasks.c **** 				{
 1118              		.loc 1 1334 0
 1119 0050 0E49     		ldr	r1, .L137+12
 1120 0052 3868     		ldr	r0, [r7]
 1121 0054 0968     		ldr	r1, [r1]
 1122 0056 8842     		cmp	r0, r1
 1123 0058 10D0     		beq	.L136
 1124              	.LBB60:
 1125              	.LBB61:
2205:FreeRTOS/Source/tasks.c **** 	{
 1126              		.loc 1 2205 0
 1127 005a 0D4B     		ldr	r3, .L137+16
 1128 005c 1B68     		ldr	r3, [r3]
 1129 005e 4BB1     		cbz	r3, .L122
2209:FreeRTOS/Source/tasks.c **** 	}
 1130              		.loc 1 2209 0
 1131 0060 0C4B     		ldr	r3, .L137+20
 1132 0062 0122     		movs	r2, #1
 1133 0064 1A60     		str	r2, [r3]
 1134 0066 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1135              	.LVL120:
 1136              	.L132:
 1137              	.LBE61:
 1138              	.LBE60:
1292:FreeRTOS/Source/tasks.c **** 
 1139              		.loc 1 1292 0 discriminator 1
 1140 0068 3468     		ldr	r4, [r6]
 1141              	.LVL121:
 1142 006a CFE7     		b	.L116
 1143              	.LVL122:
 1144              	.L135:
1366:FreeRTOS/Source/tasks.c **** 
 1145              		.loc 1 1366 0
 1146 006c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1147              	.LCFI15:
 1148              		.cfi_remember_state
 1149              		.cfi_restore 14
 1150              		.cfi_restore 7
 1151              		.cfi_restore 6
 1152              		.cfi_restore 5
 1153              		.cfi_restore 4
 1154              		.cfi_restore 3
 1155              		.cfi_def_cfa_offset 0
 1156              	.LVL123:
1327:FreeRTOS/Source/tasks.c **** 			}
 1157              		.loc 1 1327 0
 1158 0070 FFF7FEBF 		b	vPortYieldFromISR
 1159              	.LVL124:
 1160              	.L122:
 1161              	.LCFI16:
 1162              		.cfi_restore_state
1366:FreeRTOS/Source/tasks.c **** 
 1163              		.loc 1 1366 0
 1164 0074 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1165              	.LCFI17:
 1166              		.cfi_remember_state
 1167              		.cfi_restore 14
 1168              		.cfi_restore 7
 1169              		.cfi_restore 6
 1170              		.cfi_restore 5
 1171              		.cfi_restore 4
 1172              		.cfi_restore 3
 1173              		.cfi_def_cfa_offset 0
 1174              	.LVL125:
 1175              	.LBB63:
 1176              	.LBB62:
 1177 0078 FFF7FEBF 		b	vTaskSwitchContext.part.4
 1178              	.LVL126:
 1179              	.L136:
 1180              	.LCFI18:
 1181              		.cfi_restore_state
 1182              	.LBE62:
 1183              	.LBE63:
1340:FreeRTOS/Source/tasks.c **** 				}
 1184              		.loc 1 1340 0
 1185 007c 1360     		str	r3, [r2]
 1186 007e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1187              	.LVL127:
 1188              	.L138:
 1189              		.align	2
 1190              	.L137:
 1191 0080 00000000 		.word	.LANCHOR2
 1192 0084 00000000 		.word	.LANCHOR15
 1193 0088 00000000 		.word	.LANCHOR16
 1194 008c 00000000 		.word	.LANCHOR10
 1195 0090 00000000 		.word	.LANCHOR19
 1196 0094 00000000 		.word	.LANCHOR5
 1197              		.cfi_endproc
 1198              	.LFE117:
 1200              		.section	.text.vTaskResume,"ax",%progbits
 1201              		.align	2
 1202              		.global	vTaskResume
 1203              		.thumb
 1204              		.thumb_func
 1206              	vTaskResume:
 1207              	.LFB119:
1420:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1208              		.loc 1 1420 0
 1209              		.cfi_startproc
 1210              		@ args = 0, pretend = 0, frame = 0
 1211              		@ frame_needed = 0, uses_anonymous_args = 0
 1212              	.LVL128:
1428:FreeRTOS/Source/tasks.c **** 		{
 1213              		.loc 1 1428 0
 1214 0000 0028     		cmp	r0, #0
 1215 0002 30D0     		beq	.L150
1420:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1216              		.loc 1 1420 0 discriminator 1
 1217 0004 70B5     		push	{r4, r5, r6, lr}
 1218              	.LCFI19:
 1219              		.cfi_def_cfa_offset 16
 1220              		.cfi_offset 4, -16
 1221              		.cfi_offset 5, -12
 1222              		.cfi_offset 6, -8
 1223              		.cfi_offset 14, -4
1428:FreeRTOS/Source/tasks.c **** 		{
 1224              		.loc 1 1428 0 discriminator 1
 1225 0006 184D     		ldr	r5, .L153
 1226 0008 2B68     		ldr	r3, [r5]
 1227 000a 9842     		cmp	r0, r3
 1228 000c 0AD0     		beq	.L139
 1229 000e 0446     		mov	r4, r0
1430:FreeRTOS/Source/tasks.c **** 			{
 1230              		.loc 1 1430 0
 1231 0010 FFF7FEFF 		bl	vPortEnterCritical
 1232              	.LVL129:
 1233              	.LBB68:
 1234              	.LBB69:
1385:FreeRTOS/Source/tasks.c **** 		{
 1235              		.loc 1 1385 0
 1236 0014 154B     		ldr	r3, .L153+4
 1237 0016 6269     		ldr	r2, [r4, #20]
 1238 0018 9A42     		cmp	r2, r3
 1239 001a 04D0     		beq	.L152
 1240              	.LVL130:
 1241              	.L142:
 1242              	.LBE69:
 1243              	.LBE68:
1465:FreeRTOS/Source/tasks.c **** 
 1244              		.loc 1 1465 0
 1245 001c BDE87040 		pop	{r4, r5, r6, lr}
 1246              	.LCFI20:
 1247              		.cfi_remember_state
 1248              		.cfi_restore 14
 1249              		.cfi_restore 6
 1250              		.cfi_restore 5
 1251              		.cfi_restore 4
 1252              		.cfi_def_cfa_offset 0
 1253              	.LVL131:
1459:FreeRTOS/Source/tasks.c **** 		}
 1254              		.loc 1 1459 0
 1255 0020 FFF7FEBF 		b	vPortExitCritical
 1256              	.LVL132:
 1257              	.L139:
 1258              	.LCFI21:
 1259              		.cfi_restore_state
 1260 0024 70BD     		pop	{r4, r5, r6, pc}
 1261              	.LVL133:
 1262              	.L152:
 1263              	.LBB73:
 1264              	.LBB72:
 1265              	.LBB70:
 1266              	.LBB71:
1388:FreeRTOS/Source/tasks.c **** 			{
 1267              		.loc 1 1388 0
 1268 0026 A36A     		ldr	r3, [r4, #40]
 1269 0028 114A     		ldr	r2, .L153+8
 1270 002a 9342     		cmp	r3, r2
 1271 002c F6D0     		beq	.L142
 1272              	.LVL134:
 1273              	.LBE71:
 1274              	.LBE70:
 1275              	.LBE72:
 1276              	.LBE73:
1432:FreeRTOS/Source/tasks.c **** 				{
 1277              		.loc 1 1432 0
 1278 002e 002B     		cmp	r3, #0
 1279 0030 F4D1     		bne	.L142
 1280              	.LVL135:
1438:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1281              		.loc 1 1438 0
 1282 0032 261D     		adds	r6, r4, #4
 1283 0034 3046     		mov	r0, r6
 1284 0036 FFF7FEFF 		bl	uxListRemove
 1285              	.LVL136:
1439:FreeRTOS/Source/tasks.c **** 
 1286              		.loc 1 1439 0
 1287 003a 0E4A     		ldr	r2, .L153+12
 1288 003c E36A     		ldr	r3, [r4, #44]
 1289 003e 1168     		ldr	r1, [r2]
 1290 0040 0D48     		ldr	r0, .L153+16
 1291 0042 8B42     		cmp	r3, r1
 1292 0044 88BF     		it	hi
 1293 0046 1360     		strhi	r3, [r2]
 1294 0048 03EB8303 		add	r3, r3, r3, lsl #2
 1295 004c 00EB8300 		add	r0, r0, r3, lsl #2
 1296 0050 3146     		mov	r1, r6
 1297 0052 FFF7FEFF 		bl	vListInsertEnd
 1298              	.LVL137:
1442:FreeRTOS/Source/tasks.c **** 					{
 1299              		.loc 1 1442 0
 1300 0056 2B68     		ldr	r3, [r5]
 1301 0058 E26A     		ldr	r2, [r4, #44]
 1302 005a DB6A     		ldr	r3, [r3, #44]
 1303 005c 9A42     		cmp	r2, r3
 1304 005e DDD3     		bcc	.L142
1447:FreeRTOS/Source/tasks.c **** 					}
 1305              		.loc 1 1447 0
 1306 0060 FFF7FEFF 		bl	vPortYieldFromISR
 1307              	.LVL138:
 1308 0064 DAE7     		b	.L142
 1309              	.LVL139:
 1310              	.L150:
 1311              	.LCFI22:
 1312              		.cfi_def_cfa_offset 0
 1313              		.cfi_restore 4
 1314              		.cfi_restore 5
 1315              		.cfi_restore 6
 1316              		.cfi_restore 14
 1317 0066 7047     		bx	lr
 1318              	.L154:
 1319              		.align	2
 1320              	.L153:
 1321 0068 00000000 		.word	.LANCHOR2
 1322 006c 00000000 		.word	.LANCHOR15
 1323 0070 00000000 		.word	.LANCHOR13
 1324 0074 00000000 		.word	.LANCHOR8
 1325 0078 00000000 		.word	.LANCHOR9
 1326              		.cfi_endproc
 1327              	.LFE119:
 1329              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1330              		.align	2
 1331              		.global	xTaskResumeFromISR
 1332              		.thumb
 1333              		.thumb_func
 1335              	xTaskResumeFromISR:
 1336              	.LFB120:
1474:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1337              		.loc 1 1474 0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 0
 1340              		@ frame_needed = 0, uses_anonymous_args = 0
 1341              	.LVL140:
 1342 0000 70B5     		push	{r4, r5, r6, lr}
 1343              	.LCFI23:
 1344              		.cfi_def_cfa_offset 16
 1345              		.cfi_offset 4, -16
 1346              		.cfi_offset 5, -12
 1347              		.cfi_offset 6, -8
 1348              		.cfi_offset 14, -4
1474:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1349              		.loc 1 1474 0
 1350 0002 0146     		mov	r1, r0
 1351              	.LVL141:
1499:FreeRTOS/Source/tasks.c **** 		{
 1352              		.loc 1 1499 0
 1353              	@ 1499 "FreeRTOS/Source/tasks.c" 1
 1354 0004 4FF0BF00 			mov r0, #191								
 1355 0008 80F31188 		msr basepri, r0							
 1356              	
 1357              	@ 0 "" 2
 1358              	.LVL142:
 1359              		.thumb
 1360              	.LBB78:
 1361              	.LBB79:
1385:FreeRTOS/Source/tasks.c **** 		{
 1362              		.loc 1 1385 0
 1363 000c 194B     		ldr	r3, .L166
 1364 000e 4A69     		ldr	r2, [r1, #20]
 1365 0010 9A42     		cmp	r2, r3
 1366 0012 06D0     		beq	.L165
 1367              	.LVL143:
 1368              	.L164:
 1369              	.LBE79:
 1370              	.LBE78:
1475:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1371              		.loc 1 1475 0
 1372 0014 0025     		movs	r5, #0
 1373              	.LVL144:
 1374              	.L157:
1535:FreeRTOS/Source/tasks.c **** 
 1375              		.loc 1 1535 0
 1376              	@ 1535 "FreeRTOS/Source/tasks.c" 1
 1377 0016 4FF00000 			mov r0, #0					
 1378 001a 80F31188 		msr basepri, r0				
 1379              	
 1380              	@ 0 "" 2
1538:FreeRTOS/Source/tasks.c **** 
 1381              		.loc 1 1538 0
 1382              		.thumb
 1383 001e 2846     		mov	r0, r5
 1384 0020 70BD     		pop	{r4, r5, r6, pc}
 1385              	.LVL145:
 1386              	.L165:
 1387              	.LBB83:
 1388              	.LBB82:
 1389              	.LBB80:
 1390              	.LBB81:
1388:FreeRTOS/Source/tasks.c **** 			{
 1391              		.loc 1 1388 0
 1392 0022 8D6A     		ldr	r5, [r1, #40]
 1393 0024 1448     		ldr	r0, .L166+4
 1394 0026 8542     		cmp	r5, r0
 1395 0028 F4D0     		beq	.L164
 1396              	.LVL146:
 1397              	.LBE81:
 1398              	.LBE80:
 1399              	.LBE82:
 1400              	.LBE83:
1501:FreeRTOS/Source/tasks.c **** 			{
 1401              		.loc 1 1501 0
 1402 002a 002D     		cmp	r5, #0
 1403 002c F2D1     		bne	.L164
 1404              	.LVL147:
1506:FreeRTOS/Source/tasks.c **** 				{
 1405              		.loc 1 1506 0
 1406 002e 134B     		ldr	r3, .L166+8
 1407 0030 1B68     		ldr	r3, [r3]
 1408 0032 0C46     		mov	r4, r1
 1409 0034 D3B9     		cbnz	r3, .L158
1510:FreeRTOS/Source/tasks.c **** 					{
 1410              		.loc 1 1510 0
 1411 0036 124A     		ldr	r2, .L166+12
 1412 0038 CB6A     		ldr	r3, [r1, #44]
 1413 003a 1268     		ldr	r2, [r2]
 1414 003c D56A     		ldr	r5, [r2, #44]
1519:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1415              		.loc 1 1519 0
 1416 003e 0E1D     		adds	r6, r1, #4
1510:FreeRTOS/Source/tasks.c **** 					{
 1417              		.loc 1 1510 0
 1418 0040 AB42     		cmp	r3, r5
1519:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1419              		.loc 1 1519 0
 1420 0042 3046     		mov	r0, r6
1510:FreeRTOS/Source/tasks.c **** 					{
 1421              		.loc 1 1510 0
 1422 0044 34BF     		ite	cc
 1423 0046 0025     		movcc	r5, #0
 1424 0048 0125     		movcs	r5, #1
 1425              	.LVL148:
1519:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1426              		.loc 1 1519 0
 1427 004a FFF7FEFF 		bl	uxListRemove
 1428              	.LVL149:
1520:FreeRTOS/Source/tasks.c **** 				}
 1429              		.loc 1 1520 0
 1430 004e 0D4A     		ldr	r2, .L166+16
 1431 0050 E36A     		ldr	r3, [r4, #44]
 1432 0052 1168     		ldr	r1, [r2]
 1433 0054 0C48     		ldr	r0, .L166+20
 1434 0056 8B42     		cmp	r3, r1
 1435 0058 88BF     		it	hi
 1436 005a 1360     		strhi	r3, [r2]
 1437 005c 03EB8303 		add	r3, r3, r3, lsl #2
 1438 0060 3146     		mov	r1, r6
 1439 0062 00EB8300 		add	r0, r0, r3, lsl #2
 1440 0066 FFF7FEFF 		bl	vListInsertEnd
 1441              	.LVL150:
 1442 006a D4E7     		b	.L157
 1443              	.LVL151:
 1444              	.L158:
1527:FreeRTOS/Source/tasks.c **** 				}
 1445              		.loc 1 1527 0
 1446 006c 1831     		adds	r1, r1, #24
 1447              	.LVL152:
 1448 006e FFF7FEFF 		bl	vListInsertEnd
 1449              	.LVL153:
 1450 0072 D0E7     		b	.L157
 1451              	.L167:
 1452              		.align	2
 1453              	.L166:
 1454 0074 00000000 		.word	.LANCHOR15
 1455 0078 00000000 		.word	.LANCHOR13
 1456 007c 00000000 		.word	.LANCHOR19
 1457 0080 00000000 		.word	.LANCHOR2
 1458 0084 00000000 		.word	.LANCHOR8
 1459 0088 00000000 		.word	.LANCHOR9
 1460              		.cfi_endproc
 1461              	.LFE120:
 1463              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1464              		.align	2
 1465              		.global	vTaskStartScheduler
 1466              		.thumb
 1467              		.thumb_func
 1469              	vTaskStartScheduler:
 1470              	.LFB121:
1544:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 1471              		.loc 1 1544 0
 1472              		.cfi_startproc
 1473              		@ args = 0, pretend = 0, frame = 0
 1474              		@ frame_needed = 0, uses_anonymous_args = 0
 1475 0000 30B5     		push	{r4, r5, lr}
 1476              	.LCFI24:
 1477              		.cfi_def_cfa_offset 12
 1478              		.cfi_offset 4, -12
 1479              		.cfi_offset 5, -8
 1480              		.cfi_offset 14, -4
 1481 0002 85B0     		sub	sp, sp, #20
 1482              	.LCFI25:
 1483              		.cfi_def_cfa_offset 32
1552:FreeRTOS/Source/tasks.c **** 	}
 1484              		.loc 1 1552 0
 1485 0004 0024     		movs	r4, #0
 1486 0006 124A     		ldr	r2, .L172
 1487 0008 0192     		str	r2, [sp, #4]
 1488 000a 2346     		mov	r3, r4
 1489 000c 0094     		str	r4, [sp]
 1490 000e 0294     		str	r4, [sp, #8]
 1491 0010 0394     		str	r4, [sp, #12]
 1492 0012 1048     		ldr	r0, .L172+4
 1493 0014 1049     		ldr	r1, .L172+8
 1494 0016 4FF48072 		mov	r2, #256
 1495 001a FFF7FEFF 		bl	xTaskGenericCreate
 1496              	.LVL154:
1574:FreeRTOS/Source/tasks.c **** 	{
 1497              		.loc 1 1574 0
 1498 001e 0128     		cmp	r0, #1
1552:FreeRTOS/Source/tasks.c **** 	}
 1499              		.loc 1 1552 0
 1500 0020 0346     		mov	r3, r0
 1501              	.LVL155:
1574:FreeRTOS/Source/tasks.c **** 	{
 1502              		.loc 1 1574 0
 1503 0022 01D0     		beq	.L171
1619:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1504              		.loc 1 1619 0
 1505 0024 05B0     		add	sp, sp, #20
 1506              	.LCFI26:
 1507              		.cfi_remember_state
 1508              		.cfi_def_cfa_offset 12
 1509              		@ sp needed
 1510 0026 30BD     		pop	{r4, r5, pc}
 1511              	.L171:
 1512              	.LCFI27:
 1513              		.cfi_restore_state
1581:FreeRTOS/Source/tasks.c **** 
 1514              		.loc 1 1581 0
 1515              	@ 1581 "FreeRTOS/Source/tasks.c" 1
 1516 0028 4FF0BF00 			mov r0, #191								
 1517 002c 80F31188 		msr basepri, r0							
 1518              	
 1519              	@ 0 "" 2
 1520              	.LVL156:
1591:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1521              		.loc 1 1591 0
 1522              		.thumb
 1523 0030 0A48     		ldr	r0, .L172+12
1592:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1524              		.loc 1 1592 0
 1525 0032 0B49     		ldr	r1, .L172+16
1593:FreeRTOS/Source/tasks.c **** 
 1526              		.loc 1 1593 0
 1527 0034 0B4A     		ldr	r2, .L172+20
1591:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1528              		.loc 1 1591 0
 1529 0036 4FF0FF35 		mov	r5, #-1
 1530 003a 0560     		str	r5, [r0]
1592:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1531              		.loc 1 1592 0
 1532 003c 0B60     		str	r3, [r1]
1593:FreeRTOS/Source/tasks.c **** 
 1533              		.loc 1 1593 0
 1534 003e 1460     		str	r4, [r2]
1598:FreeRTOS/Source/tasks.c **** 
 1535              		.loc 1 1598 0
 1536 0040 FFF7FEFF 		bl	init_us_timer
 1537              	.LVL157:
1619:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1538              		.loc 1 1619 0
 1539 0044 05B0     		add	sp, sp, #20
 1540              	.LCFI28:
 1541              		.cfi_def_cfa_offset 12
 1542              		@ sp needed
 1543 0046 BDE83040 		pop	{r4, r5, lr}
 1544              	.LCFI29:
 1545              		.cfi_restore 14
 1546              		.cfi_restore 5
 1547              		.cfi_restore 4
 1548              		.cfi_def_cfa_offset 0
1602:FreeRTOS/Source/tasks.c **** 		{
 1549              		.loc 1 1602 0
 1550 004a FFF7FEBF 		b	xPortStartScheduler
 1551              	.LVL158:
 1552              	.L173:
 1553 004e 00BF     		.align	2
 1554              	.L172:
 1555 0050 00000000 		.word	.LANCHOR20
 1556 0054 00000000 		.word	prvIdleTask
 1557 0058 00000000 		.word	.LC0
 1558 005c 00000000 		.word	.LANCHOR1
 1559 0060 00000000 		.word	.LANCHOR16
 1560 0064 00000000 		.word	.LANCHOR3
 1561              		.cfi_endproc
 1562              	.LFE121:
 1564              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1565              		.align	2
 1566              		.global	vTaskEndScheduler
 1567              		.thumb
 1568              		.thumb_func
 1570              	vTaskEndScheduler:
 1571              	.LFB122:
1623:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1572              		.loc 1 1623 0
 1573              		.cfi_startproc
 1574              		@ args = 0, pretend = 0, frame = 0
 1575              		@ frame_needed = 0, uses_anonymous_args = 0
 1576              		@ link register save eliminated.
1627:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1577              		.loc 1 1627 0
 1578              	@ 1627 "FreeRTOS/Source/tasks.c" 1
 1579 0000 4FF0BF00 			mov r0, #191								
 1580 0004 80F31188 		msr basepri, r0							
 1581              	
 1582              	@ 0 "" 2
1628:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1583              		.loc 1 1628 0
 1584              		.thumb
 1585 0008 024B     		ldr	r3, .L175
 1586 000a 0022     		movs	r2, #0
 1587 000c 1A60     		str	r2, [r3]
1629:FreeRTOS/Source/tasks.c **** }
 1588              		.loc 1 1629 0
 1589 000e FFF7FEBF 		b	vPortEndScheduler
 1590              	.LVL159:
 1591              	.L176:
 1592 0012 00BF     		.align	2
 1593              	.L175:
 1594 0014 00000000 		.word	.LANCHOR16
 1595              		.cfi_endproc
 1596              	.LFE122:
 1598              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1599              		.align	2
 1600              		.global	vTaskSuspendAll
 1601              		.thumb
 1602              		.thumb_func
 1604              	vTaskSuspendAll:
 1605              	.LFB123:
1634:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1606              		.loc 1 1634 0
 1607              		.cfi_startproc
 1608              		@ args = 0, pretend = 0, frame = 0
 1609              		@ frame_needed = 0, uses_anonymous_args = 0
 1610              		@ link register save eliminated.
1639:FreeRTOS/Source/tasks.c **** }
 1611              		.loc 1 1639 0
 1612 0000 024A     		ldr	r2, .L178
 1613 0002 1368     		ldr	r3, [r2]
 1614 0004 0133     		adds	r3, r3, #1
 1615 0006 1360     		str	r3, [r2]
 1616 0008 7047     		bx	lr
 1617              	.L179:
 1618 000a 00BF     		.align	2
 1619              	.L178:
 1620 000c 00000000 		.word	.LANCHOR19
 1621              		.cfi_endproc
 1622              	.LFE123:
 1624              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1625              		.align	2
 1626              		.global	xTaskGetTickCount
 1627              		.thumb
 1628              		.thumb_func
 1630              	xTaskGetTickCount:
 1631              	.LFB125:
1765:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
 1632              		.loc 1 1765 0
 1633              		.cfi_startproc
 1634              		@ args = 0, pretend = 0, frame = 0
 1635              		@ frame_needed = 0, uses_anonymous_args = 0
 1636              		@ link register save eliminated.
1771:FreeRTOS/Source/tasks.c **** 	}
 1637              		.loc 1 1771 0
 1638 0000 014B     		ldr	r3, .L181
 1639 0002 1868     		ldr	r0, [r3]
 1640              	.LVL160:
1776:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1641              		.loc 1 1776 0
 1642 0004 7047     		bx	lr
 1643              	.L182:
 1644 0006 00BF     		.align	2
 1645              	.L181:
 1646 0008 00000000 		.word	.LANCHOR3
 1647              		.cfi_endproc
 1648              	.LFE125:
 1650              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1651              		.align	2
 1652              		.global	xTaskGetTickCountFromISR
 1653              		.thumb
 1654              		.thumb_func
 1656              	xTaskGetTickCountFromISR:
 1657              	.LFB126:
1780:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
 1658              		.loc 1 1780 0
 1659              		.cfi_startproc
 1660              		@ args = 0, pretend = 0, frame = 0
 1661              		@ frame_needed = 0, uses_anonymous_args = 0
 1662              		@ link register save eliminated.
 1663              	.LVL161:
1802:FreeRTOS/Source/tasks.c **** 	}
 1664              		.loc 1 1802 0
 1665 0000 014B     		ldr	r3, .L184
 1666 0002 1868     		ldr	r0, [r3]
 1667              	.LVL162:
1807:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1668              		.loc 1 1807 0
 1669 0004 7047     		bx	lr
 1670              	.L185:
 1671 0006 00BF     		.align	2
 1672              	.L184:
 1673 0008 00000000 		.word	.LANCHOR3
 1674              		.cfi_endproc
 1675              	.LFE126:
 1677              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1678              		.align	2
 1679              		.global	uxTaskGetNumberOfTasks
 1680              		.thumb
 1681              		.thumb_func
 1683              	uxTaskGetNumberOfTasks:
 1684              	.LFB127:
1811:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1685              		.loc 1 1811 0
 1686              		.cfi_startproc
 1687              		@ args = 0, pretend = 0, frame = 0
 1688              		@ frame_needed = 0, uses_anonymous_args = 0
 1689              		@ link register save eliminated.
1814:FreeRTOS/Source/tasks.c **** }
 1690              		.loc 1 1814 0
 1691 0000 014B     		ldr	r3, .L187
 1692 0002 1868     		ldr	r0, [r3]
1815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1693              		.loc 1 1815 0
 1694 0004 7047     		bx	lr
 1695              	.L188:
 1696 0006 00BF     		.align	2
 1697              	.L187:
 1698 0008 00000000 		.word	.LANCHOR10
 1699              		.cfi_endproc
 1700              	.LFE127:
 1702              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1703              		.align	2
 1704              		.global	xTaskGetIdleTaskHandle
 1705              		.thumb
 1706              		.thumb_func
 1708              	xTaskGetIdleTaskHandle:
 1709              	.LFB128:
1910:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
 1710              		.loc 1 1910 0
 1711              		.cfi_startproc
 1712              		@ args = 0, pretend = 0, frame = 0
 1713              		@ frame_needed = 0, uses_anonymous_args = 0
 1714              		@ link register save eliminated.
1914:FreeRTOS/Source/tasks.c **** 	}
 1715              		.loc 1 1914 0
 1716 0000 014B     		ldr	r3, .L190
1915:FreeRTOS/Source/tasks.c **** 
 1717              		.loc 1 1915 0
 1718 0002 1868     		ldr	r0, [r3]
 1719 0004 7047     		bx	lr
 1720              	.L191:
 1721 0006 00BF     		.align	2
 1722              	.L190:
 1723 0008 00000000 		.word	.LANCHOR20
 1724              		.cfi_endproc
 1725              	.LFE128:
 1727              		.section	.text.xTaskIncrementTick,"ax",%progbits
 1728              		.align	2
 1729              		.global	xTaskIncrementTick
 1730              		.thumb
 1731              		.thumb_func
 1733              	xTaskIncrementTick:
 1734              	.LFB129:
1940:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
 1735              		.loc 1 1940 0
 1736              		.cfi_startproc
 1737              		@ args = 0, pretend = 0, frame = 0
 1738              		@ frame_needed = 0, uses_anonymous_args = 0
 1739              	.LVL163:
 1740 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1741              	.LCFI30:
 1742              		.cfi_def_cfa_offset 40
 1743              		.cfi_offset 3, -40
 1744              		.cfi_offset 4, -36
 1745              		.cfi_offset 5, -32
 1746              		.cfi_offset 6, -28
 1747              		.cfi_offset 7, -24
 1748              		.cfi_offset 8, -20
 1749              		.cfi_offset 9, -16
 1750              		.cfi_offset 10, -12
 1751              		.cfi_offset 11, -8
 1752              		.cfi_offset 14, -4
1949:FreeRTOS/Source/tasks.c **** 	{
 1753              		.loc 1 1949 0
 1754 0004 3D4B     		ldr	r3, .L222
 1755 0006 1B68     		ldr	r3, [r3]
 1756 0008 002B     		cmp	r3, #0
 1757 000a 45D1     		bne	.L193
1953:FreeRTOS/Source/tasks.c **** 
 1758              		.loc 1 1953 0
 1759 000c 3C4B     		ldr	r3, .L222+4
 1760 000e 1A68     		ldr	r2, [r3]
 1761 0010 0132     		adds	r2, r2, #1
 1762 0012 1A60     		str	r2, [r3]
 1763              	.LBB84:
1958:FreeRTOS/Source/tasks.c **** 
 1764              		.loc 1 1958 0
 1765 0014 1E68     		ldr	r6, [r3]
 1766              	.LVL164:
1960:FreeRTOS/Source/tasks.c **** 			{
 1767              		.loc 1 1960 0
 1768 0016 002E     		cmp	r6, #0
 1769 0018 5BD0     		beq	.L219
1973:FreeRTOS/Source/tasks.c **** 			{
 1770              		.loc 1 1973 0
 1771 001a 3A4B     		ldr	r3, .L222+8
 1772 001c 1B68     		ldr	r3, [r3]
 1773 001e 9E42     		cmp	r6, r3
 1774 0020 47D3     		bcc	.L220
 1775              	.L206:
 1776 0022 394F     		ldr	r7, .L222+12
 1777 0024 DFF8F890 		ldr	r9, .L222+36
 1778 0028 DFF8F880 		ldr	r8, .L222+40
2027:FreeRTOS/Source/tasks.c **** 
 1779              		.loc 1 2027 0
 1780 002c 374D     		ldr	r5, .L222+16
 1781 002e 0024     		movs	r4, #0
 1782 0030 29E0     		b	.L195
 1783              	.LVL165:
 1784              	.L213:
1993:FreeRTOS/Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1785              		.loc 1 1993 0
 1786 0032 354B     		ldr	r3, .L222+12
 1787 0034 1B68     		ldr	r3, [r3]
 1788 0036 DB68     		ldr	r3, [r3, #12]
 1789 0038 D3F80CA0 		ldr	r10, [r3, #12]
 1790              	.LVL166:
1994:FreeRTOS/Source/tasks.c **** 
 1791              		.loc 1 1994 0
 1792 003c DAF80420 		ldr	r2, [r10, #4]
 1793              	.LVL167:
2012:FreeRTOS/Source/tasks.c **** 
 1794              		.loc 1 2012 0
 1795 0040 0AF1040B 		add	fp, r10, #4
1996:FreeRTOS/Source/tasks.c **** 						{
 1796              		.loc 1 1996 0
 1797 0044 9642     		cmp	r6, r2
2012:FreeRTOS/Source/tasks.c **** 
 1798              		.loc 1 2012 0
 1799 0046 5846     		mov	r0, fp
1996:FreeRTOS/Source/tasks.c **** 						{
 1800              		.loc 1 1996 0
 1801 0048 54D3     		bcc	.L221
2012:FreeRTOS/Source/tasks.c **** 
 1802              		.loc 1 2012 0
 1803 004a FFF7FEFF 		bl	uxListRemove
 1804              	.LVL168:
2016:FreeRTOS/Source/tasks.c **** 						{
 1805              		.loc 1 2016 0
 1806 004e DAF82820 		ldr	r2, [r10, #40]
2018:FreeRTOS/Source/tasks.c **** 						}
 1807              		.loc 1 2018 0
 1808 0052 0AF11800 		add	r0, r10, #24
2016:FreeRTOS/Source/tasks.c **** 						{
 1809              		.loc 1 2016 0
 1810 0056 0AB1     		cbz	r2, .L199
2018:FreeRTOS/Source/tasks.c **** 						}
 1811              		.loc 1 2018 0
 1812 0058 FFF7FEFF 		bl	uxListRemove
 1813              	.LVL169:
 1814              	.L199:
2027:FreeRTOS/Source/tasks.c **** 
 1815              		.loc 1 2027 0
 1816 005c DAF82C20 		ldr	r2, [r10, #44]
 1817 0060 2B68     		ldr	r3, [r5]
 1818 0062 02EB8200 		add	r0, r2, r2, lsl #2
 1819 0066 9A42     		cmp	r2, r3
 1820 0068 5946     		mov	r1, fp
 1821 006a 09EB8000 		add	r0, r9, r0, lsl #2
 1822 006e 88BF     		it	hi
 1823 0070 2A60     		strhi	r2, [r5]
 1824 0072 FFF7FEFF 		bl	vListInsertEnd
 1825              	.LVL170:
2037:FreeRTOS/Source/tasks.c **** 							{
 1826              		.loc 1 2037 0
 1827 0076 D8F80010 		ldr	r1, [r8]
 1828 007a DAF82C20 		ldr	r2, [r10, #44]
 1829 007e CB6A     		ldr	r3, [r1, #44]
2039:FreeRTOS/Source/tasks.c **** 							}
 1830              		.loc 1 2039 0
 1831 0080 9A42     		cmp	r2, r3
 1832 0082 28BF     		it	cs
 1833 0084 0124     		movcs	r4, #1
 1834              	.LVL171:
 1835              	.L195:
1977:FreeRTOS/Source/tasks.c **** 					{
 1836              		.loc 1 1977 0
 1837 0086 3B68     		ldr	r3, [r7]
 1838 0088 1B68     		ldr	r3, [r3]
 1839 008a 002B     		cmp	r3, #0
 1840 008c D1D1     		bne	.L213
1984:FreeRTOS/Source/tasks.c **** 						break;
 1841              		.loc 1 1984 0
 1842 008e 1D4A     		ldr	r2, .L222+8
 1843 0090 4FF0FF33 		mov	r3, #-1
 1844 0094 1360     		str	r3, [r2]
1985:FreeRTOS/Source/tasks.c **** 					}
 1845              		.loc 1 1985 0
 1846 0096 11E0     		b	.L196
 1847              	.LVL172:
 1848              	.L193:
 1849              	.LBE84:
2085:FreeRTOS/Source/tasks.c **** 
 1850              		.loc 1 2085 0
 1851 0098 1D4A     		ldr	r2, .L222+20
 1852 009a 1368     		ldr	r3, [r2]
 1853 009c 0133     		adds	r3, r3, #1
 1854 009e 1360     		str	r3, [r2]
1943:FreeRTOS/Source/tasks.c **** 
 1855              		.loc 1 1943 0
 1856 00a0 0024     		movs	r4, #0
 1857              	.LVL173:
 1858              	.L202:
2098:FreeRTOS/Source/tasks.c **** 		{
 1859              		.loc 1 2098 0
 1860 00a2 1C4B     		ldr	r3, .L222+24
 1861 00a4 1B68     		ldr	r3, [r3]
2100:FreeRTOS/Source/tasks.c **** 		}
 1862              		.loc 1 2100 0
 1863 00a6 002B     		cmp	r3, #0
 1864 00a8 18BF     		it	ne
 1865 00aa 0124     		movne	r4, #1
 1866              	.LVL174:
2110:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1867              		.loc 1 2110 0
 1868 00ac 2046     		mov	r0, r4
 1869 00ae BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1870              	.LVL175:
 1871              	.L220:
 1872 00b2 DFF86C90 		ldr	r9, .L222+36
 1873 00b6 DFF86C80 		ldr	r8, .L222+40
1943:FreeRTOS/Source/tasks.c **** 
 1874              		.loc 1 1943 0
 1875 00ba 0024     		movs	r4, #0
 1876              	.LVL176:
 1877              	.L196:
2057:FreeRTOS/Source/tasks.c **** 			{
 1878              		.loc 1 2057 0
 1879 00bc D8F80030 		ldr	r3, [r8]
 1880 00c0 DB6A     		ldr	r3, [r3, #44]
 1881 00c2 03EB8303 		add	r3, r3, r3, lsl #2
 1882 00c6 59F82330 		ldr	r3, [r9, r3, lsl #2]
2059:FreeRTOS/Source/tasks.c **** 			}
 1883              		.loc 1 2059 0
 1884 00ca 022B     		cmp	r3, #2
 1885 00cc 28BF     		it	cs
 1886 00ce 0124     		movcs	r4, #1
 1887              	.LVL177:
 1888 00d0 E7E7     		b	.L202
 1889              	.LVL178:
 1890              	.L219:
 1891              	.LBB86:
 1892              	.LBB85:
1962:FreeRTOS/Source/tasks.c **** 			}
 1893              		.loc 1 1962 0
 1894 00d2 114B     		ldr	r3, .L222+28
 1895 00d4 0C4F     		ldr	r7, .L222+12
 1896 00d6 114A     		ldr	r2, .L222+32
 1897 00d8 3968     		ldr	r1, [r7]
 1898              	.LVL179:
 1899 00da 1868     		ldr	r0, [r3]
 1900 00dc 3860     		str	r0, [r7]
 1901 00de 1960     		str	r1, [r3]
 1902 00e0 1368     		ldr	r3, [r2]
 1903 00e2 0133     		adds	r3, r3, #1
 1904 00e4 1360     		str	r3, [r2]
 1905 00e6 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1906              	.LVL180:
 1907              	.LBE85:
1973:FreeRTOS/Source/tasks.c **** 			{
 1908              		.loc 1 1973 0
 1909 00ea 064B     		ldr	r3, .L222+8
 1910 00ec 1B68     		ldr	r3, [r3]
 1911 00ee 9E42     		cmp	r6, r3
 1912 00f0 97D2     		bcs	.L206
 1913 00f2 DEE7     		b	.L220
 1914              	.LVL181:
 1915              	.L221:
2003:FreeRTOS/Source/tasks.c **** 							break;
 1916              		.loc 1 2003 0
 1917 00f4 034B     		ldr	r3, .L222+8
 1918 00f6 1A60     		str	r2, [r3]
2004:FreeRTOS/Source/tasks.c **** 						}
 1919              		.loc 1 2004 0
 1920 00f8 E0E7     		b	.L196
 1921              	.L223:
 1922 00fa 00BF     		.align	2
 1923              	.L222:
 1924 00fc 00000000 		.word	.LANCHOR19
 1925 0100 00000000 		.word	.LANCHOR3
 1926 0104 00000000 		.word	.LANCHOR1
 1927 0108 00000000 		.word	.LANCHOR0
 1928 010c 00000000 		.word	.LANCHOR8
 1929 0110 00000000 		.word	.LANCHOR22
 1930 0114 00000000 		.word	.LANCHOR5
 1931 0118 00000000 		.word	.LANCHOR4
 1932 011c 00000000 		.word	.LANCHOR21
 1933 0120 00000000 		.word	.LANCHOR9
 1934 0124 00000000 		.word	.LANCHOR2
 1935              	.LBE86:
 1936              		.cfi_endproc
 1937              	.LFE129:
 1939              		.section	.text.xTaskResumeAll,"ax",%progbits
 1940              		.align	2
 1941              		.global	xTaskResumeAll
 1942              		.thumb
 1943              		.thumb_func
 1945              	xTaskResumeAll:
 1946              	.LFB124:
1672:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
 1947              		.loc 1 1672 0
 1948              		.cfi_startproc
 1949              		@ args = 0, pretend = 0, frame = 0
 1950              		@ frame_needed = 0, uses_anonymous_args = 0
 1951              	.LVL182:
 1952 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1953              	.LCFI31:
 1954              		.cfi_def_cfa_offset 40
 1955              		.cfi_offset 3, -40
 1956              		.cfi_offset 4, -36
 1957              		.cfi_offset 5, -32
 1958              		.cfi_offset 6, -28
 1959              		.cfi_offset 7, -24
 1960              		.cfi_offset 8, -20
 1961              		.cfi_offset 9, -16
 1962              		.cfi_offset 10, -12
 1963              		.cfi_offset 11, -8
 1964              		.cfi_offset 14, -4
1685:FreeRTOS/Source/tasks.c **** 	{
 1965              		.loc 1 1685 0
 1966 0004 FFF7FEFF 		bl	vPortEnterCritical
 1967              	.LVL183:
1687:FreeRTOS/Source/tasks.c **** 
 1968              		.loc 1 1687 0
 1969 0008 2A4B     		ldr	r3, .L250
 1970 000a 1A68     		ldr	r2, [r3]
 1971 000c 013A     		subs	r2, r2, #1
 1972 000e 1A60     		str	r2, [r3]
1689:FreeRTOS/Source/tasks.c **** 		{
 1973              		.loc 1 1689 0
 1974 0010 1B68     		ldr	r3, [r3]
 1975 0012 002B     		cmp	r3, #0
 1976 0014 45D1     		bne	.L228
1691:FreeRTOS/Source/tasks.c **** 			{
 1977              		.loc 1 1691 0
 1978 0016 284B     		ldr	r3, .L250+4
 1979 0018 1B68     		ldr	r3, [r3]
 1980 001a 002B     		cmp	r3, #0
 1981 001c 41D0     		beq	.L228
 1982 001e 274E     		ldr	r6, .L250+8
 1983 0020 DFF8A4A0 		ldr	r10, .L250+20
1700:FreeRTOS/Source/tasks.c **** 
 1984              		.loc 1 1700 0
 1985 0024 264D     		ldr	r5, .L250+12
 1986 0026 DFF8A490 		ldr	r9, .L250+24
1704:FreeRTOS/Source/tasks.c **** 					{
 1987              		.loc 1 1704 0
 1988 002a DFF8A480 		ldr	r8, .L250+28
1695:FreeRTOS/Source/tasks.c **** 				{
 1989              		.loc 1 1695 0
 1990 002e 3746     		mov	r7, r6
 1991 0030 1FE0     		b	.L230
 1992              	.L231:
1697:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1993              		.loc 1 1697 0
 1994 0032 FB68     		ldr	r3, [r7, #12]
 1995 0034 DC68     		ldr	r4, [r3, #12]
 1996              	.LVL184:
1699:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1997              		.loc 1 1699 0
 1998 0036 04F1040B 		add	fp, r4, #4
1698:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1999              		.loc 1 1698 0
 2000 003a 04F11800 		add	r0, r4, #24
 2001 003e FFF7FEFF 		bl	uxListRemove
 2002              	.LVL185:
1699:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2003              		.loc 1 1699 0
 2004 0042 5846     		mov	r0, fp
 2005 0044 FFF7FEFF 		bl	uxListRemove
 2006              	.LVL186:
1700:FreeRTOS/Source/tasks.c **** 
 2007              		.loc 1 1700 0
 2008 0048 E36A     		ldr	r3, [r4, #44]
 2009 004a 2A68     		ldr	r2, [r5]
 2010 004c 03EB8300 		add	r0, r3, r3, lsl #2
 2011 0050 9342     		cmp	r3, r2
 2012 0052 5946     		mov	r1, fp
 2013 0054 09EB8000 		add	r0, r9, r0, lsl #2
 2014 0058 88BF     		it	hi
 2015 005a 2B60     		strhi	r3, [r5]
 2016 005c FFF7FEFF 		bl	vListInsertEnd
 2017              	.LVL187:
1704:FreeRTOS/Source/tasks.c **** 					{
 2018              		.loc 1 1704 0
 2019 0060 D8F80030 		ldr	r3, [r8]
 2020 0064 E26A     		ldr	r2, [r4, #44]
 2021 0066 DB6A     		ldr	r3, [r3, #44]
 2022 0068 9A42     		cmp	r2, r3
1706:FreeRTOS/Source/tasks.c **** 					}
 2023              		.loc 1 1706 0
 2024 006a 24BF     		itt	cs
 2025 006c 0123     		movcs	r3, #1
 2026 006e CAF80030 		strcs	r3, [r10]
 2027              	.LVL188:
 2028              	.L230:
1695:FreeRTOS/Source/tasks.c **** 				{
 2029              		.loc 1 1695 0
 2030 0072 3368     		ldr	r3, [r6]
 2031 0074 002B     		cmp	r3, #0
 2032 0076 DCD1     		bne	.L231
1718:FreeRTOS/Source/tasks.c **** 				{
 2033              		.loc 1 1718 0
 2034 0078 124C     		ldr	r4, .L250+16
 2035 007a 2368     		ldr	r3, [r4]
 2036 007c 6BB1     		cbz	r3, .L234
1720:FreeRTOS/Source/tasks.c **** 					{
 2037              		.loc 1 1720 0
 2038 007e 2368     		ldr	r3, [r4]
 2039 0080 5BB1     		cbz	r3, .L234
1724:FreeRTOS/Source/tasks.c **** 						}
 2040              		.loc 1 1724 0
 2041 0082 0125     		movs	r5, #1
 2042              	.L242:
1722:FreeRTOS/Source/tasks.c **** 						{
 2043              		.loc 1 1722 0
 2044 0084 FFF7FEFF 		bl	xTaskIncrementTick
 2045              	.LVL189:
 2046 0088 08B1     		cbz	r0, .L235
1724:FreeRTOS/Source/tasks.c **** 						}
 2047              		.loc 1 1724 0
 2048 008a CAF80050 		str	r5, [r10]
 2049              	.L235:
1730:FreeRTOS/Source/tasks.c **** 					}
 2050              		.loc 1 1730 0
 2051 008e 2368     		ldr	r3, [r4]
 2052 0090 013B     		subs	r3, r3, #1
 2053 0092 2360     		str	r3, [r4]
1720:FreeRTOS/Source/tasks.c **** 					{
 2054              		.loc 1 1720 0
 2055 0094 2368     		ldr	r3, [r4]
 2056 0096 002B     		cmp	r3, #0
 2057 0098 F4D1     		bne	.L242
 2058              	.L234:
1738:FreeRTOS/Source/tasks.c **** 				{
 2059              		.loc 1 1738 0
 2060 009a DAF80040 		ldr	r4, [r10]
 2061 009e 012C     		cmp	r4, #1
 2062 00a0 05D0     		beq	.L249
 2063              	.L228:
1674:FreeRTOS/Source/tasks.c **** 
 2064              		.loc 1 1674 0
 2065 00a2 0024     		movs	r4, #0
 2066              	.LVL190:
 2067              	.L226:
1758:FreeRTOS/Source/tasks.c **** 
 2068              		.loc 1 1758 0
 2069 00a4 FFF7FEFF 		bl	vPortExitCritical
 2070              	.LVL191:
1761:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2071              		.loc 1 1761 0
 2072 00a8 2046     		mov	r0, r4
 2073 00aa BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2074              	.LVL192:
 2075              	.L249:
1745:FreeRTOS/Source/tasks.c **** 				}
 2076              		.loc 1 1745 0
 2077 00ae FFF7FEFF 		bl	vPortYieldFromISR
 2078              	.LVL193:
 2079 00b2 F7E7     		b	.L226
 2080              	.L251:
 2081              		.align	2
 2082              	.L250:
 2083 00b4 00000000 		.word	.LANCHOR19
 2084 00b8 00000000 		.word	.LANCHOR10
 2085 00bc 00000000 		.word	.LANCHOR13
 2086 00c0 00000000 		.word	.LANCHOR8
 2087 00c4 00000000 		.word	.LANCHOR22
 2088 00c8 00000000 		.word	.LANCHOR5
 2089 00cc 00000000 		.word	.LANCHOR9
 2090 00d0 00000000 		.word	.LANCHOR2
 2091              		.cfi_endproc
 2092              	.LFE124:
 2094              		.section	.text.vTaskDelayUntil,"ax",%progbits
 2095              		.align	2
 2096              		.global	vTaskDelayUntil
 2097              		.thumb
 2098              		.thumb_func
 2100              	vTaskDelayUntil:
 2101              	.LFB112:
 827:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2102              		.loc 1 827 0
 2103              		.cfi_startproc
 2104              		@ args = 0, pretend = 0, frame = 0
 2105              		@ frame_needed = 0, uses_anonymous_args = 0
 2106              	.LVL194:
 2107              	.LBB87:
 2108              	.LBB88:
1639:FreeRTOS/Source/tasks.c **** }
 2109              		.loc 1 1639 0
 2110 0000 134A     		ldr	r2, .L261
 2111 0002 1368     		ldr	r3, [r2]
 2112              	.LBE88:
 2113              	.LBE87:
 827:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2114              		.loc 1 827 0
 2115 0004 10B5     		push	{r4, lr}
 2116              	.LCFI32:
 2117              		.cfi_def_cfa_offset 8
 2118              		.cfi_offset 4, -8
 2119              		.cfi_offset 14, -4
 2120              	.LBB91:
 2121              	.LBB89:
1639:FreeRTOS/Source/tasks.c **** }
 2122              		.loc 1 1639 0
 2123 0006 0133     		adds	r3, r3, #1
 2124              	.LBE89:
 2125              	.LBE91:
 2126              	.LBB92:
 839:FreeRTOS/Source/tasks.c **** 
 2127              		.loc 1 839 0
 2128 0008 124C     		ldr	r4, .L261+4
 2129              	.LBE92:
 2130              	.LBB93:
 2131              	.LBB90:
1639:FreeRTOS/Source/tasks.c **** }
 2132              		.loc 1 1639 0
 2133 000a 1360     		str	r3, [r2]
 2134              	.LBE90:
 2135              	.LBE93:
 2136              	.LBB94:
 839:FreeRTOS/Source/tasks.c **** 
 2137              		.loc 1 839 0
 2138 000c 2268     		ldr	r2, [r4]
 2139              	.LVL195:
 842:FreeRTOS/Source/tasks.c **** 
 2140              		.loc 1 842 0
 2141 000e 0368     		ldr	r3, [r0]
 844:FreeRTOS/Source/tasks.c **** 			{
 2142              		.loc 1 844 0
 2143 0010 9A42     		cmp	r2, r3
 842:FreeRTOS/Source/tasks.c **** 
 2144              		.loc 1 842 0
 2145 0012 03EB0104 		add	r4, r3, r1
 2146              	.LVL196:
 844:FreeRTOS/Source/tasks.c **** 			{
 2147              		.loc 1 844 0
 2148 0016 06D2     		bcs	.L253
 851:FreeRTOS/Source/tasks.c **** 				{
 2149              		.loc 1 851 0
 2150 0018 A342     		cmp	r3, r4
 2151 001a 06D8     		bhi	.L259
 2152              	.L254:
 876:FreeRTOS/Source/tasks.c **** 
 2153              		.loc 1 876 0
 2154 001c 0460     		str	r4, [r0]
 2155              	.LBE94:
 903:FreeRTOS/Source/tasks.c **** 
 2156              		.loc 1 903 0
 2157 001e FFF7FEFF 		bl	xTaskResumeAll
 2158              	.LVL197:
 907:FreeRTOS/Source/tasks.c **** 		{
 2159              		.loc 1 907 0
 2160 0022 88B1     		cbz	r0, .L260
 2161              	.LVL198:
 2162              	.L252:
 2163 0024 10BD     		pop	{r4, pc}
 2164              	.LVL199:
 2165              	.L253:
 2166              	.LBB95:
 865:FreeRTOS/Source/tasks.c **** 				{
 2167              		.loc 1 865 0
 2168 0026 A342     		cmp	r3, r4
 2169 0028 01D8     		bhi	.L255
 2170              	.L259:
 865:FreeRTOS/Source/tasks.c **** 				{
 2171              		.loc 1 865 0 is_stmt 0 discriminator 1
 2172 002a A242     		cmp	r2, r4
 2173 002c F6D2     		bcs	.L254
 2174              	.L255:
 2175              	.LVL200:
 884:FreeRTOS/Source/tasks.c **** 				{
 2176              		.loc 1 884 0 is_stmt 1
 2177 002e 0A4B     		ldr	r3, .L261+8
 876:FreeRTOS/Source/tasks.c **** 
 2178              		.loc 1 876 0
 2179 0030 0460     		str	r4, [r0]
 884:FreeRTOS/Source/tasks.c **** 				{
 2180              		.loc 1 884 0
 2181 0032 1868     		ldr	r0, [r3]
 2182              	.LVL201:
 2183 0034 0430     		adds	r0, r0, #4
 2184 0036 FFF7FEFF 		bl	uxListRemove
 2185              	.LVL202:
 896:FreeRTOS/Source/tasks.c **** 			}
 2186              		.loc 1 896 0
 2187 003a 2046     		mov	r0, r4
 2188 003c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2189              	.LVL203:
 2190              	.LBE95:
 903:FreeRTOS/Source/tasks.c **** 
 2191              		.loc 1 903 0
 2192 0040 FFF7FEFF 		bl	xTaskResumeAll
 2193              	.LVL204:
 907:FreeRTOS/Source/tasks.c **** 		{
 2194              		.loc 1 907 0
 2195 0044 0028     		cmp	r0, #0
 2196 0046 EDD1     		bne	.L252
 2197              	.LVL205:
 2198              	.L260:
 915:FreeRTOS/Source/tasks.c **** 
 2199              		.loc 1 915 0
 2200 0048 BDE81040 		pop	{r4, lr}
 2201              	.LCFI33:
 2202              		.cfi_restore 14
 2203              		.cfi_restore 4
 2204              		.cfi_def_cfa_offset 0
 2205              	.LVL206:
 909:FreeRTOS/Source/tasks.c **** 		}
 2206              		.loc 1 909 0
 2207 004c FFF7FEBF 		b	vPortYieldFromISR
 2208              	.LVL207:
 2209              	.L262:
 2210              		.align	2
 2211              	.L261:
 2212 0050 00000000 		.word	.LANCHOR19
 2213 0054 00000000 		.word	.LANCHOR3
 2214 0058 00000000 		.word	.LANCHOR2
 2215              		.cfi_endproc
 2216              	.LFE112:
 2218              		.section	.text.vTaskDelay,"ax",%progbits
 2219              		.align	2
 2220              		.global	vTaskDelay
 2221              		.thumb
 2222              		.thumb_func
 2224              	vTaskDelay:
 2225              	.LFB113:
 923:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2226              		.loc 1 923 0
 2227              		.cfi_startproc
 2228              		@ args = 0, pretend = 0, frame = 0
 2229              		@ frame_needed = 0, uses_anonymous_args = 0
 2230              	.LVL208:
 929:FreeRTOS/Source/tasks.c **** 		{
 2231              		.loc 1 929 0
 2232 0000 08B9     		cbnz	r0, .L272
 2233              	.LVL209:
 975:FreeRTOS/Source/tasks.c **** 		}
 2234              		.loc 1 975 0
 2235 0002 FFF7FEBF 		b	vPortYieldFromISR
 2236              	.LVL210:
 2237              	.L272:
 2238              	.LBB96:
 2239              	.LBB97:
1639:FreeRTOS/Source/tasks.c **** }
 2240              		.loc 1 1639 0
 2241 0006 0C4A     		ldr	r2, .L273
 2242              	.LBE97:
 2243              	.LBE96:
 951:FreeRTOS/Source/tasks.c **** 				{
 2244              		.loc 1 951 0
 2245 0008 0C49     		ldr	r1, .L273+4
 2246              	.LBB101:
 2247              	.LBB98:
1639:FreeRTOS/Source/tasks.c **** }
 2248              		.loc 1 1639 0
 2249 000a 1368     		ldr	r3, [r2]
 2250              	.LBE98:
 2251              	.LBE101:
 923:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 2252              		.loc 1 923 0
 2253 000c 10B5     		push	{r4, lr}
 2254              	.LCFI34:
 2255              		.cfi_def_cfa_offset 8
 2256              		.cfi_offset 4, -8
 2257              		.cfi_offset 14, -4
 2258              	.LBB102:
 2259              	.LBB99:
1639:FreeRTOS/Source/tasks.c **** }
 2260              		.loc 1 1639 0
 2261 000e 0133     		adds	r3, r3, #1
 2262              	.LBE99:
 2263              	.LBE102:
 946:FreeRTOS/Source/tasks.c **** 
 2264              		.loc 1 946 0
 2265 0010 0B4C     		ldr	r4, .L273+8
 2266              	.LBB103:
 2267              	.LBB100:
1639:FreeRTOS/Source/tasks.c **** }
 2268              		.loc 1 1639 0
 2269 0012 1360     		str	r3, [r2]
 2270              	.LBE100:
 2271              	.LBE103:
 946:FreeRTOS/Source/tasks.c **** 
 2272              		.loc 1 946 0
 2273 0014 2468     		ldr	r4, [r4]
 951:FreeRTOS/Source/tasks.c **** 				{
 2274              		.loc 1 951 0
 2275 0016 0B68     		ldr	r3, [r1]
 946:FreeRTOS/Source/tasks.c **** 
 2276              		.loc 1 946 0
 2277 0018 0444     		add	r4, r4, r0
 2278              	.LVL211:
 951:FreeRTOS/Source/tasks.c **** 				{
 2279              		.loc 1 951 0
 2280 001a 181D     		adds	r0, r3, #4
 2281              	.LVL212:
 2282 001c FFF7FEFF 		bl	uxListRemove
 2283              	.LVL213:
 962:FreeRTOS/Source/tasks.c **** 			}
 2284              		.loc 1 962 0
 2285 0020 2046     		mov	r0, r4
 2286 0022 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2287              	.LVL214:
 964:FreeRTOS/Source/tasks.c **** 		}
 2288              		.loc 1 964 0
 2289 0026 FFF7FEFF 		bl	xTaskResumeAll
 2290              	.LVL215:
 973:FreeRTOS/Source/tasks.c **** 		{
 2291              		.loc 1 973 0
 2292 002a 00B1     		cbz	r0, .L265
 981:FreeRTOS/Source/tasks.c **** 
 2293              		.loc 1 981 0
 2294 002c 10BD     		pop	{r4, pc}
 2295              	.LVL216:
 2296              	.L265:
 2297 002e BDE81040 		pop	{r4, lr}
 2298              	.LCFI35:
 2299              		.cfi_restore 14
 2300              		.cfi_restore 4
 2301              		.cfi_def_cfa_offset 0
 2302              	.LVL217:
 975:FreeRTOS/Source/tasks.c **** 		}
 2303              		.loc 1 975 0
 2304 0032 FFF7FEBF 		b	vPortYieldFromISR
 2305              	.LVL218:
 2306              	.L274:
 2307 0036 00BF     		.align	2
 2308              	.L273:
 2309 0038 00000000 		.word	.LANCHOR19
 2310 003c 00000000 		.word	.LANCHOR2
 2311 0040 00000000 		.word	.LANCHOR3
 2312              		.cfi_endproc
 2313              	.LFE113:
 2315              		.section	.text.prvIdleTask,"ax",%progbits
 2316              		.align	2
 2317              		.thumb
 2318              		.thumb_func
 2320              	prvIdleTask:
 2321              	.LFB141:
2691:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 2322              		.loc 1 2691 0
 2323              		.cfi_startproc
 2324              		@ Volatile: function does not return.
 2325              		@ args = 0, pretend = 0, frame = 0
 2326              		@ frame_needed = 0, uses_anonymous_args = 0
 2327              	.LVL219:
 2328 0000 1C4E     		ldr	r6, .L286
 2329 0002 1D4D     		ldr	r5, .L286+4
 2330 0004 1D4C     		ldr	r4, .L286+8
 2331 0006 DFF87880 		ldr	r8, .L286+12
 2332 000a DFF87890 		ldr	r9, .L286+16
 2333 000e 2DE98848 		push	{r3, r7, fp, lr}
 2334              	.LCFI36:
 2335              		.cfi_def_cfa_offset 16
 2336              		.cfi_offset 3, -16
 2337              		.cfi_offset 7, -12
 2338              		.cfi_offset 11, -8
 2339              		.cfi_offset 14, -4
 2340              	.LBB112:
 2341              	.LBB113:
3042:FreeRTOS/Source/tasks.c **** 			}
 2342              		.loc 1 3042 0
 2343 0012 B246     		mov	r10, r6
 2344 0014 06E0     		b	.L277
 2345              	.LVL220:
 2346              	.L278:
 2347              	.LBB114:
 2348              	.LBB115:
1639:FreeRTOS/Source/tasks.c **** }
 2349              		.loc 1 1639 0
 2350 0016 2368     		ldr	r3, [r4]
 2351              	.LBE115:
 2352              	.LBE114:
3042:FreeRTOS/Source/tasks.c **** 			}
 2353              		.loc 1 3042 0
 2354 0018 3768     		ldr	r7, [r6]
 2355              	.LVL221:
 2356              	.LBB117:
 2357              	.LBB116:
1639:FreeRTOS/Source/tasks.c **** }
 2358              		.loc 1 1639 0
 2359 001a 0133     		adds	r3, r3, #1
 2360 001c 2360     		str	r3, [r4]
 2361              	.LBE116:
 2362              	.LBE117:
3044:FreeRTOS/Source/tasks.c **** 
 2363              		.loc 1 3044 0
 2364 001e FFF7FEFF 		bl	xTaskResumeAll
 2365              	.LVL222:
3046:FreeRTOS/Source/tasks.c **** 			{
 2366              		.loc 1 3046 0
 2367 0022 4FB9     		cbnz	r7, .L285
 2368              	.LVL223:
 2369              	.L277:
3038:FreeRTOS/Source/tasks.c **** 		{
 2370              		.loc 1 3038 0
 2371 0024 2B68     		ldr	r3, [r5]
 2372 0026 002B     		cmp	r3, #0
 2373 0028 F5D1     		bne	.L278
 2374              	.LBE113:
 2375              	.LBE112:
2721:FreeRTOS/Source/tasks.c **** 			{
 2376              		.loc 1 2721 0
 2377 002a D9F80030 		ldr	r3, [r9]
 2378 002e 012B     		cmp	r3, #1
 2379 0030 F8D9     		bls	.L277
2723:FreeRTOS/Source/tasks.c **** 			}
 2380              		.loc 1 2723 0
 2381 0032 FFF7FEFF 		bl	vPortYieldFromISR
 2382              	.LVL224:
 2383 0036 F5E7     		b	.L277
 2384              	.LVL225:
 2385              	.L285:
 2386              	.LBB122:
 2387              	.LBB121:
 2388              	.LBB118:
3050:FreeRTOS/Source/tasks.c **** 				{
 2389              		.loc 1 3050 0
 2390 0038 FFF7FEFF 		bl	vPortEnterCritical
 2391              	.LVL226:
3052:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2392              		.loc 1 3052 0
 2393 003c DAF80C30 		ldr	r3, [r10, #12]
 2394 0040 D3F80CB0 		ldr	fp, [r3, #12]
 2395              	.LVL227:
3053:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 2396              		.loc 1 3053 0
 2397 0044 0BF10400 		add	r0, fp, #4
 2398 0048 FFF7FEFF 		bl	uxListRemove
 2399              	.LVL228:
3054:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 2400              		.loc 1 3054 0
 2401 004c D8F80030 		ldr	r3, [r8]
3055:FreeRTOS/Source/tasks.c **** 				}
 2402              		.loc 1 3055 0
 2403 0050 094A     		ldr	r2, .L286+4
3054:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 2404              		.loc 1 3054 0
 2405 0052 013B     		subs	r3, r3, #1
 2406 0054 C8F80030 		str	r3, [r8]
3055:FreeRTOS/Source/tasks.c **** 				}
 2407              		.loc 1 3055 0
 2408 0058 074B     		ldr	r3, .L286+4
 2409 005a 1B68     		ldr	r3, [r3]
 2410 005c 013B     		subs	r3, r3, #1
 2411 005e 1360     		str	r3, [r2]
3057:FreeRTOS/Source/tasks.c **** 
 2412              		.loc 1 3057 0
 2413 0060 FFF7FEFF 		bl	vPortExitCritical
 2414              	.LVL229:
 2415              	.LBB119:
 2416              	.LBB120:
3337:FreeRTOS/Source/tasks.c **** 		}
 2417              		.loc 1 3337 0
 2418 0064 DBF83000 		ldr	r0, [fp, #48]
 2419 0068 FFF7FEFF 		bl	free
 2420              	.LVL230:
3341:FreeRTOS/Source/tasks.c **** 	}
 2421              		.loc 1 3341 0
 2422 006c 5846     		mov	r0, fp
 2423 006e FFF7FEFF 		bl	free
 2424              	.LVL231:
 2425 0072 D7E7     		b	.L277
 2426              	.L287:
 2427              		.align	2
 2428              	.L286:
 2429 0074 00000000 		.word	.LANCHOR14
 2430 0078 00000000 		.word	.LANCHOR18
 2431 007c 00000000 		.word	.LANCHOR19
 2432 0080 00000000 		.word	.LANCHOR10
 2433 0084 00000000 		.word	.LANCHOR9
 2434              	.LBE120:
 2435              	.LBE119:
 2436              	.LBE118:
 2437              	.LBE121:
 2438              	.LBE122:
 2439              		.cfi_endproc
 2440              	.LFE141:
 2442              		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 2443              		.align	2
 2444              		.global	vTaskSetApplicationTaskTag
 2445              		.thumb
 2446              		.thumb_func
 2448              	vTaskSetApplicationTaskTag:
 2449              	.LFB130:
2116:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
 2450              		.loc 1 2116 0
 2451              		.cfi_startproc
 2452              		@ args = 0, pretend = 0, frame = 0
 2453              		@ frame_needed = 0, uses_anonymous_args = 0
 2454              	.LVL232:
 2455 0000 38B5     		push	{r3, r4, r5, lr}
 2456              	.LCFI37:
 2457              		.cfi_def_cfa_offset 16
 2458              		.cfi_offset 3, -16
 2459              		.cfi_offset 4, -12
 2460              		.cfi_offset 5, -8
 2461              		.cfi_offset 14, -4
2116:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
 2462              		.loc 1 2116 0
 2463 0002 0D46     		mov	r5, r1
2121:FreeRTOS/Source/tasks.c **** 		{
 2464              		.loc 1 2121 0
 2465 0004 0446     		mov	r4, r0
 2466 0006 30B1     		cbz	r0, .L291
 2467              	.LVL233:
2132:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2468              		.loc 1 2132 0
 2469 0008 FFF7FEFF 		bl	vPortEnterCritical
 2470              	.LVL234:
2133:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2471              		.loc 1 2133 0
 2472 000c E564     		str	r5, [r4, #76]
2135:FreeRTOS/Source/tasks.c **** 
 2473              		.loc 1 2135 0
 2474 000e BDE83840 		pop	{r3, r4, r5, lr}
 2475              	.LCFI38:
 2476              		.cfi_remember_state
 2477              		.cfi_restore 14
 2478              		.cfi_restore 5
 2479              		.cfi_restore 4
 2480              		.cfi_restore 3
 2481              		.cfi_def_cfa_offset 0
 2482              	.LVL235:
2134:FreeRTOS/Source/tasks.c **** 	}
 2483              		.loc 1 2134 0
 2484 0012 FFF7FEBF 		b	vPortExitCritical
 2485              	.LVL236:
 2486              	.L291:
 2487              	.LCFI39:
 2488              		.cfi_restore_state
2123:FreeRTOS/Source/tasks.c **** 		}
 2489              		.loc 1 2123 0
 2490 0016 044B     		ldr	r3, .L292
 2491 0018 1C68     		ldr	r4, [r3]
 2492              	.LVL237:
2132:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2493              		.loc 1 2132 0
 2494 001a FFF7FEFF 		bl	vPortEnterCritical
 2495              	.LVL238:
2133:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2496              		.loc 1 2133 0
 2497 001e E564     		str	r5, [r4, #76]
2135:FreeRTOS/Source/tasks.c **** 
 2498              		.loc 1 2135 0
 2499 0020 BDE83840 		pop	{r3, r4, r5, lr}
 2500              	.LCFI40:
 2501              		.cfi_restore 3
 2502              		.cfi_restore 4
 2503              		.cfi_restore 5
 2504              		.cfi_restore 14
 2505              		.cfi_def_cfa_offset 0
 2506              	.LVL239:
2134:FreeRTOS/Source/tasks.c **** 	}
 2507              		.loc 1 2134 0
 2508 0024 FFF7FEBF 		b	vPortExitCritical
 2509              	.LVL240:
 2510              	.L293:
 2511              		.align	2
 2512              	.L292:
 2513 0028 00000000 		.word	.LANCHOR2
 2514              		.cfi_endproc
 2515              	.LFE130:
 2517              		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2518              		.align	2
 2519              		.global	xTaskGetApplicationTaskTag
 2520              		.thumb
 2521              		.thumb_func
 2523              	xTaskGetApplicationTaskTag:
 2524              	.LFB131:
2143:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
 2525              		.loc 1 2143 0
 2526              		.cfi_startproc
 2527              		@ args = 0, pretend = 0, frame = 0
 2528              		@ frame_needed = 0, uses_anonymous_args = 0
 2529              	.LVL241:
 2530 0000 10B5     		push	{r4, lr}
 2531              	.LCFI41:
 2532              		.cfi_def_cfa_offset 8
 2533              		.cfi_offset 4, -8
 2534              		.cfi_offset 14, -4
2148:FreeRTOS/Source/tasks.c **** 		{
 2535              		.loc 1 2148 0
 2536 0002 0446     		mov	r4, r0
 2537 0004 30B1     		cbz	r0, .L297
 2538              	.LVL242:
 2539              	.L295:
2159:FreeRTOS/Source/tasks.c **** 		{
 2540              		.loc 1 2159 0
 2541 0006 FFF7FEFF 		bl	vPortEnterCritical
 2542              	.LVL243:
2161:FreeRTOS/Source/tasks.c **** 		}
 2543              		.loc 1 2161 0
 2544 000a E46C     		ldr	r4, [r4, #76]
 2545              	.LVL244:
2163:FreeRTOS/Source/tasks.c **** 
 2546              		.loc 1 2163 0
 2547 000c FFF7FEFF 		bl	vPortExitCritical
 2548              	.LVL245:
2166:FreeRTOS/Source/tasks.c **** 
 2549              		.loc 1 2166 0
 2550 0010 2046     		mov	r0, r4
 2551 0012 10BD     		pop	{r4, pc}
 2552              	.LVL246:
 2553              	.L297:
2150:FreeRTOS/Source/tasks.c **** 		}
 2554              		.loc 1 2150 0
 2555 0014 014B     		ldr	r3, .L298
 2556 0016 1C68     		ldr	r4, [r3]
 2557              	.LVL247:
 2558 0018 F5E7     		b	.L295
 2559              	.L299:
 2560 001a 00BF     		.align	2
 2561              	.L298:
 2562 001c 00000000 		.word	.LANCHOR2
 2563              		.cfi_endproc
 2564              	.LFE131:
 2566              		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2567              		.align	2
 2568              		.global	xTaskCallApplicationTaskHook
 2569              		.thumb
 2570              		.thumb_func
 2572              	xTaskCallApplicationTaskHook:
 2573              	.LFB132:
2174:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
 2574              		.loc 1 2174 0
 2575              		.cfi_startproc
 2576              		@ args = 0, pretend = 0, frame = 0
 2577              		@ frame_needed = 0, uses_anonymous_args = 0
 2578              		@ link register save eliminated.
 2579              	.LVL248:
2179:FreeRTOS/Source/tasks.c **** 		{
 2580              		.loc 1 2179 0
 2581 0000 28B1     		cbz	r0, .L303
 2582              	.LVL249:
 2583              	.L301:
2188:FreeRTOS/Source/tasks.c **** 		{
 2584              		.loc 1 2188 0
 2585 0002 C36C     		ldr	r3, [r0, #76]
 2586 0004 0BB1     		cbz	r3, .L302
2190:FreeRTOS/Source/tasks.c **** 		}
 2587              		.loc 1 2190 0
 2588 0006 0846     		mov	r0, r1
 2589              	.LVL250:
 2590 0008 1847     		bx	r3
 2591              	.LVL251:
 2592              	.L302:
2198:FreeRTOS/Source/tasks.c **** 
 2593              		.loc 1 2198 0
 2594 000a 1846     		mov	r0, r3
 2595              	.LVL252:
 2596 000c 7047     		bx	lr
 2597              	.LVL253:
 2598              	.L303:
2181:FreeRTOS/Source/tasks.c **** 		}
 2599              		.loc 1 2181 0
 2600 000e 014B     		ldr	r3, .L304
 2601 0010 1868     		ldr	r0, [r3]
 2602              	.LVL254:
 2603 0012 F6E7     		b	.L301
 2604              	.L305:
 2605              		.align	2
 2606              	.L304:
 2607 0014 00000000 		.word	.LANCHOR2
 2608              		.cfi_endproc
 2609              	.LFE132:
 2611              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2612              		.align	2
 2613              		.global	vTaskSwitchContext
 2614              		.thumb
 2615              		.thumb_func
 2617              	vTaskSwitchContext:
 2618              	.LFB133:
2204:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2619              		.loc 1 2204 0
 2620              		.cfi_startproc
 2621              		@ args = 0, pretend = 0, frame = 0
 2622              		@ frame_needed = 0, uses_anonymous_args = 0
 2623              		@ link register save eliminated.
2205:FreeRTOS/Source/tasks.c **** 	{
 2624              		.loc 1 2205 0
 2625 0000 044B     		ldr	r3, .L310
 2626 0002 1B68     		ldr	r3, [r3]
 2627 0004 1BB1     		cbz	r3, .L307
2209:FreeRTOS/Source/tasks.c **** 	}
 2628              		.loc 1 2209 0
 2629 0006 044B     		ldr	r3, .L310+4
 2630 0008 0122     		movs	r2, #1
 2631 000a 1A60     		str	r2, [r3]
 2632 000c 7047     		bx	lr
 2633              	.L307:
 2634 000e FFF7FEBF 		b	vTaskSwitchContext.part.4
 2635              	.LVL255:
 2636              	.L311:
 2637 0012 00BF     		.align	2
 2638              	.L310:
 2639 0014 00000000 		.word	.LANCHOR19
 2640 0018 00000000 		.word	.LANCHOR5
 2641              		.cfi_endproc
 2642              	.LFE133:
 2644              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2645              		.align	2
 2646              		.global	vTaskPlaceOnEventList
 2647              		.thumb
 2648              		.thumb_func
 2650              	vTaskPlaceOnEventList:
 2651              	.LFB134:
2263:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2652              		.loc 1 2263 0
 2653              		.cfi_startproc
 2654              		@ args = 0, pretend = 0, frame = 0
 2655              		@ frame_needed = 0, uses_anonymous_args = 0
 2656              	.LVL256:
 2657 0000 38B5     		push	{r3, r4, r5, lr}
 2658              	.LCFI42:
 2659              		.cfi_def_cfa_offset 16
 2660              		.cfi_offset 3, -16
 2661              		.cfi_offset 4, -12
 2662              		.cfi_offset 5, -8
 2663              		.cfi_offset 14, -4
2275:FreeRTOS/Source/tasks.c **** 
 2664              		.loc 1 2275 0
 2665 0002 0D4C     		ldr	r4, .L316
 2666 0004 2368     		ldr	r3, [r4]
2263:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2667              		.loc 1 2263 0
 2668 0006 0D46     		mov	r5, r1
2275:FreeRTOS/Source/tasks.c **** 
 2669              		.loc 1 2275 0
 2670 0008 03F11801 		add	r1, r3, #24
 2671              	.LVL257:
 2672 000c FFF7FEFF 		bl	vListInsert
 2673              	.LVL258:
2280:FreeRTOS/Source/tasks.c **** 	{
 2674              		.loc 1 2280 0
 2675 0010 2068     		ldr	r0, [r4]
 2676 0012 0430     		adds	r0, r0, #4
 2677 0014 FFF7FEFF 		bl	uxListRemove
 2678              	.LVL259:
2293:FreeRTOS/Source/tasks.c **** 		{
 2679              		.loc 1 2293 0
 2680 0018 6B1C     		adds	r3, r5, #1
 2681 001a 06D0     		beq	.L315
2305:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2682              		.loc 1 2305 0
 2683 001c 074B     		ldr	r3, .L316+4
 2684 001e 1868     		ldr	r0, [r3]
 2685              	.LVL260:
2306:FreeRTOS/Source/tasks.c **** 		}
 2686              		.loc 1 2306 0
 2687 0020 2844     		add	r0, r0, r5
 2688              	.LVL261:
2318:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2689              		.loc 1 2318 0
 2690 0022 BDE83840 		pop	{r3, r4, r5, lr}
 2691              	.LCFI43:
 2692              		.cfi_remember_state
 2693              		.cfi_restore 14
 2694              		.cfi_restore 5
 2695              		.cfi_restore 4
 2696              		.cfi_restore 3
 2697              		.cfi_def_cfa_offset 0
 2698              	.LVL262:
2306:FreeRTOS/Source/tasks.c **** 		}
 2699              		.loc 1 2306 0
 2700 0026 FFF7FEBF 		b	prvAddCurrentTaskToDelayedList
 2701              	.LVL263:
 2702              	.L315:
 2703              	.LCFI44:
 2704              		.cfi_restore_state
2298:FreeRTOS/Source/tasks.c **** 		}
 2705              		.loc 1 2298 0
 2706 002a 2168     		ldr	r1, [r4]
 2707 002c 0448     		ldr	r0, .L316+8
 2708 002e 0431     		adds	r1, r1, #4
2318:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2709              		.loc 1 2318 0
 2710 0030 BDE83840 		pop	{r3, r4, r5, lr}
 2711              	.LCFI45:
 2712              		.cfi_restore 14
 2713              		.cfi_restore 5
 2714              		.cfi_restore 4
 2715              		.cfi_restore 3
 2716              		.cfi_def_cfa_offset 0
 2717              	.LVL264:
2298:FreeRTOS/Source/tasks.c **** 		}
 2718              		.loc 1 2298 0
 2719 0034 FFF7FEBF 		b	vListInsertEnd
 2720              	.LVL265:
 2721              	.L317:
 2722              		.align	2
 2723              	.L316:
 2724 0038 00000000 		.word	.LANCHOR2
 2725 003c 00000000 		.word	.LANCHOR3
 2726 0040 00000000 		.word	.LANCHOR15
 2727              		.cfi_endproc
 2728              	.LFE134:
 2730              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2731              		.align	2
 2732              		.global	vTaskPlaceOnUnorderedEventList
 2733              		.thumb
 2734              		.thumb_func
 2736              	vTaskPlaceOnUnorderedEventList:
 2737              	.LFB135:
2322:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2738              		.loc 1 2322 0
 2739              		.cfi_startproc
 2740              		@ args = 0, pretend = 0, frame = 0
 2741              		@ frame_needed = 0, uses_anonymous_args = 0
 2742              	.LVL266:
 2743 0000 38B5     		push	{r3, r4, r5, lr}
 2744              	.LCFI46:
 2745              		.cfi_def_cfa_offset 16
 2746              		.cfi_offset 3, -16
 2747              		.cfi_offset 4, -12
 2748              		.cfi_offset 5, -8
 2749              		.cfi_offset 14, -4
2334:FreeRTOS/Source/tasks.c **** 
 2750              		.loc 1 2334 0
 2751 0002 0F4C     		ldr	r4, .L322
 2752 0004 2568     		ldr	r5, [r4]
2341:FreeRTOS/Source/tasks.c **** 
 2753              		.loc 1 2341 0
 2754 0006 2368     		ldr	r3, [r4]
2334:FreeRTOS/Source/tasks.c **** 
 2755              		.loc 1 2334 0
 2756 0008 41F00041 		orr	r1, r1, #-2147483648
 2757              	.LVL267:
 2758 000c A961     		str	r1, [r5, #24]
2341:FreeRTOS/Source/tasks.c **** 
 2759              		.loc 1 2341 0
 2760 000e 03F11801 		add	r1, r3, #24
2322:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
 2761              		.loc 1 2322 0
 2762 0012 1546     		mov	r5, r2
2341:FreeRTOS/Source/tasks.c **** 
 2763              		.loc 1 2341 0
 2764 0014 FFF7FEFF 		bl	vListInsertEnd
 2765              	.LVL268:
2346:FreeRTOS/Source/tasks.c **** 	{
 2766              		.loc 1 2346 0
 2767 0018 2068     		ldr	r0, [r4]
 2768 001a 0430     		adds	r0, r0, #4
 2769 001c FFF7FEFF 		bl	uxListRemove
 2770              	.LVL269:
2359:FreeRTOS/Source/tasks.c **** 		{
 2771              		.loc 1 2359 0
 2772 0020 6B1C     		adds	r3, r5, #1
 2773 0022 06D0     		beq	.L321
2371:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2774              		.loc 1 2371 0
 2775 0024 074B     		ldr	r3, .L322+4
 2776 0026 1868     		ldr	r0, [r3]
 2777              	.LVL270:
2372:FreeRTOS/Source/tasks.c **** 		}
 2778              		.loc 1 2372 0
 2779 0028 2844     		add	r0, r0, r5
 2780              	.LVL271:
2384:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2781              		.loc 1 2384 0
 2782 002a BDE83840 		pop	{r3, r4, r5, lr}
 2783              	.LCFI47:
 2784              		.cfi_remember_state
 2785              		.cfi_restore 14
 2786              		.cfi_restore 5
 2787              		.cfi_restore 4
 2788              		.cfi_restore 3
 2789              		.cfi_def_cfa_offset 0
 2790              	.LVL272:
2372:FreeRTOS/Source/tasks.c **** 		}
 2791              		.loc 1 2372 0
 2792 002e FFF7FEBF 		b	prvAddCurrentTaskToDelayedList
 2793              	.LVL273:
 2794              	.L321:
 2795              	.LCFI48:
 2796              		.cfi_restore_state
2364:FreeRTOS/Source/tasks.c **** 		}
 2797              		.loc 1 2364 0
 2798 0032 2168     		ldr	r1, [r4]
 2799 0034 0448     		ldr	r0, .L322+8
 2800 0036 0431     		adds	r1, r1, #4
2384:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2801              		.loc 1 2384 0
 2802 0038 BDE83840 		pop	{r3, r4, r5, lr}
 2803              	.LCFI49:
 2804              		.cfi_restore 14
 2805              		.cfi_restore 5
 2806              		.cfi_restore 4
 2807              		.cfi_restore 3
 2808              		.cfi_def_cfa_offset 0
 2809              	.LVL274:
2364:FreeRTOS/Source/tasks.c **** 		}
 2810              		.loc 1 2364 0
 2811 003c FFF7FEBF 		b	vListInsertEnd
 2812              	.LVL275:
 2813              	.L323:
 2814              		.align	2
 2815              	.L322:
 2816 0040 00000000 		.word	.LANCHOR2
 2817 0044 00000000 		.word	.LANCHOR3
 2818 0048 00000000 		.word	.LANCHOR15
 2819              		.cfi_endproc
 2820              	.LFE135:
 2822              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2823              		.align	2
 2824              		.global	xTaskRemoveFromEventList
 2825              		.thumb
 2826              		.thumb_func
 2828              	xTaskRemoveFromEventList:
 2829              	.LFB136:
2466:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2830              		.loc 1 2466 0
 2831              		.cfi_startproc
 2832              		@ args = 0, pretend = 0, frame = 0
 2833              		@ frame_needed = 0, uses_anonymous_args = 0
 2834              	.LVL276:
 2835 0000 38B5     		push	{r3, r4, r5, lr}
 2836              	.LCFI50:
 2837              		.cfi_def_cfa_offset 16
 2838              		.cfi_offset 3, -16
 2839              		.cfi_offset 4, -12
 2840              		.cfi_offset 5, -8
 2841              		.cfi_offset 14, -4
2483:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2842              		.loc 1 2483 0
 2843 0002 C368     		ldr	r3, [r0, #12]
 2844 0004 DC68     		ldr	r4, [r3, #12]
 2845              	.LVL277:
2485:FreeRTOS/Source/tasks.c **** 
 2846              		.loc 1 2485 0
 2847 0006 04F11805 		add	r5, r4, #24
 2848 000a 2846     		mov	r0, r5
 2849              	.LVL278:
 2850 000c FFF7FEFF 		bl	uxListRemove
 2851              	.LVL279:
2487:FreeRTOS/Source/tasks.c **** 	{
 2852              		.loc 1 2487 0
 2853 0010 124B     		ldr	r3, .L331
 2854 0012 1B68     		ldr	r3, [r3]
 2855 0014 E3B9     		cbnz	r3, .L325
2489:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2856              		.loc 1 2489 0
 2857 0016 251D     		adds	r5, r4, #4
 2858 0018 2846     		mov	r0, r5
 2859 001a FFF7FEFF 		bl	uxListRemove
 2860              	.LVL280:
2490:FreeRTOS/Source/tasks.c **** 	}
 2861              		.loc 1 2490 0
 2862 001e 104A     		ldr	r2, .L331+4
 2863 0020 E36A     		ldr	r3, [r4, #44]
 2864 0022 1168     		ldr	r1, [r2]
 2865 0024 0F48     		ldr	r0, .L331+8
 2866 0026 8B42     		cmp	r3, r1
 2867 0028 88BF     		it	hi
 2868 002a 1360     		strhi	r3, [r2]
 2869 002c 03EB8303 		add	r3, r3, r3, lsl #2
 2870 0030 2946     		mov	r1, r5
 2871 0032 00EB8300 		add	r0, r0, r3, lsl #2
 2872 0036 FFF7FEFF 		bl	vListInsertEnd
 2873              	.LVL281:
 2874              	.L327:
2499:FreeRTOS/Source/tasks.c **** 	{
 2875              		.loc 1 2499 0
 2876 003a 0B4B     		ldr	r3, .L331+12
 2877 003c E26A     		ldr	r2, [r4, #44]
 2878 003e 1B68     		ldr	r3, [r3]
 2879 0040 DB6A     		ldr	r3, [r3, #44]
 2880 0042 9A42     		cmp	r2, r3
 2881              	.LVL282:
2508:FreeRTOS/Source/tasks.c **** 	}
 2882              		.loc 1 2508 0
 2883 0044 83BF     		ittte	hi
 2884 0046 094B     		ldrhi	r3, .L331+16
 2885 0048 0120     		movhi	r0, #1
 2886 004a 1860     		strhi	r0, [r3]
2512:FreeRTOS/Source/tasks.c **** 	}
 2887              		.loc 1 2512 0
 2888 004c 0020     		movls	r0, #0
 2889              	.LVL283:
2530:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2890              		.loc 1 2530 0
 2891 004e 38BD     		pop	{r3, r4, r5, pc}
 2892              	.LVL284:
 2893              	.L325:
2496:FreeRTOS/Source/tasks.c **** 	}
 2894              		.loc 1 2496 0
 2895 0050 2946     		mov	r1, r5
 2896 0052 0748     		ldr	r0, .L331+20
 2897 0054 FFF7FEFF 		bl	vListInsertEnd
 2898              	.LVL285:
 2899 0058 EFE7     		b	.L327
 2900              	.L332:
 2901 005a 00BF     		.align	2
 2902              	.L331:
 2903 005c 00000000 		.word	.LANCHOR19
 2904 0060 00000000 		.word	.LANCHOR8
 2905 0064 00000000 		.word	.LANCHOR9
 2906 0068 00000000 		.word	.LANCHOR2
 2907 006c 00000000 		.word	.LANCHOR5
 2908 0070 00000000 		.word	.LANCHOR13
 2909              		.cfi_endproc
 2910              	.LFE136:
 2912              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 2913              		.align	2
 2914              		.global	xTaskRemoveFromUnorderedEventList
 2915              		.thumb
 2916              		.thumb_func
 2918              	xTaskRemoveFromUnorderedEventList:
 2919              	.LFB137:
2534:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
 2920              		.loc 1 2534 0
 2921              		.cfi_startproc
 2922              		@ args = 0, pretend = 0, frame = 0
 2923              		@ frame_needed = 0, uses_anonymous_args = 0
 2924              	.LVL286:
 2925 0000 38B5     		push	{r3, r4, r5, lr}
 2926              	.LCFI51:
 2927              		.cfi_def_cfa_offset 16
 2928              		.cfi_offset 3, -16
 2929              		.cfi_offset 4, -12
 2930              		.cfi_offset 5, -8
 2931              		.cfi_offset 14, -4
2547:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2932              		.loc 1 2547 0
 2933 0002 C468     		ldr	r4, [r0, #12]
 2934              	.LVL287:
2543:FreeRTOS/Source/tasks.c **** 
 2935              		.loc 1 2543 0
 2936 0004 41F00041 		orr	r1, r1, #-2147483648
 2937              	.LVL288:
 2938 0008 0160     		str	r1, [r0]
2554:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2939              		.loc 1 2554 0
 2940 000a 251D     		adds	r5, r4, #4
2549:FreeRTOS/Source/tasks.c **** 
 2941              		.loc 1 2549 0
 2942 000c FFF7FEFF 		bl	uxListRemove
 2943              	.LVL289:
2554:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2944              		.loc 1 2554 0
 2945 0010 2846     		mov	r0, r5
 2946 0012 FFF7FEFF 		bl	uxListRemove
 2947              	.LVL290:
2555:FreeRTOS/Source/tasks.c **** 
 2948              		.loc 1 2555 0
 2949 0016 0C4A     		ldr	r2, .L338
 2950 0018 E36A     		ldr	r3, [r4, #44]
 2951 001a 1168     		ldr	r1, [r2]
 2952 001c 0B48     		ldr	r0, .L338+4
 2953 001e 8B42     		cmp	r3, r1
 2954 0020 88BF     		it	hi
 2955 0022 1360     		strhi	r3, [r2]
 2956 0024 03EB8303 		add	r3, r3, r3, lsl #2
 2957 0028 00EB8300 		add	r0, r0, r3, lsl #2
 2958 002c 2946     		mov	r1, r5
 2959 002e FFF7FEFF 		bl	vListInsertEnd
 2960              	.LVL291:
2557:FreeRTOS/Source/tasks.c **** 	{
 2961              		.loc 1 2557 0
 2962 0032 074B     		ldr	r3, .L338+8
 2963 0034 E26A     		ldr	r2, [r4, #44]
 2964 0036 1B68     		ldr	r3, [r3]
 2965 0038 DB6A     		ldr	r3, [r3, #44]
 2966 003a 9A42     		cmp	r2, r3
 2967              	.LVL292:
2567:FreeRTOS/Source/tasks.c **** 	}
 2968              		.loc 1 2567 0
 2969 003c 83BF     		ittte	hi
 2970 003e 054B     		ldrhi	r3, .L338+12
 2971 0040 0120     		movhi	r0, #1
 2972 0042 1860     		strhi	r0, [r3]
2571:FreeRTOS/Source/tasks.c **** 	}
 2973              		.loc 1 2571 0
 2974 0044 0020     		movls	r0, #0
 2975              	.LVL293:
2575:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2976              		.loc 1 2575 0
 2977 0046 38BD     		pop	{r3, r4, r5, pc}
 2978              	.LVL294:
 2979              	.L339:
 2980              		.align	2
 2981              	.L338:
 2982 0048 00000000 		.word	.LANCHOR8
 2983 004c 00000000 		.word	.LANCHOR9
 2984 0050 00000000 		.word	.LANCHOR2
 2985 0054 00000000 		.word	.LANCHOR5
 2986              		.cfi_endproc
 2987              	.LFE137:
 2989              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2990              		.align	2
 2991              		.global	vTaskSetTimeOutState
 2992              		.thumb
 2993              		.thumb_func
 2995              	vTaskSetTimeOutState:
 2996              	.LFB138:
2579:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2997              		.loc 1 2579 0
 2998              		.cfi_startproc
 2999              		@ args = 0, pretend = 0, frame = 0
 3000              		@ frame_needed = 0, uses_anonymous_args = 0
 3001              		@ link register save eliminated.
 3002              	.LVL295:
2581:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3003              		.loc 1 2581 0
 3004 0000 034A     		ldr	r2, .L341
2582:FreeRTOS/Source/tasks.c **** }
 3005              		.loc 1 2582 0
 3006 0002 044B     		ldr	r3, .L341+4
2581:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3007              		.loc 1 2581 0
 3008 0004 1268     		ldr	r2, [r2]
2582:FreeRTOS/Source/tasks.c **** }
 3009              		.loc 1 2582 0
 3010 0006 1B68     		ldr	r3, [r3]
 3011 0008 80E80C00 		stmia	r0, {r2, r3}
 3012 000c 7047     		bx	lr
 3013              	.L342:
 3014 000e 00BF     		.align	2
 3015              	.L341:
 3016 0010 00000000 		.word	.LANCHOR21
 3017 0014 00000000 		.word	.LANCHOR3
 3018              		.cfi_endproc
 3019              	.LFE138:
 3021              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3022              		.align	2
 3023              		.global	xTaskCheckForTimeOut
 3024              		.thumb
 3025              		.thumb_func
 3027              	xTaskCheckForTimeOut:
 3028              	.LFB139:
2587:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 3029              		.loc 1 2587 0
 3030              		.cfi_startproc
 3031              		@ args = 0, pretend = 0, frame = 0
 3032              		@ frame_needed = 0, uses_anonymous_args = 0
 3033              	.LVL296:
 3034 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3035              	.LCFI52:
 3036              		.cfi_def_cfa_offset 24
 3037              		.cfi_offset 3, -24
 3038              		.cfi_offset 4, -20
 3039              		.cfi_offset 5, -16
 3040              		.cfi_offset 6, -12
 3041              		.cfi_offset 7, -8
 3042              		.cfi_offset 14, -4
2587:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
 3043              		.loc 1 2587 0
 3044 0002 0D46     		mov	r5, r1
 3045 0004 0446     		mov	r4, r0
2593:FreeRTOS/Source/tasks.c **** 	{
 3046              		.loc 1 2593 0
 3047 0006 FFF7FEFF 		bl	vPortEnterCritical
 3048              	.LVL297:
 3049              	.LBB123:
2602:FreeRTOS/Source/tasks.c **** 			{
 3050              		.loc 1 2602 0
 3051 000a 2B68     		ldr	r3, [r5]
2596:FreeRTOS/Source/tasks.c **** 
 3052              		.loc 1 2596 0
 3053 000c 1249     		ldr	r1, .L351
2602:FreeRTOS/Source/tasks.c **** 			{
 3054              		.loc 1 2602 0
 3055 000e 5A1C     		adds	r2, r3, #1
2596:FreeRTOS/Source/tasks.c **** 
 3056              		.loc 1 2596 0
 3057 0010 0868     		ldr	r0, [r1]
 3058              	.LVL298:
2602:FreeRTOS/Source/tasks.c **** 			{
 3059              		.loc 1 2602 0
 3060 0012 1BD0     		beq	.L347
2609:FreeRTOS/Source/tasks.c **** 		{
 3061              		.loc 1 2609 0
 3062 0014 114E     		ldr	r6, .L351+4
 3063 0016 2768     		ldr	r7, [r4]
 3064 0018 3268     		ldr	r2, [r6]
 3065 001a 9742     		cmp	r7, r2
 3066 001c 6268     		ldr	r2, [r4, #4]
 3067 001e 01D0     		beq	.L346
2609:FreeRTOS/Source/tasks.c **** 		{
 3068              		.loc 1 2609 0 is_stmt 0 discriminator 1
 3069 0020 9042     		cmp	r0, r2
 3070 0022 0ED2     		bcs	.L349
 3071              	.L346:
2617:FreeRTOS/Source/tasks.c **** 		{
 3072              		.loc 1 2617 0 is_stmt 1
 3073 0024 871A     		subs	r7, r0, r2
 3074 0026 BB42     		cmp	r3, r7
 3075 0028 0BD9     		bls	.L349
 3076 002a 1B1A     		subs	r3, r3, r0
2620:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3077              		.loc 1 2620 0
 3078 002c 1344     		add	r3, r3, r2
 3079              	.LBB124:
 3080              	.LBB125:
2581:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3081              		.loc 1 2581 0
 3082 002e 3068     		ldr	r0, [r6]
 3083              	.LVL299:
2582:FreeRTOS/Source/tasks.c **** }
 3084              		.loc 1 2582 0
 3085 0030 0A68     		ldr	r2, [r1]
 3086              	.LBE125:
 3087              	.LBE124:
2620:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3088              		.loc 1 2620 0
 3089 0032 2B60     		str	r3, [r5]
 3090              	.LVL300:
 3091              	.LBB127:
 3092              	.LBB126:
2582:FreeRTOS/Source/tasks.c **** }
 3093              		.loc 1 2582 0
 3094 0034 84E80500 		stmia	r4, {r0, r2}
 3095              	.LVL301:
 3096              	.LBE126:
 3097              	.LBE127:
2622:FreeRTOS/Source/tasks.c **** 		}
 3098              		.loc 1 2622 0
 3099 0038 0025     		movs	r5, #0
 3100              	.LVL302:
 3101              	.LBE123:
2629:FreeRTOS/Source/tasks.c **** 
 3102              		.loc 1 2629 0
 3103 003a FFF7FEFF 		bl	vPortExitCritical
 3104              	.LVL303:
2632:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3105              		.loc 1 2632 0
 3106 003e 2846     		mov	r0, r5
 3107 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3108              	.LVL304:
 3109              	.L349:
 3110              	.LBB128:
2615:FreeRTOS/Source/tasks.c **** 		}
 3111              		.loc 1 2615 0
 3112 0042 0125     		movs	r5, #1
 3113              	.LVL305:
 3114              	.LBE128:
2629:FreeRTOS/Source/tasks.c **** 
 3115              		.loc 1 2629 0
 3116 0044 FFF7FEFF 		bl	vPortExitCritical
 3117              	.LVL306:
2632:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3118              		.loc 1 2632 0
 3119 0048 2846     		mov	r0, r5
 3120 004a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3121              	.LVL307:
 3122              	.L347:
 3123              	.LBB129:
2604:FreeRTOS/Source/tasks.c **** 			}
 3124              		.loc 1 2604 0
 3125 004c 0025     		movs	r5, #0
 3126              	.LVL308:
 3127              	.LBE129:
2629:FreeRTOS/Source/tasks.c **** 
 3128              		.loc 1 2629 0
 3129 004e FFF7FEFF 		bl	vPortExitCritical
 3130              	.LVL309:
2632:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 3131              		.loc 1 2632 0
 3132 0052 2846     		mov	r0, r5
 3133 0054 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3134              	.LVL310:
 3135              	.L352:
 3136 0056 00BF     		.align	2
 3137              	.L351:
 3138 0058 00000000 		.word	.LANCHOR3
 3139 005c 00000000 		.word	.LANCHOR21
 3140              		.cfi_endproc
 3141              	.LFE139:
 3143              		.section	.text.vTaskMissedYield,"ax",%progbits
 3144              		.align	2
 3145              		.global	vTaskMissedYield
 3146              		.thumb
 3147              		.thumb_func
 3149              	vTaskMissedYield:
 3150              	.LFB140:
2636:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 3151              		.loc 1 2636 0
 3152              		.cfi_startproc
 3153              		@ args = 0, pretend = 0, frame = 0
 3154              		@ frame_needed = 0, uses_anonymous_args = 0
 3155              		@ link register save eliminated.
2637:FreeRTOS/Source/tasks.c **** }
 3156              		.loc 1 2637 0
 3157 0000 014B     		ldr	r3, .L354
 3158 0002 0122     		movs	r2, #1
 3159 0004 1A60     		str	r2, [r3]
 3160 0006 7047     		bx	lr
 3161              	.L355:
 3162              		.align	2
 3163              	.L354:
 3164 0008 00000000 		.word	.LANCHOR5
 3165              		.cfi_endproc
 3166              	.LFE140:
 3168              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3169              		.align	2
 3170              		.global	uxTaskGetStackHighWaterMark
 3171              		.thumb
 3172              		.thumb_func
 3174              	uxTaskGetStackHighWaterMark:
 3175              	.LFB148:
3284:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
 3176              		.loc 1 3284 0
 3177              		.cfi_startproc
 3178              		@ args = 0, pretend = 0, frame = 0
 3179              		@ frame_needed = 0, uses_anonymous_args = 0
 3180              		@ link register save eliminated.
 3181              	.LVL311:
3289:FreeRTOS/Source/tasks.c **** 
 3182              		.loc 1 3289 0
 3183 0000 60B1     		cbz	r0, .L363
 3184              	.LVL312:
 3185              	.L357:
3293:FreeRTOS/Source/tasks.c **** 		}
 3186              		.loc 1 3293 0 discriminator 4
 3187 0002 016B     		ldr	r1, [r0, #48]
 3188              	.LVL313:
 3189              	.LBB130:
 3190              	.LBB131:
3267:FreeRTOS/Source/tasks.c **** 		{
 3191              		.loc 1 3267 0 discriminator 4
 3192 0004 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 3193 0006 A52B     		cmp	r3, #165
 3194 0008 0BD1     		bne	.L360
 3195 000a 4B1C     		adds	r3, r1, #1
 3196              	.LVL314:
 3197              	.L359:
 3198 000c 581A     		subs	r0, r3, r1
 3199              	.LVL315:
3267:FreeRTOS/Source/tasks.c **** 		{
 3200              		.loc 1 3267 0 is_stmt 0
 3201 000e 13F8012B 		ldrb	r2, [r3], #1	@ zero_extendqisi2
 3202              	.LVL316:
 3203 0012 A52A     		cmp	r2, #165
 3204 0014 FAD0     		beq	.L359
 3205 0016 C0F38F00 		ubfx	r0, r0, #2, #16
 3206              	.LVL317:
 3207 001a 7047     		bx	lr
 3208              	.LVL318:
 3209              	.L363:
 3210              	.LBE131:
 3211              	.LBE130:
3289:FreeRTOS/Source/tasks.c **** 
 3212              		.loc 1 3289 0 is_stmt 1 discriminator 1
 3213 001c 024B     		ldr	r3, .L364
 3214 001e 1868     		ldr	r0, [r3]
 3215              	.LVL319:
 3216 0020 EFE7     		b	.L357
 3217              	.LVL320:
 3218              	.L360:
 3219              	.LBB133:
 3220              	.LBB132:
3267:FreeRTOS/Source/tasks.c **** 		{
 3221              		.loc 1 3267 0
 3222 0022 0020     		movs	r0, #0
 3223              	.LVL321:
 3224              	.LBE132:
 3225              	.LBE133:
3304:FreeRTOS/Source/tasks.c **** 
 3226              		.loc 1 3304 0
 3227 0024 7047     		bx	lr
 3228              	.L365:
 3229 0026 00BF     		.align	2
 3230              	.L364:
 3231 0028 00000000 		.word	.LANCHOR2
 3232              		.cfi_endproc
 3233              	.LFE148:
 3235              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3236              		.align	2
 3237              		.global	xTaskGetCurrentTaskHandle
 3238              		.thumb
 3239              		.thumb_func
 3241              	xTaskGetCurrentTaskHandle:
 3242              	.LFB151:
3367:FreeRTOS/Source/tasks.c **** 	}
3368:FreeRTOS/Source/tasks.c **** }
3369:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3370:FreeRTOS/Source/tasks.c **** 
3371:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3372:FreeRTOS/Source/tasks.c **** 
3373:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3374:FreeRTOS/Source/tasks.c **** 	{
 3243              		.loc 1 3374 0
 3244              		.cfi_startproc
 3245              		@ args = 0, pretend = 0, frame = 0
 3246              		@ frame_needed = 0, uses_anonymous_args = 0
 3247              		@ link register save eliminated.
3375:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3376:FreeRTOS/Source/tasks.c **** 
3377:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3378:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3379:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3380:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3248              		.loc 1 3380 0
 3249 0000 014B     		ldr	r3, .L367
 3250 0002 1868     		ldr	r0, [r3]
 3251              	.LVL322:
3381:FreeRTOS/Source/tasks.c **** 
3382:FreeRTOS/Source/tasks.c **** 		return xReturn;
3383:FreeRTOS/Source/tasks.c **** 	}
 3252              		.loc 1 3383 0
 3253 0004 7047     		bx	lr
 3254              	.L368:
 3255 0006 00BF     		.align	2
 3256              	.L367:
 3257 0008 00000000 		.word	.LANCHOR2
 3258              		.cfi_endproc
 3259              	.LFE151:
 3261              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3262              		.align	2
 3263              		.global	vTaskPriorityInherit
 3264              		.thumb
 3265              		.thumb_func
 3267              	vTaskPriorityInherit:
 3268              	.LFB152:
3384:FreeRTOS/Source/tasks.c **** 
3385:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3386:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3387:FreeRTOS/Source/tasks.c **** 
3388:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3389:FreeRTOS/Source/tasks.c **** 
3390:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3391:FreeRTOS/Source/tasks.c **** 	{
3392:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3393:FreeRTOS/Source/tasks.c **** 
3394:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3395:FreeRTOS/Source/tasks.c **** 		{
3396:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3397:FreeRTOS/Source/tasks.c **** 		}
3398:FreeRTOS/Source/tasks.c **** 		else
3399:FreeRTOS/Source/tasks.c **** 		{
3400:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3401:FreeRTOS/Source/tasks.c **** 			{
3402:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3403:FreeRTOS/Source/tasks.c **** 			}
3404:FreeRTOS/Source/tasks.c **** 			else
3405:FreeRTOS/Source/tasks.c **** 			{
3406:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3407:FreeRTOS/Source/tasks.c **** 			}
3408:FreeRTOS/Source/tasks.c **** 		}
3409:FreeRTOS/Source/tasks.c **** 
3410:FreeRTOS/Source/tasks.c **** 		return xReturn;
3411:FreeRTOS/Source/tasks.c **** 	}
3412:FreeRTOS/Source/tasks.c **** 
3413:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3414:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3415:FreeRTOS/Source/tasks.c **** 
3416:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3417:FreeRTOS/Source/tasks.c **** 
3418:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3419:FreeRTOS/Source/tasks.c **** 	{
 3269              		.loc 1 3419 0
 3270              		.cfi_startproc
 3271              		@ args = 0, pretend = 0, frame = 0
 3272              		@ frame_needed = 0, uses_anonymous_args = 0
 3273              	.LVL323:
3420:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3421:FreeRTOS/Source/tasks.c **** 
3422:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3423:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3424:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3274              		.loc 1 3424 0
 3275 0000 0028     		cmp	r0, #0
 3276 0002 30D0     		beq	.L381
3419:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3277              		.loc 1 3419 0
 3278 0004 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3279              	.LCFI53:
 3280              		.cfi_def_cfa_offset 24
 3281              		.cfi_offset 3, -24
 3282              		.cfi_offset 4, -20
 3283              		.cfi_offset 5, -16
 3284              		.cfi_offset 6, -12
 3285              		.cfi_offset 7, -8
 3286              		.cfi_offset 14, -4
3425:FreeRTOS/Source/tasks.c **** 		{
3426:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3427:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3428:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3429:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3287              		.loc 1 3429 0
 3288 0006 184C     		ldr	r4, .L384
 3289 0008 C36A     		ldr	r3, [r0, #44]
 3290 000a 2268     		ldr	r2, [r4]
 3291 000c D26A     		ldr	r2, [r2, #44]
 3292 000e 9342     		cmp	r3, r2
 3293 0010 12D2     		bcs	.L369
3430:FreeRTOS/Source/tasks.c **** 			{
3431:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3432:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3433:FreeRTOS/Source/tasks.c **** 				not	being used for anything else. */
3434:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3294              		.loc 1 3434 0
 3295 0012 8269     		ldr	r2, [r0, #24]
 3296 0014 002A     		cmp	r2, #0
 3297 0016 04DB     		blt	.L371
3435:FreeRTOS/Source/tasks.c **** 				{
3436:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3298              		.loc 1 3436 0
 3299 0018 2268     		ldr	r2, [r4]
 3300 001a D26A     		ldr	r2, [r2, #44]
 3301 001c C2F10502 		rsb	r2, r2, #5
 3302 0020 8261     		str	r2, [r0, #24]
 3303              	.L371:
3437:FreeRTOS/Source/tasks.c **** 				}
3438:FreeRTOS/Source/tasks.c **** 				else
3439:FreeRTOS/Source/tasks.c **** 				{
3440:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3441:FreeRTOS/Source/tasks.c **** 				}
3442:FreeRTOS/Source/tasks.c **** 
3443:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3444:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
3445:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 3304              		.loc 1 3445 0
 3305 0022 124D     		ldr	r5, .L384+4
 3306 0024 4269     		ldr	r2, [r0, #20]
 3307 0026 03EB8303 		add	r3, r3, r3, lsl #2
 3308 002a 05EB8303 		add	r3, r5, r3, lsl #2
 3309 002e 9A42     		cmp	r2, r3
 3310 0030 03D0     		beq	.L383
3446:FreeRTOS/Source/tasks.c **** 				{
3447:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
3448:FreeRTOS/Source/tasks.c **** 					{
3449:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3450:FreeRTOS/Source/tasks.c **** 					}
3451:FreeRTOS/Source/tasks.c **** 					else
3452:FreeRTOS/Source/tasks.c **** 					{
3453:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3454:FreeRTOS/Source/tasks.c **** 					}
3455:FreeRTOS/Source/tasks.c **** 
3456:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3457:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
3458:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
3459:FreeRTOS/Source/tasks.c **** 				}
3460:FreeRTOS/Source/tasks.c **** 				else
3461:FreeRTOS/Source/tasks.c **** 				{
3462:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
3463:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3311              		.loc 1 3463 0
 3312 0032 2368     		ldr	r3, [r4]
 3313 0034 DB6A     		ldr	r3, [r3, #44]
 3314 0036 C362     		str	r3, [r0, #44]
 3315              	.L369:
 3316 0038 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3317              	.L383:
3447:FreeRTOS/Source/tasks.c **** 					{
 3318              		.loc 1 3447 0
 3319 003a 061D     		adds	r6, r0, #4
 3320 003c 0746     		mov	r7, r0
 3321 003e 3046     		mov	r0, r6
 3322              	.LVL324:
 3323 0040 FFF7FEFF 		bl	uxListRemove
 3324              	.LVL325:
3457:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3325              		.loc 1 3457 0
 3326 0044 2268     		ldr	r2, [r4]
3458:FreeRTOS/Source/tasks.c **** 				}
 3327              		.loc 1 3458 0
 3328 0046 0A4B     		ldr	r3, .L384+8
3457:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3329              		.loc 1 3457 0
 3330 0048 D06A     		ldr	r0, [r2, #44]
3458:FreeRTOS/Source/tasks.c **** 				}
 3331              		.loc 1 3458 0
 3332 004a 1A68     		ldr	r2, [r3]
3457:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3333              		.loc 1 3457 0
 3334 004c F862     		str	r0, [r7, #44]
3458:FreeRTOS/Source/tasks.c **** 				}
 3335              		.loc 1 3458 0
 3336 004e 9042     		cmp	r0, r2
 3337 0050 00D9     		bls	.L375
3458:FreeRTOS/Source/tasks.c **** 				}
 3338              		.loc 1 3458 0 is_stmt 0 discriminator 1
 3339 0052 1860     		str	r0, [r3]
 3340              	.L375:
3458:FreeRTOS/Source/tasks.c **** 				}
 3341              		.loc 1 3458 0 discriminator 3
 3342 0054 00EB8000 		add	r0, r0, r0, lsl #2
 3343 0058 05EB8000 		add	r0, r5, r0, lsl #2
 3344 005c 3146     		mov	r1, r6
3464:FreeRTOS/Source/tasks.c **** 				}
3465:FreeRTOS/Source/tasks.c **** 
3466:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3467:FreeRTOS/Source/tasks.c **** 			}
3468:FreeRTOS/Source/tasks.c **** 			else
3469:FreeRTOS/Source/tasks.c **** 			{
3470:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3471:FreeRTOS/Source/tasks.c **** 			}
3472:FreeRTOS/Source/tasks.c **** 		}
3473:FreeRTOS/Source/tasks.c **** 		else
3474:FreeRTOS/Source/tasks.c **** 		{
3475:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3476:FreeRTOS/Source/tasks.c **** 		}
3477:FreeRTOS/Source/tasks.c **** 	}
 3345              		.loc 1 3477 0 is_stmt 1 discriminator 3
 3346 005e BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 3347              	.LCFI54:
 3348              		.cfi_restore 14
 3349              		.cfi_restore 7
 3350              		.cfi_restore 6
 3351              		.cfi_restore 5
 3352              		.cfi_restore 4
 3353              		.cfi_restore 3
 3354              		.cfi_def_cfa_offset 0
 3355              	.LVL326:
3458:FreeRTOS/Source/tasks.c **** 				}
 3356              		.loc 1 3458 0 discriminator 3
 3357 0062 FFF7FEBF 		b	vListInsertEnd
 3358              	.LVL327:
 3359              	.L381:
 3360 0066 7047     		bx	lr
 3361              	.L385:
 3362              		.align	2
 3363              	.L384:
 3364 0068 00000000 		.word	.LANCHOR2
 3365 006c 00000000 		.word	.LANCHOR9
 3366 0070 00000000 		.word	.LANCHOR8
 3367              		.cfi_endproc
 3368              	.LFE152:
 3370              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 3371              		.align	2
 3372              		.global	xTaskPriorityDisinherit
 3373              		.thumb
 3374              		.thumb_func
 3376              	xTaskPriorityDisinherit:
 3377              	.LFB153:
3478:FreeRTOS/Source/tasks.c **** 
3479:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3480:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3481:FreeRTOS/Source/tasks.c **** 
3482:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3483:FreeRTOS/Source/tasks.c **** 
3484:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3485:FreeRTOS/Source/tasks.c **** 	{
 3378              		.loc 1 3485 0
 3379              		.cfi_startproc
 3380              		@ args = 0, pretend = 0, frame = 0
 3381              		@ frame_needed = 0, uses_anonymous_args = 0
 3382              	.LVL328:
3486:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
3487:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
3488:FreeRTOS/Source/tasks.c **** 
3489:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3383              		.loc 1 3489 0
 3384 0000 18B3     		cbz	r0, .L394
3485:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3385              		.loc 1 3485 0
 3386 0002 38B5     		push	{r3, r4, r5, lr}
 3387              	.LCFI55:
 3388              		.cfi_def_cfa_offset 16
 3389              		.cfi_offset 3, -16
 3390              		.cfi_offset 4, -12
 3391              		.cfi_offset 5, -8
 3392              		.cfi_offset 14, -4
3490:FreeRTOS/Source/tasks.c **** 		{
3491:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3492:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3493:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3494:FreeRTOS/Source/tasks.c **** 			be the running state task. */
3495:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3496:FreeRTOS/Source/tasks.c **** 
3497:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3498:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
3499:FreeRTOS/Source/tasks.c **** 
3500:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3501:FreeRTOS/Source/tasks.c **** 			task? */
3502:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3393              		.loc 1 3502 0
 3394 0004 C16A     		ldr	r1, [r0, #44]
3498:FreeRTOS/Source/tasks.c **** 
 3395              		.loc 1 3498 0
 3396 0006 836C     		ldr	r3, [r0, #72]
 3397              		.loc 1 3502 0
 3398 0008 426C     		ldr	r2, [r0, #68]
3498:FreeRTOS/Source/tasks.c **** 
 3399              		.loc 1 3498 0
 3400 000a 013B     		subs	r3, r3, #1
 3401              		.loc 1 3502 0
 3402 000c 9142     		cmp	r1, r2
3498:FreeRTOS/Source/tasks.c **** 
 3403              		.loc 1 3498 0
 3404 000e 8364     		str	r3, [r0, #72]
 3405              		.loc 1 3502 0
 3406 0010 00D0     		beq	.L389
3503:FreeRTOS/Source/tasks.c **** 			{
3504:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3505:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 3407              		.loc 1 3505 0
 3408 0012 0BB1     		cbz	r3, .L395
 3409              	.L389:
3487:FreeRTOS/Source/tasks.c **** 
 3410              		.loc 1 3487 0
 3411 0014 0020     		movs	r0, #0
 3412              	.LVL329:
 3413 0016 38BD     		pop	{r3, r4, r5, pc}
 3414              	.LVL330:
 3415              	.L395:
3506:FreeRTOS/Source/tasks.c **** 				{
3507:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3508:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3509:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3510:FreeRTOS/Source/tasks.c **** 					holding	task then it must be the running state task.  Remove
3511:FreeRTOS/Source/tasks.c **** 					the	holding task from the ready	list. */
3512:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 3416              		.loc 1 3512 0
 3417 0018 051D     		adds	r5, r0, #4
 3418 001a 0446     		mov	r4, r0
 3419 001c 2846     		mov	r0, r5
 3420              	.LVL331:
 3421 001e FFF7FEFF 		bl	uxListRemove
 3422              	.LVL332:
3513:FreeRTOS/Source/tasks.c **** 					{
3514:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3515:FreeRTOS/Source/tasks.c **** 					}
3516:FreeRTOS/Source/tasks.c **** 					else
3517:FreeRTOS/Source/tasks.c **** 					{
3518:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3519:FreeRTOS/Source/tasks.c **** 					}
3520:FreeRTOS/Source/tasks.c **** 
3521:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3522:FreeRTOS/Source/tasks.c **** 					new	ready list. */
3523:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3524:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
3525:FreeRTOS/Source/tasks.c **** 
3526:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3527:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
3528:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
3529:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
3530:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3423              		.loc 1 3530 0
 3424 0022 0B4A     		ldr	r2, .L396
3524:FreeRTOS/Source/tasks.c **** 
 3425              		.loc 1 3524 0
 3426 0024 636C     		ldr	r3, [r4, #68]
 3427              		.loc 1 3530 0
 3428 0026 1168     		ldr	r1, [r2]
3524:FreeRTOS/Source/tasks.c **** 
 3429              		.loc 1 3524 0
 3430 0028 E362     		str	r3, [r4, #44]
3529:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3431              		.loc 1 3529 0
 3432 002a C3F10500 		rsb	r0, r3, #5
 3433              		.loc 1 3530 0
 3434 002e 8B42     		cmp	r3, r1
3529:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3435              		.loc 1 3529 0
 3436 0030 A061     		str	r0, [r4, #24]
 3437              		.loc 1 3530 0
 3438 0032 0848     		ldr	r0, .L396+4
 3439 0034 88BF     		it	hi
 3440 0036 1360     		strhi	r3, [r2]
 3441 0038 03EB8303 		add	r3, r3, r3, lsl #2
 3442 003c 00EB8300 		add	r0, r0, r3, lsl #2
 3443 0040 2946     		mov	r1, r5
 3444 0042 FFF7FEFF 		bl	vListInsertEnd
 3445              	.LVL333:
3531:FreeRTOS/Source/tasks.c **** 
3532:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3533:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
3534:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3535:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
3536:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
3537:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
3538:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
3539:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
3540:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 3446              		.loc 1 3540 0
 3447 0046 0120     		movs	r0, #1
 3448              	.LVL334:
3541:FreeRTOS/Source/tasks.c **** 				}
3542:FreeRTOS/Source/tasks.c **** 				else
3543:FreeRTOS/Source/tasks.c **** 				{
3544:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3545:FreeRTOS/Source/tasks.c **** 				}
3546:FreeRTOS/Source/tasks.c **** 			}
3547:FreeRTOS/Source/tasks.c **** 			else
3548:FreeRTOS/Source/tasks.c **** 			{
3549:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3550:FreeRTOS/Source/tasks.c **** 			}
3551:FreeRTOS/Source/tasks.c **** 		}
3552:FreeRTOS/Source/tasks.c **** 		else
3553:FreeRTOS/Source/tasks.c **** 		{
3554:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3555:FreeRTOS/Source/tasks.c **** 		}
3556:FreeRTOS/Source/tasks.c **** 
3557:FreeRTOS/Source/tasks.c **** 		return xReturn;
3558:FreeRTOS/Source/tasks.c **** 	}
 3449              		.loc 1 3558 0
 3450 0048 38BD     		pop	{r3, r4, r5, pc}
 3451              	.LVL335:
 3452              	.L394:
 3453              	.LCFI56:
 3454              		.cfi_def_cfa_offset 0
 3455              		.cfi_restore 3
 3456              		.cfi_restore 4
 3457              		.cfi_restore 5
 3458              		.cfi_restore 14
3487:FreeRTOS/Source/tasks.c **** 
 3459              		.loc 1 3487 0
 3460 004a 0020     		movs	r0, #0
 3461              	.LVL336:
 3462              		.loc 1 3558 0
 3463 004c 7047     		bx	lr
 3464              	.L397:
 3465 004e 00BF     		.align	2
 3466              	.L396:
 3467 0050 00000000 		.word	.LANCHOR8
 3468 0054 00000000 		.word	.LANCHOR9
 3469              		.cfi_endproc
 3470              	.LFE153:
 3472              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 3473              		.align	2
 3474              		.global	uxTaskResetEventItemValue
 3475              		.thumb
 3476              		.thumb_func
 3478              	uxTaskResetEventItemValue:
 3479              	.LFB154:
3559:FreeRTOS/Source/tasks.c **** 
3560:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3561:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3562:FreeRTOS/Source/tasks.c **** 
3563:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3564:FreeRTOS/Source/tasks.c **** 
3565:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
3566:FreeRTOS/Source/tasks.c **** 	{
3567:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3568:FreeRTOS/Source/tasks.c **** 
3569:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3570:FreeRTOS/Source/tasks.c **** 		{
3571:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3572:FreeRTOS/Source/tasks.c **** 
3573:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3574:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
3575:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3576:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3577:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
3578:FreeRTOS/Source/tasks.c **** 			critical section. */
3579:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3580:FreeRTOS/Source/tasks.c **** 			{
3581:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
3582:FreeRTOS/Source/tasks.c **** 			}
3583:FreeRTOS/Source/tasks.c **** 		}
3584:FreeRTOS/Source/tasks.c **** 		else
3585:FreeRTOS/Source/tasks.c **** 		{
3586:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3587:FreeRTOS/Source/tasks.c **** 		}
3588:FreeRTOS/Source/tasks.c **** 	}
3589:FreeRTOS/Source/tasks.c **** 
3590:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3591:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3592:FreeRTOS/Source/tasks.c **** 
3593:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3594:FreeRTOS/Source/tasks.c **** 
3595:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
3596:FreeRTOS/Source/tasks.c **** 	{
3597:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3598:FreeRTOS/Source/tasks.c **** 		{
3599:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3600:FreeRTOS/Source/tasks.c **** 			{
3601:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3602:FreeRTOS/Source/tasks.c **** 
3603:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3604:FreeRTOS/Source/tasks.c **** 				{
3605:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
3606:FreeRTOS/Source/tasks.c **** 				}
3607:FreeRTOS/Source/tasks.c **** 				else
3608:FreeRTOS/Source/tasks.c **** 				{
3609:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3610:FreeRTOS/Source/tasks.c **** 				}
3611:FreeRTOS/Source/tasks.c **** 			}
3612:FreeRTOS/Source/tasks.c **** 			else
3613:FreeRTOS/Source/tasks.c **** 			{
3614:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3615:FreeRTOS/Source/tasks.c **** 			}
3616:FreeRTOS/Source/tasks.c **** 		}
3617:FreeRTOS/Source/tasks.c **** 		else
3618:FreeRTOS/Source/tasks.c **** 		{
3619:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3620:FreeRTOS/Source/tasks.c **** 		}
3621:FreeRTOS/Source/tasks.c **** 	}
3622:FreeRTOS/Source/tasks.c **** 
3623:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3624:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3625:FreeRTOS/Source/tasks.c **** 
3626:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3627:FreeRTOS/Source/tasks.c **** 
3628:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3629:FreeRTOS/Source/tasks.c **** 	{
3630:FreeRTOS/Source/tasks.c **** 	size_t x;
3631:FreeRTOS/Source/tasks.c **** 
3632:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
3633:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3634:FreeRTOS/Source/tasks.c **** 
3635:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3636:FreeRTOS/Source/tasks.c **** 		printed out. */
3637:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3638:FreeRTOS/Source/tasks.c **** 		{
3639:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
3640:FreeRTOS/Source/tasks.c **** 		}
3641:FreeRTOS/Source/tasks.c **** 
3642:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
3643:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = 0x00;
3644:FreeRTOS/Source/tasks.c **** 
3645:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
3646:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
3647:FreeRTOS/Source/tasks.c **** 	}
3648:FreeRTOS/Source/tasks.c **** 
3649:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3650:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3651:FreeRTOS/Source/tasks.c **** 
3652:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3653:FreeRTOS/Source/tasks.c **** 
3654:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3655:FreeRTOS/Source/tasks.c **** 	{
3656:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3657:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3658:FreeRTOS/Source/tasks.c **** 	char cStatus;
3659:FreeRTOS/Source/tasks.c **** 
3660:FreeRTOS/Source/tasks.c **** 		/*
3661:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3662:FreeRTOS/Source/tasks.c **** 		 *
3663:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3664:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3665:FreeRTOS/Source/tasks.c **** 		 * scheduler.
3666:FreeRTOS/Source/tasks.c **** 		 *
3667:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3668:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3669:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
3670:FreeRTOS/Source/tasks.c **** 		 *
3671:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3672:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3673:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3674:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3675:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3676:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3677:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
3678:FreeRTOS/Source/tasks.c **** 		 *
3679:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3680:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3681:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
3682:FreeRTOS/Source/tasks.c **** 		 */
3683:FreeRTOS/Source/tasks.c **** 
3684:FreeRTOS/Source/tasks.c **** 
3685:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3686:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3687:FreeRTOS/Source/tasks.c **** 
3688:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3689:FreeRTOS/Source/tasks.c **** 		function is executing. */
3690:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3691:FreeRTOS/Source/tasks.c **** 
3692:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3693:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3694:FreeRTOS/Source/tasks.c **** 
3695:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3696:FreeRTOS/Source/tasks.c **** 		{
3697:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3698:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3699:FreeRTOS/Source/tasks.c **** 
3700:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3701:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3702:FreeRTOS/Source/tasks.c **** 			{
3703:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3704:FreeRTOS/Source/tasks.c **** 				{
3705:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3706:FreeRTOS/Source/tasks.c **** 										break;
3707:FreeRTOS/Source/tasks.c **** 
3708:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3709:FreeRTOS/Source/tasks.c **** 										break;
3710:FreeRTOS/Source/tasks.c **** 
3711:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
3712:FreeRTOS/Source/tasks.c **** 										break;
3713:FreeRTOS/Source/tasks.c **** 
3714:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
3715:FreeRTOS/Source/tasks.c **** 										break;
3716:FreeRTOS/Source/tasks.c **** 
3717:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
3718:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
3719:FreeRTOS/Source/tasks.c **** 										cStatus = 0x00;
3720:FreeRTOS/Source/tasks.c **** 										break;
3721:FreeRTOS/Source/tasks.c **** 				}
3722:FreeRTOS/Source/tasks.c **** 
3723:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
3724:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
3725:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3726:FreeRTOS/Source/tasks.c **** 
3727:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
3728:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
3729:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
3730:FreeRTOS/Source/tasks.c **** 			}
3731:FreeRTOS/Source/tasks.c **** 
3732:FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3733:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3734:FreeRTOS/Source/tasks.c **** 		}
3735:FreeRTOS/Source/tasks.c **** 		else
3736:FreeRTOS/Source/tasks.c **** 		{
3737:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3738:FreeRTOS/Source/tasks.c **** 		}
3739:FreeRTOS/Source/tasks.c **** 	}
3740:FreeRTOS/Source/tasks.c **** 
3741:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
3742:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
3743:FreeRTOS/Source/tasks.c **** 
3744:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3745:FreeRTOS/Source/tasks.c **** 
3746:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3747:FreeRTOS/Source/tasks.c **** 	{
3748:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3749:FreeRTOS/Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3750:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
3751:FreeRTOS/Source/tasks.c **** 
3752:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
3753:FreeRTOS/Source/tasks.c **** 		{
3754:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
3755:FreeRTOS/Source/tasks.c **** 		}
3756:FreeRTOS/Source/tasks.c **** 		#endif
3757:FreeRTOS/Source/tasks.c **** 
3758:FreeRTOS/Source/tasks.c **** 		/*
3759:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
3760:FreeRTOS/Source/tasks.c **** 		 *
3761:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3762:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3763:FreeRTOS/Source/tasks.c **** 		 * scheduler.
3764:FreeRTOS/Source/tasks.c **** 		 *
3765:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3766:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
3767:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
3768:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
3769:FreeRTOS/Source/tasks.c **** 		 *
3770:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3771:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
3772:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
3773:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
3774:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3775:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3776:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
3777:FreeRTOS/Source/tasks.c **** 		 *
3778:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3779:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
3780:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
3781:FreeRTOS/Source/tasks.c **** 		 */
3782:FreeRTOS/Source/tasks.c **** 
3783:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3784:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3785:FreeRTOS/Source/tasks.c **** 
3786:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3787:FreeRTOS/Source/tasks.c **** 		function is executing. */
3788:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3789:FreeRTOS/Source/tasks.c **** 
3790:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task. */
3791:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3792:FreeRTOS/Source/tasks.c **** 
3793:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3794:FreeRTOS/Source/tasks.c **** 		{
3795:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
3796:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3797:FreeRTOS/Source/tasks.c **** 
3798:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
3799:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
3800:FreeRTOS/Source/tasks.c **** 
3801:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
3802:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0 )
3803:FreeRTOS/Source/tasks.c **** 			{
3804:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
3805:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
3806:FreeRTOS/Source/tasks.c **** 				{
3807:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
3808:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
3809:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
3810:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3811:FreeRTOS/Source/tasks.c **** 
3812:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
3813:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
3814:FreeRTOS/Source/tasks.c **** 					easily. */
3815:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
3818:FreeRTOS/Source/tasks.c **** 					{
3819:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3820:FreeRTOS/Source/tasks.c **** 						{
3821:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
3822:FreeRTOS/Source/tasks.c **** 						}
3823:FreeRTOS/Source/tasks.c **** 						#else
3824:FreeRTOS/Source/tasks.c **** 						{
3825:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3826:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3827:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3828:FreeRTOS/Source/tasks.c **** 						}
3829:FreeRTOS/Source/tasks.c **** 						#endif
3830:FreeRTOS/Source/tasks.c **** 					}
3831:FreeRTOS/Source/tasks.c **** 					else
3832:FreeRTOS/Source/tasks.c **** 					{
3833:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
3834:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
3835:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3836:FreeRTOS/Source/tasks.c **** 						{
3837:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
3838:FreeRTOS/Source/tasks.c **** 						}
3839:FreeRTOS/Source/tasks.c **** 						#else
3840:FreeRTOS/Source/tasks.c **** 						{
3841:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
3842:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
3843:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
3844:FreeRTOS/Source/tasks.c **** 						}
3845:FreeRTOS/Source/tasks.c **** 						#endif
3846:FreeRTOS/Source/tasks.c **** 					}
3847:FreeRTOS/Source/tasks.c **** 
3848:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
3849:FreeRTOS/Source/tasks.c **** 				}
3850:FreeRTOS/Source/tasks.c **** 			}
3851:FreeRTOS/Source/tasks.c **** 			else
3852:FreeRTOS/Source/tasks.c **** 			{
3853:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3854:FreeRTOS/Source/tasks.c **** 			}
3855:FreeRTOS/Source/tasks.c **** 
3856:FreeRTOS/Source/tasks.c **** 			/* Free the array again. */
3857:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
3858:FreeRTOS/Source/tasks.c **** 		}
3859:FreeRTOS/Source/tasks.c **** 		else
3860:FreeRTOS/Source/tasks.c **** 		{
3861:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3862:FreeRTOS/Source/tasks.c **** 		}
3863:FreeRTOS/Source/tasks.c **** 	}
3864:FreeRTOS/Source/tasks.c **** 
3865:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
3866:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3867:FreeRTOS/Source/tasks.c **** 
3868:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
3869:FreeRTOS/Source/tasks.c **** {
 3480              		.loc 1 3869 0
 3481              		.cfi_startproc
 3482              		@ args = 0, pretend = 0, frame = 0
 3483              		@ frame_needed = 0, uses_anonymous_args = 0
 3484              		@ link register save eliminated.
3870:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
3871:FreeRTOS/Source/tasks.c **** 
3872:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 3485              		.loc 1 3872 0
 3486 0000 044B     		ldr	r3, .L399
 3487 0002 1968     		ldr	r1, [r3]
3873:FreeRTOS/Source/tasks.c **** 
3874:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
3875:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
3876:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 3488              		.loc 1 3876 0
 3489 0004 1A68     		ldr	r2, [r3]
 3490 0006 1B68     		ldr	r3, [r3]
3872:FreeRTOS/Source/tasks.c **** 
 3491              		.loc 1 3872 0
 3492 0008 8869     		ldr	r0, [r1, #24]
 3493              	.LVL337:
 3494              		.loc 1 3876 0
 3495 000a DB6A     		ldr	r3, [r3, #44]
 3496 000c C3F10503 		rsb	r3, r3, #5
 3497 0010 9361     		str	r3, [r2, #24]
3877:FreeRTOS/Source/tasks.c **** 
3878:FreeRTOS/Source/tasks.c **** 	return uxReturn;
3879:FreeRTOS/Source/tasks.c **** }
 3498              		.loc 1 3879 0
 3499 0012 7047     		bx	lr
 3500              	.L400:
 3501              		.align	2
 3502              	.L399:
 3503 0014 00000000 		.word	.LANCHOR2
 3504              		.cfi_endproc
 3505              	.LFE154:
 3507              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 3508              		.align	2
 3509              		.global	pvTaskIncrementMutexHeldCount
 3510              		.thumb
 3511              		.thumb_func
 3513              	pvTaskIncrementMutexHeldCount:
 3514              	.LFB155:
3880:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3881:FreeRTOS/Source/tasks.c **** 
3882:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3883:FreeRTOS/Source/tasks.c **** 
3884:FreeRTOS/Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
3885:FreeRTOS/Source/tasks.c **** 	{
 3515              		.loc 1 3885 0
 3516              		.cfi_startproc
 3517              		@ args = 0, pretend = 0, frame = 0
 3518              		@ frame_needed = 0, uses_anonymous_args = 0
 3519              		@ link register save eliminated.
3886:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
3887:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
3888:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
 3520              		.loc 1 3888 0
 3521 0000 044B     		ldr	r3, .L406
 3522 0002 1A68     		ldr	r2, [r3]
 3523 0004 1AB1     		cbz	r2, .L402
3889:FreeRTOS/Source/tasks.c **** 		{
3890:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 3524              		.loc 1 3890 0
 3525 0006 1968     		ldr	r1, [r3]
 3526 0008 8A6C     		ldr	r2, [r1, #72]
 3527 000a 0132     		adds	r2, r2, #1
 3528 000c 8A64     		str	r2, [r1, #72]
 3529              	.L402:
3891:FreeRTOS/Source/tasks.c **** 		}
3892:FreeRTOS/Source/tasks.c **** 
3893:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
 3530              		.loc 1 3893 0
 3531 000e 1868     		ldr	r0, [r3]
3894:FreeRTOS/Source/tasks.c **** 	}
 3532              		.loc 1 3894 0
 3533 0010 7047     		bx	lr
 3534              	.L407:
 3535 0012 00BF     		.align	2
 3536              	.L406:
 3537 0014 00000000 		.word	.LANCHOR2
 3538              		.cfi_endproc
 3539              	.LFE155:
 3541              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 3542              		.align	2
 3543              		.global	ulTaskNotifyTake
 3544              		.thumb
 3545              		.thumb_func
 3547              	ulTaskNotifyTake:
 3548              	.LFB156:
3895:FreeRTOS/Source/tasks.c **** 
3896:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
3897:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3898:FreeRTOS/Source/tasks.c **** 
3899:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
3900:FreeRTOS/Source/tasks.c **** 
3901:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
3902:FreeRTOS/Source/tasks.c **** 	{
 3549              		.loc 1 3902 0
 3550              		.cfi_startproc
 3551              		@ args = 0, pretend = 0, frame = 0
 3552              		@ frame_needed = 0, uses_anonymous_args = 0
 3553              	.LVL338:
 3554 0000 70B5     		push	{r4, r5, r6, lr}
 3555              	.LCFI57:
 3556              		.cfi_def_cfa_offset 16
 3557              		.cfi_offset 4, -16
 3558              		.cfi_offset 5, -12
 3559              		.cfi_offset 6, -8
 3560              		.cfi_offset 14, -4
3903:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
3904:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
3905:FreeRTOS/Source/tasks.c **** 
3906:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
3907:FreeRTOS/Source/tasks.c **** 		{
3908:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
3909:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 3561              		.loc 1 3909 0
 3562 0002 1D4C     		ldr	r4, .L426
3902:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 3563              		.loc 1 3902 0
 3564 0004 0646     		mov	r6, r0
 3565 0006 0D46     		mov	r5, r1
3906:FreeRTOS/Source/tasks.c **** 		{
 3566              		.loc 1 3906 0
 3567 0008 FFF7FEFF 		bl	vPortEnterCritical
 3568              	.LVL339:
 3569              		.loc 1 3909 0
 3570 000c 2368     		ldr	r3, [r4]
 3571 000e 5B6D     		ldr	r3, [r3, #84]
 3572 0010 23B9     		cbnz	r3, .L410
3910:FreeRTOS/Source/tasks.c **** 			{
3911:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
3912:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 3573              		.loc 1 3912 0
 3574 0012 2368     		ldr	r3, [r4]
 3575 0014 0122     		movs	r2, #1
 3576 0016 83F85820 		strb	r2, [r3, #88]
3913:FreeRTOS/Source/tasks.c **** 
3914:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3577              		.loc 1 3914 0
 3578 001a C5B9     		cbnz	r5, .L423
 3579              	.L410:
3915:FreeRTOS/Source/tasks.c **** 				{
3916:FreeRTOS/Source/tasks.c **** 					/* The task is going to block.  First it must be removed
3917:FreeRTOS/Source/tasks.c **** 					from the ready list. */
3918:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
3919:FreeRTOS/Source/tasks.c **** 					{
3920:FreeRTOS/Source/tasks.c **** 						/* The current task must be in a ready list, so there is
3921:FreeRTOS/Source/tasks.c **** 						no need to check, and the port reset macro can be called
3922:FreeRTOS/Source/tasks.c **** 						directly. */
3923:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
3924:FreeRTOS/Source/tasks.c **** 					}
3925:FreeRTOS/Source/tasks.c **** 					else
3926:FreeRTOS/Source/tasks.c **** 					{
3927:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3928:FreeRTOS/Source/tasks.c **** 					}
3929:FreeRTOS/Source/tasks.c **** 
3930:FreeRTOS/Source/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
3931:FreeRTOS/Source/tasks.c **** 					{
3932:FreeRTOS/Source/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
3933:FreeRTOS/Source/tasks.c **** 						{
3934:FreeRTOS/Source/tasks.c **** 							/* Add the task to the suspended task list instead
3935:FreeRTOS/Source/tasks.c **** 							of a delayed task list to ensure the task is not
3936:FreeRTOS/Source/tasks.c **** 							woken by a timing event.  It will block
3937:FreeRTOS/Source/tasks.c **** 							indefinitely. */
3938:FreeRTOS/Source/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
3939:FreeRTOS/Source/tasks.c **** 						}
3940:FreeRTOS/Source/tasks.c **** 						else
3941:FreeRTOS/Source/tasks.c **** 						{
3942:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3943:FreeRTOS/Source/tasks.c **** 							woken if no notification events occur.  This may
3944:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3945:FreeRTOS/Source/tasks.c **** 							handle it. */
3946:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
3947:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
3948:FreeRTOS/Source/tasks.c **** 						}
3949:FreeRTOS/Source/tasks.c **** 					}
3950:FreeRTOS/Source/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
3951:FreeRTOS/Source/tasks.c **** 					{
3952:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
3953:FreeRTOS/Source/tasks.c **** 							woken if the event does not occur.  This may
3954:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
3955:FreeRTOS/Source/tasks.c **** 							handle it. */
3956:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
3957:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
3958:FreeRTOS/Source/tasks.c **** 					}
3959:FreeRTOS/Source/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
3960:FreeRTOS/Source/tasks.c **** 
3961:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
3962:FreeRTOS/Source/tasks.c **** 
3963:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
3964:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
3965:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
3966:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
3967:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
3968:FreeRTOS/Source/tasks.c **** 				}
3969:FreeRTOS/Source/tasks.c **** 				else
3970:FreeRTOS/Source/tasks.c **** 				{
3971:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3972:FreeRTOS/Source/tasks.c **** 				}
3973:FreeRTOS/Source/tasks.c **** 			}
3974:FreeRTOS/Source/tasks.c **** 			else
3975:FreeRTOS/Source/tasks.c **** 			{
3976:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3977:FreeRTOS/Source/tasks.c **** 			}
3978:FreeRTOS/Source/tasks.c **** 		}
3979:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3580              		.loc 1 3979 0
 3581 001c FFF7FEFF 		bl	vPortExitCritical
 3582              	.LVL340:
3980:FreeRTOS/Source/tasks.c **** 
3981:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3583              		.loc 1 3981 0
 3584 0020 FFF7FEFF 		bl	vPortEnterCritical
 3585              	.LVL341:
3982:FreeRTOS/Source/tasks.c **** 		{
3983:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
3984:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 3586              		.loc 1 3984 0
 3587 0024 2368     		ldr	r3, [r4]
 3588 0026 144A     		ldr	r2, .L426
 3589 0028 5D6D     		ldr	r5, [r3, #84]
 3590              	.LVL342:
3985:FreeRTOS/Source/tasks.c **** 
3986:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
 3591              		.loc 1 3986 0
 3592 002a 25B1     		cbz	r5, .L414
3987:FreeRTOS/Source/tasks.c **** 			{
3988:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 3593              		.loc 1 3988 0
 3594 002c 5EB9     		cbnz	r6, .L424
3989:FreeRTOS/Source/tasks.c **** 				{
3990:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
3991:FreeRTOS/Source/tasks.c **** 				}
3992:FreeRTOS/Source/tasks.c **** 				else
3993:FreeRTOS/Source/tasks.c **** 				{
3994:FreeRTOS/Source/tasks.c **** 					( pxCurrentTCB->ulNotifiedValue )--;
 3595              		.loc 1 3994 0
 3596 002e 1268     		ldr	r2, [r2]
 3597 0030 536D     		ldr	r3, [r2, #84]
 3598 0032 013B     		subs	r3, r3, #1
 3599 0034 5365     		str	r3, [r2, #84]
 3600              	.L414:
3995:FreeRTOS/Source/tasks.c **** 				}
3996:FreeRTOS/Source/tasks.c **** 			}
3997:FreeRTOS/Source/tasks.c **** 			else
3998:FreeRTOS/Source/tasks.c **** 			{
3999:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4000:FreeRTOS/Source/tasks.c **** 			}
4001:FreeRTOS/Source/tasks.c **** 
4002:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 3601              		.loc 1 4002 0
 3602 0036 2368     		ldr	r3, [r4]
 3603 0038 0022     		movs	r2, #0
 3604 003a 83F85820 		strb	r2, [r3, #88]
4003:FreeRTOS/Source/tasks.c **** 		}
4004:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3605              		.loc 1 4004 0
 3606 003e FFF7FEFF 		bl	vPortExitCritical
 3607              	.LVL343:
4005:FreeRTOS/Source/tasks.c **** 
4006:FreeRTOS/Source/tasks.c **** 		return ulReturn;
4007:FreeRTOS/Source/tasks.c **** 	}
 3608              		.loc 1 4007 0
 3609 0042 2846     		mov	r0, r5
 3610 0044 70BD     		pop	{r4, r5, r6, pc}
 3611              	.LVL344:
 3612              	.L424:
3990:FreeRTOS/Source/tasks.c **** 				}
 3613              		.loc 1 3990 0
 3614 0046 1368     		ldr	r3, [r2]
 3615 0048 0022     		movs	r2, #0
 3616 004a 5A65     		str	r2, [r3, #84]
 3617 004c F3E7     		b	.L414
 3618              	.LVL345:
 3619              	.L423:
3918:FreeRTOS/Source/tasks.c **** 					{
 3620              		.loc 1 3918 0
 3621 004e 2068     		ldr	r0, [r4]
 3622 0050 0430     		adds	r0, r0, #4
 3623 0052 FFF7FEFF 		bl	uxListRemove
 3624              	.LVL346:
3932:FreeRTOS/Source/tasks.c **** 						{
 3625              		.loc 1 3932 0
 3626 0056 6B1C     		adds	r3, r5, #1
 3627 0058 07D0     		beq	.L425
3946:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 3628              		.loc 1 3946 0
 3629 005a 084B     		ldr	r3, .L426+4
 3630 005c 1868     		ldr	r0, [r3]
 3631              	.LVL347:
3947:FreeRTOS/Source/tasks.c **** 						}
 3632              		.loc 1 3947 0
 3633 005e 2844     		add	r0, r0, r5
 3634              	.LVL348:
 3635 0060 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3636              	.LVL349:
 3637              	.L413:
3967:FreeRTOS/Source/tasks.c **** 				}
 3638              		.loc 1 3967 0
 3639 0064 FFF7FEFF 		bl	vPortYieldFromISR
 3640              	.LVL350:
 3641 0068 D8E7     		b	.L410
 3642              	.L425:
3938:FreeRTOS/Source/tasks.c **** 						}
 3643              		.loc 1 3938 0
 3644 006a 2168     		ldr	r1, [r4]
 3645 006c 0448     		ldr	r0, .L426+8
 3646 006e 0431     		adds	r1, r1, #4
 3647 0070 FFF7FEFF 		bl	vListInsertEnd
 3648              	.LVL351:
 3649 0074 F6E7     		b	.L413
 3650              	.L427:
 3651 0076 00BF     		.align	2
 3652              	.L426:
 3653 0078 00000000 		.word	.LANCHOR2
 3654 007c 00000000 		.word	.LANCHOR3
 3655 0080 00000000 		.word	.LANCHOR15
 3656              		.cfi_endproc
 3657              	.LFE156:
 3659              		.section	.text.xTaskNotifyWait,"ax",%progbits
 3660              		.align	2
 3661              		.global	xTaskNotifyWait
 3662              		.thumb
 3663              		.thumb_func
 3665              	xTaskNotifyWait:
 3666              	.LFB157:
4008:FreeRTOS/Source/tasks.c **** 
4009:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4010:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4011:FreeRTOS/Source/tasks.c **** 
4012:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4013:FreeRTOS/Source/tasks.c **** 
4014:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4015:FreeRTOS/Source/tasks.c **** 	{
 3667              		.loc 1 4015 0
 3668              		.cfi_startproc
 3669              		@ args = 0, pretend = 0, frame = 0
 3670              		@ frame_needed = 0, uses_anonymous_args = 0
 3671              	.LVL352:
 3672 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3673              	.LCFI58:
 3674              		.cfi_def_cfa_offset 24
 3675              		.cfi_offset 4, -24
 3676              		.cfi_offset 5, -20
 3677              		.cfi_offset 6, -16
 3678              		.cfi_offset 7, -12
 3679              		.cfi_offset 8, -8
 3680              		.cfi_offset 14, -4
4016:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
4017:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4018:FreeRTOS/Source/tasks.c **** 
4019:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
4020:FreeRTOS/Source/tasks.c **** 		{
4021:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4022:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->eNotifyState != eNotified )
 3681              		.loc 1 4022 0
 3682 0004 244C     		ldr	r4, .L446
4015:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
 3683              		.loc 1 4015 0
 3684 0006 1F46     		mov	r7, r3
 3685 0008 8046     		mov	r8, r0
 3686 000a 0E46     		mov	r6, r1
 3687 000c 1546     		mov	r5, r2
4019:FreeRTOS/Source/tasks.c **** 		{
 3688              		.loc 1 4019 0
 3689 000e FFF7FEFF 		bl	vPortEnterCritical
 3690              	.LVL353:
 3691              		.loc 1 4022 0
 3692 0012 2368     		ldr	r3, [r4]
 3693 0014 93F85830 		ldrb	r3, [r3, #88]	@ zero_extendqisi2
 3694 0018 022B     		cmp	r3, #2
 3695 001a 09D0     		beq	.L430
4023:FreeRTOS/Source/tasks.c **** 			{
4024:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4025:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4026:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4027:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 3696              		.loc 1 4027 0
 3697 001c 2168     		ldr	r1, [r4]
 3698 001e 4A6D     		ldr	r2, [r1, #84]
 3699 0020 22EA0800 		bic	r0, r2, r8
 3700 0024 4865     		str	r0, [r1, #84]
4028:FreeRTOS/Source/tasks.c **** 
4029:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4030:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->eNotifyState = eWaitingNotification;
 3701              		.loc 1 4030 0
 3702 0026 2368     		ldr	r3, [r4]
 3703 0028 0122     		movs	r2, #1
 3704 002a 83F85820 		strb	r2, [r3, #88]
4031:FreeRTOS/Source/tasks.c **** 
4032:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3705              		.loc 1 4032 0
 3706 002e E7B9     		cbnz	r7, .L444
 3707              	.L430:
4033:FreeRTOS/Source/tasks.c **** 				{
4034:FreeRTOS/Source/tasks.c **** 					/* The task is going to block.  First it must be removed
4035:FreeRTOS/Source/tasks.c **** 					from the	ready list. */
4036:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
4037:FreeRTOS/Source/tasks.c **** 					{
4038:FreeRTOS/Source/tasks.c **** 						/* The current task must be in a ready list, so there is
4039:FreeRTOS/Source/tasks.c **** 						no need to check, and the port reset macro can be called
4040:FreeRTOS/Source/tasks.c **** 						directly. */
4041:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
4042:FreeRTOS/Source/tasks.c **** 					}
4043:FreeRTOS/Source/tasks.c **** 					else
4044:FreeRTOS/Source/tasks.c **** 					{
4045:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4046:FreeRTOS/Source/tasks.c **** 					}
4047:FreeRTOS/Source/tasks.c **** 
4048:FreeRTOS/Source/tasks.c **** 					#if ( INCLUDE_vTaskSuspend == 1 )
4049:FreeRTOS/Source/tasks.c **** 					{
4050:FreeRTOS/Source/tasks.c **** 						if( xTicksToWait == portMAX_DELAY )
4051:FreeRTOS/Source/tasks.c **** 						{
4052:FreeRTOS/Source/tasks.c **** 							/* Add the task to the suspended task list instead
4053:FreeRTOS/Source/tasks.c **** 							of a delayed task list to ensure the task is not
4054:FreeRTOS/Source/tasks.c **** 							woken by a timing event.  It will block
4055:FreeRTOS/Source/tasks.c **** 							indefinitely. */
4056:FreeRTOS/Source/tasks.c **** 							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
4057:FreeRTOS/Source/tasks.c **** 						}
4058:FreeRTOS/Source/tasks.c **** 						else
4059:FreeRTOS/Source/tasks.c **** 						{
4060:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
4061:FreeRTOS/Source/tasks.c **** 							woken if no notification events occur.  This may
4062:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
4063:FreeRTOS/Source/tasks.c **** 							handle it. */
4064:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
4065:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
4066:FreeRTOS/Source/tasks.c **** 						}
4067:FreeRTOS/Source/tasks.c **** 					}
4068:FreeRTOS/Source/tasks.c **** 					#else /* INCLUDE_vTaskSuspend */
4069:FreeRTOS/Source/tasks.c **** 					{
4070:FreeRTOS/Source/tasks.c **** 							/* Calculate the time at which the task should be
4071:FreeRTOS/Source/tasks.c **** 							woken if the event does not occur.  This may
4072:FreeRTOS/Source/tasks.c **** 							overflow but this doesn't matter, the scheduler will
4073:FreeRTOS/Source/tasks.c **** 							handle it. */
4074:FreeRTOS/Source/tasks.c **** 							xTimeToWake = xTickCount + xTicksToWait;
4075:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
4076:FreeRTOS/Source/tasks.c **** 					}
4077:FreeRTOS/Source/tasks.c **** 					#endif /* INCLUDE_vTaskSuspend */
4078:FreeRTOS/Source/tasks.c **** 
4079:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4080:FreeRTOS/Source/tasks.c **** 
4081:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4082:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4083:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4084:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4085:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
4086:FreeRTOS/Source/tasks.c **** 				}
4087:FreeRTOS/Source/tasks.c **** 				else
4088:FreeRTOS/Source/tasks.c **** 				{
4089:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4090:FreeRTOS/Source/tasks.c **** 				}
4091:FreeRTOS/Source/tasks.c **** 			}
4092:FreeRTOS/Source/tasks.c **** 			else
4093:FreeRTOS/Source/tasks.c **** 			{
4094:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4095:FreeRTOS/Source/tasks.c **** 			}
4096:FreeRTOS/Source/tasks.c **** 		}
4097:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3708              		.loc 1 4097 0
 3709 0030 FFF7FEFF 		bl	vPortExitCritical
 3710              	.LVL354:
4098:FreeRTOS/Source/tasks.c **** 
4099:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3711              		.loc 1 4099 0
 3712 0034 FFF7FEFF 		bl	vPortEnterCritical
 3713              	.LVL355:
4100:FreeRTOS/Source/tasks.c **** 		{
4101:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4102:FreeRTOS/Source/tasks.c **** 
4103:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
 3714              		.loc 1 4103 0
 3715 0038 15B1     		cbz	r5, .L434
4104:FreeRTOS/Source/tasks.c **** 			{
4105:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4106:FreeRTOS/Source/tasks.c **** 				have changed. */
4107:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 3716              		.loc 1 4107 0
 3717 003a 2368     		ldr	r3, [r4]
 3718 003c 5B6D     		ldr	r3, [r3, #84]
 3719 003e 2B60     		str	r3, [r5]
 3720              	.L434:
4108:FreeRTOS/Source/tasks.c **** 			}
4109:FreeRTOS/Source/tasks.c **** 
4110:FreeRTOS/Source/tasks.c **** 			/* If eNotifyValue is set then either the task never entered the
4111:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4112:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4113:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4114:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
 3721              		.loc 1 4114 0
 3722 0040 2368     		ldr	r3, [r4]
 3723 0042 154A     		ldr	r2, .L446
 3724 0044 93F85830 		ldrb	r3, [r3, #88]	@ zero_extendqisi2
 3725 0048 012B     		cmp	r3, #1
 3726 004a 22D0     		beq	.L436
4115:FreeRTOS/Source/tasks.c **** 			{
4116:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4117:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
4118:FreeRTOS/Source/tasks.c **** 			}
4119:FreeRTOS/Source/tasks.c **** 			else
4120:FreeRTOS/Source/tasks.c **** 			{
4121:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4122:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4123:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 3727              		.loc 1 4123 0
 3728 004c 1368     		ldr	r3, [r2]
 3729 004e 596D     		ldr	r1, [r3, #84]
 3730 0050 21EA0601 		bic	r1, r1, r6
 3731 0054 5965     		str	r1, [r3, #84]
 3732              	.LVL356:
4124:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3733              		.loc 1 4124 0
 3734 0056 0125     		movs	r5, #1
 3735              	.LVL357:
 3736              	.L435:
4125:FreeRTOS/Source/tasks.c **** 			}
4126:FreeRTOS/Source/tasks.c **** 
4127:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
 3737              		.loc 1 4127 0
 3738 0058 2368     		ldr	r3, [r4]
 3739 005a 0022     		movs	r2, #0
 3740 005c 83F85820 		strb	r2, [r3, #88]
4128:FreeRTOS/Source/tasks.c **** 		}
4129:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3741              		.loc 1 4129 0
 3742 0060 FFF7FEFF 		bl	vPortExitCritical
 3743              	.LVL358:
4130:FreeRTOS/Source/tasks.c **** 
4131:FreeRTOS/Source/tasks.c **** 		return xReturn;
4132:FreeRTOS/Source/tasks.c **** 	}
 3744              		.loc 1 4132 0
 3745 0064 2846     		mov	r0, r5
 3746 0066 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3747              	.LVL359:
 3748              	.L444:
4036:FreeRTOS/Source/tasks.c **** 					{
 3749              		.loc 1 4036 0
 3750 006a 2068     		ldr	r0, [r4]
 3751 006c 0430     		adds	r0, r0, #4
 3752 006e FFF7FEFF 		bl	uxListRemove
 3753              	.LVL360:
4050:FreeRTOS/Source/tasks.c **** 						{
 3754              		.loc 1 4050 0
 3755 0072 7B1C     		adds	r3, r7, #1
 3756 0074 07D0     		beq	.L445
4064:FreeRTOS/Source/tasks.c **** 							prvAddCurrentTaskToDelayedList( xTimeToWake );
 3757              		.loc 1 4064 0
 3758 0076 094B     		ldr	r3, .L446+4
 3759 0078 1868     		ldr	r0, [r3]
 3760              	.LVL361:
4065:FreeRTOS/Source/tasks.c **** 						}
 3761              		.loc 1 4065 0
 3762 007a 3844     		add	r0, r0, r7
 3763              	.LVL362:
 3764 007c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3765              	.LVL363:
 3766              	.L433:
4085:FreeRTOS/Source/tasks.c **** 				}
 3767              		.loc 1 4085 0
 3768 0080 FFF7FEFF 		bl	vPortYieldFromISR
 3769              	.LVL364:
 3770 0084 D4E7     		b	.L430
 3771              	.L445:
4056:FreeRTOS/Source/tasks.c **** 						}
 3772              		.loc 1 4056 0
 3773 0086 2168     		ldr	r1, [r4]
 3774 0088 0548     		ldr	r0, .L446+8
 3775 008a 0431     		adds	r1, r1, #4
 3776 008c FFF7FEFF 		bl	vListInsertEnd
 3777              	.LVL365:
 3778 0090 F6E7     		b	.L433
 3779              	.L436:
4117:FreeRTOS/Source/tasks.c **** 			}
 3780              		.loc 1 4117 0
 3781 0092 0025     		movs	r5, #0
 3782              	.LVL366:
 3783 0094 E0E7     		b	.L435
 3784              	.L447:
 3785 0096 00BF     		.align	2
 3786              	.L446:
 3787 0098 00000000 		.word	.LANCHOR2
 3788 009c 00000000 		.word	.LANCHOR3
 3789 00a0 00000000 		.word	.LANCHOR15
 3790              		.cfi_endproc
 3791              	.LFE157:
 3793              		.section	.text.xTaskGenericNotify,"ax",%progbits
 3794              		.align	2
 3795              		.global	xTaskGenericNotify
 3796              		.thumb
 3797              		.thumb_func
 3799              	xTaskGenericNotify:
 3800              	.LFB158:
4133:FreeRTOS/Source/tasks.c **** 
4134:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4135:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4136:FreeRTOS/Source/tasks.c **** 
4137:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4138:FreeRTOS/Source/tasks.c **** 
4139:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4140:FreeRTOS/Source/tasks.c **** 	{
 3801              		.loc 1 4140 0
 3802              		.cfi_startproc
 3803              		@ args = 0, pretend = 0, frame = 0
 3804              		@ frame_needed = 0, uses_anonymous_args = 0
 3805              	.LVL367:
 3806 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3807              	.LCFI59:
 3808              		.cfi_def_cfa_offset 24
 3809              		.cfi_offset 3, -24
 3810              		.cfi_offset 4, -20
 3811              		.cfi_offset 5, -16
 3812              		.cfi_offset 6, -12
 3813              		.cfi_offset 7, -8
 3814              		.cfi_offset 14, -4
 3815              		.loc 1 4140 0
 3816 0002 1E46     		mov	r6, r3
 3817 0004 0446     		mov	r4, r0
 3818              	.LVL368:
 3819 0006 0F46     		mov	r7, r1
 3820 0008 1546     		mov	r5, r2
4141:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4142:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4143:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4144:FreeRTOS/Source/tasks.c **** 
4145:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4146:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4147:FreeRTOS/Source/tasks.c **** 
4148:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3821              		.loc 1 4148 0
 3822 000a FFF7FEFF 		bl	vPortEnterCritical
 3823              	.LVL369:
4149:FreeRTOS/Source/tasks.c **** 		{
4150:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 3824              		.loc 1 4150 0
 3825 000e 0EB1     		cbz	r6, .L449
4151:FreeRTOS/Source/tasks.c **** 			{
4152:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 3826              		.loc 1 4152 0
 3827 0010 636D     		ldr	r3, [r4, #84]
 3828 0012 3360     		str	r3, [r6]
 3829              	.L449:
4153:FreeRTOS/Source/tasks.c **** 			}
4154:FreeRTOS/Source/tasks.c **** 
4155:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 3830              		.loc 1 4155 0
 3831 0014 94F85830 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
4156:FreeRTOS/Source/tasks.c **** 
4157:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3832              		.loc 1 4157 0
 3833 0018 0221     		movs	r1, #2
4158:FreeRTOS/Source/tasks.c **** 
4159:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 3834              		.loc 1 4159 0
 3835 001a 6A1E     		subs	r2, r5, #1
4155:FreeRTOS/Source/tasks.c **** 
 3836              		.loc 1 4155 0
 3837 001c DBB2     		uxtb	r3, r3
 3838              	.LVL370:
4157:FreeRTOS/Source/tasks.c **** 
 3839              		.loc 1 4157 0
 3840 001e 84F85810 		strb	r1, [r4, #88]
 3841              		.loc 1 4159 0
 3842 0022 032A     		cmp	r2, #3
 3843 0024 06D8     		bhi	.L450
 3844 0026 DFE802F0 		tbb	[pc, r2]
 3845              	.L452:
 3846 002a 2D       		.byte	(.L451-.L452)/2
 3847 002b 0C       		.byte	(.L453-.L452)/2
 3848 002c 04       		.byte	(.L465-.L452)/2
 3849 002d 02       		.byte	(.L455-.L452)/2
 3850              		.p2align 1
 3851              	.L455:
4160:FreeRTOS/Source/tasks.c **** 			{
4161:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4162:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4163:FreeRTOS/Source/tasks.c **** 					break;
4164:FreeRTOS/Source/tasks.c **** 
4165:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4166:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4167:FreeRTOS/Source/tasks.c **** 					break;
4168:FreeRTOS/Source/tasks.c **** 
4169:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4170:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4171:FreeRTOS/Source/tasks.c **** 					break;
4172:FreeRTOS/Source/tasks.c **** 
4173:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4174:FreeRTOS/Source/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 3852              		.loc 1 4174 0
 3853 002e 022B     		cmp	r3, #2
 3854 0030 2CD0     		beq	.L460
 3855              	.L465:
4175:FreeRTOS/Source/tasks.c **** 					{
4176:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 3856              		.loc 1 4176 0
 3857 0032 6765     		str	r7, [r4, #84]
 3858              	.LVL371:
 3859              	.L450:
4177:FreeRTOS/Source/tasks.c **** 					}
4178:FreeRTOS/Source/tasks.c **** 					else
4179:FreeRTOS/Source/tasks.c **** 					{
4180:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4181:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4182:FreeRTOS/Source/tasks.c **** 					}
4183:FreeRTOS/Source/tasks.c **** 					break;
4184:FreeRTOS/Source/tasks.c **** 
4185:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4186:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4187:FreeRTOS/Source/tasks.c **** 					updated. */
4188:FreeRTOS/Source/tasks.c **** 					break;
4189:FreeRTOS/Source/tasks.c **** 			}
4190:FreeRTOS/Source/tasks.c **** 
4191:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4192:FreeRTOS/Source/tasks.c **** 
4193:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4194:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4195:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 3860              		.loc 1 4195 0
 3861 0034 012B     		cmp	r3, #1
 3862 0036 0AD0     		beq	.L467
 3863              	.LVL372:
 3864              	.L466:
 3865 0038 0124     		movs	r4, #1
 3866              	.LVL373:
 3867              	.L456:
4196:FreeRTOS/Source/tasks.c **** 			{
4197:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
4198:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
4199:FreeRTOS/Source/tasks.c **** 
4200:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4201:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4202:FreeRTOS/Source/tasks.c **** 
4203:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4204:FreeRTOS/Source/tasks.c **** 				{
4205:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4206:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4207:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4208:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4209:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4210:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4211:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4212:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4213:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4214:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4215:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4216:FreeRTOS/Source/tasks.c **** 				}
4217:FreeRTOS/Source/tasks.c **** 				#endif
4218:FreeRTOS/Source/tasks.c **** 
4219:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4220:FreeRTOS/Source/tasks.c **** 				{
4221:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4222:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4223:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
4224:FreeRTOS/Source/tasks.c **** 				}
4225:FreeRTOS/Source/tasks.c **** 				else
4226:FreeRTOS/Source/tasks.c **** 				{
4227:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4228:FreeRTOS/Source/tasks.c **** 				}
4229:FreeRTOS/Source/tasks.c **** 			}
4230:FreeRTOS/Source/tasks.c **** 			else
4231:FreeRTOS/Source/tasks.c **** 			{
4232:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4233:FreeRTOS/Source/tasks.c **** 			}
4234:FreeRTOS/Source/tasks.c **** 		}
4235:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3868              		.loc 1 4235 0
 3869 003a FFF7FEFF 		bl	vPortExitCritical
 3870              	.LVL374:
4236:FreeRTOS/Source/tasks.c **** 
4237:FreeRTOS/Source/tasks.c **** 		return xReturn;
4238:FreeRTOS/Source/tasks.c **** 	}
 3871              		.loc 1 4238 0
 3872 003e 2046     		mov	r0, r4
 3873 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3874              	.LVL375:
 3875              	.L453:
4166:FreeRTOS/Source/tasks.c **** 					break;
 3876              		.loc 1 4166 0
 3877 0042 626D     		ldr	r2, [r4, #84]
4195:FreeRTOS/Source/tasks.c **** 			{
 3878              		.loc 1 4195 0
 3879 0044 012B     		cmp	r3, #1
4166:FreeRTOS/Source/tasks.c **** 					break;
 3880              		.loc 1 4166 0
 3881 0046 02F10102 		add	r2, r2, #1
 3882 004a 6265     		str	r2, [r4, #84]
4195:FreeRTOS/Source/tasks.c **** 			{
 3883              		.loc 1 4195 0
 3884 004c F4D1     		bne	.L466
 3885              	.LVL376:
 3886              	.L467:
4197:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 3887              		.loc 1 4197 0
 3888 004e 251D     		adds	r5, r4, #4
 3889 0050 2846     		mov	r0, r5
 3890 0052 FFF7FEFF 		bl	uxListRemove
 3891              	.LVL377:
4198:FreeRTOS/Source/tasks.c **** 
 3892              		.loc 1 4198 0
 3893 0056 0E4A     		ldr	r2, .L468
 3894 0058 E36A     		ldr	r3, [r4, #44]
 3895 005a 1168     		ldr	r1, [r2]
 3896 005c 0D48     		ldr	r0, .L468+4
 3897 005e 8B42     		cmp	r3, r1
 3898 0060 88BF     		it	hi
 3899 0062 1360     		strhi	r3, [r2]
 3900 0064 03EB8303 		add	r3, r3, r3, lsl #2
 3901 0068 00EB8300 		add	r0, r0, r3, lsl #2
 3902 006c 2946     		mov	r1, r5
 3903 006e FFF7FEFF 		bl	vListInsertEnd
 3904              	.LVL378:
4219:FreeRTOS/Source/tasks.c **** 				{
 3905              		.loc 1 4219 0
 3906 0072 094B     		ldr	r3, .L468+8
 3907 0074 E26A     		ldr	r2, [r4, #44]
 3908 0076 1B68     		ldr	r3, [r3]
 3909 0078 DB6A     		ldr	r3, [r3, #44]
 3910 007a 9A42     		cmp	r2, r3
 3911 007c DCD9     		bls	.L466
4223:FreeRTOS/Source/tasks.c **** 				}
 3912              		.loc 1 4223 0
 3913 007e FFF7FEFF 		bl	vPortYieldFromISR
 3914              	.LVL379:
 3915 0082 D9E7     		b	.L466
 3916              	.LVL380:
 3917              	.L451:
4162:FreeRTOS/Source/tasks.c **** 					break;
 3918              		.loc 1 4162 0
 3919 0084 626D     		ldr	r2, [r4, #84]
 3920 0086 1743     		orrs	r7, r7, r2
 3921              	.LVL381:
 3922 0088 6765     		str	r7, [r4, #84]
4163:FreeRTOS/Source/tasks.c **** 
 3923              		.loc 1 4163 0
 3924 008a D3E7     		b	.L450
 3925              	.LVL382:
 3926              	.L460:
4181:FreeRTOS/Source/tasks.c **** 					}
 3927              		.loc 1 4181 0
 3928 008c 0024     		movs	r4, #0
 3929              	.LVL383:
 3930 008e D4E7     		b	.L456
 3931              	.L469:
 3932              		.align	2
 3933              	.L468:
 3934 0090 00000000 		.word	.LANCHOR8
 3935 0094 00000000 		.word	.LANCHOR9
 3936 0098 00000000 		.word	.LANCHOR2
 3937              		.cfi_endproc
 3938              	.LFE158:
 3940              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 3941              		.align	2
 3942              		.global	xTaskGenericNotifyFromISR
 3943              		.thumb
 3944              		.thumb_func
 3946              	xTaskGenericNotifyFromISR:
 3947              	.LFB159:
4239:FreeRTOS/Source/tasks.c **** 
4240:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4241:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4242:FreeRTOS/Source/tasks.c **** 
4243:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4244:FreeRTOS/Source/tasks.c **** 
4245:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4246:FreeRTOS/Source/tasks.c **** 	{
 3948              		.loc 1 4246 0
 3949              		.cfi_startproc
 3950              		@ args = 4, pretend = 0, frame = 0
 3951              		@ frame_needed = 0, uses_anonymous_args = 0
 3952              	.LVL384:
 3953 0000 38B5     		push	{r3, r4, r5, lr}
 3954              	.LCFI60:
 3955              		.cfi_def_cfa_offset 16
 3956              		.cfi_offset 3, -16
 3957              		.cfi_offset 4, -12
 3958              		.cfi_offset 5, -8
 3959              		.cfi_offset 14, -4
 3960              		.loc 1 4246 0
 3961 0002 0446     		mov	r4, r0
 3962              	.LVL385:
4247:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4248:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4249:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
4250:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4251:FreeRTOS/Source/tasks.c **** 
4252:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4253:FreeRTOS/Source/tasks.c **** 
4254:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4255:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4256:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4257:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4258:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4259:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4260:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4261:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4262:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4263:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4264:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4265:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4266:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4267:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4268:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4269:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4270:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4271:FreeRTOS/Source/tasks.c **** 
4272:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4273:FreeRTOS/Source/tasks.c **** 
4274:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 3963              		.loc 1 4274 0
 3964              	@ 4274 "FreeRTOS/Source/tasks.c" 1
 3965 0004 4FF0BF00 			mov r0, #191								
 3966 0008 80F31188 		msr basepri, r0							
 3967              	
 3968              	@ 0 "" 2
 3969              	.LVL386:
4275:FreeRTOS/Source/tasks.c **** 		{
4276:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 3970              		.loc 1 4276 0
 3971              		.thumb
 3972 000c 0BB1     		cbz	r3, .L471
4277:FreeRTOS/Source/tasks.c **** 			{
4278:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 3973              		.loc 1 4278 0
 3974 000e 606D     		ldr	r0, [r4, #84]
 3975 0010 1860     		str	r0, [r3]
 3976              	.L471:
4279:FreeRTOS/Source/tasks.c **** 			}
4280:FreeRTOS/Source/tasks.c **** 
4281:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
 3977              		.loc 1 4281 0
 3978 0012 94F85830 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 3979              	.LVL387:
4282:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3980              		.loc 1 4282 0
 3981 0016 0220     		movs	r0, #2
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 3982              		.loc 1 4284 0
 3983 0018 013A     		subs	r2, r2, #1
 3984              	.LVL388:
4281:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3985              		.loc 1 4281 0
 3986 001a DBB2     		uxtb	r3, r3
 3987              	.LVL389:
4282:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 3988              		.loc 1 4282 0
 3989 001c 84F85800 		strb	r0, [r4, #88]
 3990              		.loc 1 4284 0
 3991 0020 032A     		cmp	r2, #3
 3992 0022 06D8     		bhi	.L472
 3993 0024 DFE802F0 		tbb	[pc, r2]
 3994              	.L474:
 3995 0028 29       		.byte	(.L473-.L474)/2
 3996 0029 0E       		.byte	(.L475-.L474)/2
 3997 002a 04       		.byte	(.L492-.L474)/2
 3998 002b 02       		.byte	(.L477-.L474)/2
 3999              		.p2align 1
 4000              	.L477:
4285:FreeRTOS/Source/tasks.c **** 			{
4286:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4287:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
4288:FreeRTOS/Source/tasks.c **** 					break;
4289:FreeRTOS/Source/tasks.c **** 
4290:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4291:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
4292:FreeRTOS/Source/tasks.c **** 					break;
4293:FreeRTOS/Source/tasks.c **** 
4294:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4295:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
4296:FreeRTOS/Source/tasks.c **** 					break;
4297:FreeRTOS/Source/tasks.c **** 
4298:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4299:FreeRTOS/Source/tasks.c **** 					if( eOriginalNotifyState != eNotified )
 4001              		.loc 1 4299 0
 4002 002c 022B     		cmp	r3, #2
 4003 002e 3BD0     		beq	.L484
 4004              	.L492:
4300:FreeRTOS/Source/tasks.c **** 					{
4301:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4005              		.loc 1 4301 0
 4006 0030 6165     		str	r1, [r4, #84]
 4007              	.LVL390:
 4008              	.L472:
4302:FreeRTOS/Source/tasks.c **** 					}
4303:FreeRTOS/Source/tasks.c **** 					else
4304:FreeRTOS/Source/tasks.c **** 					{
4305:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4306:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4307:FreeRTOS/Source/tasks.c **** 					}
4308:FreeRTOS/Source/tasks.c **** 					break;
4309:FreeRTOS/Source/tasks.c **** 
4310:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4311:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4312:FreeRTOS/Source/tasks.c **** 					updated. */
4313:FreeRTOS/Source/tasks.c **** 					break;
4314:FreeRTOS/Source/tasks.c **** 			}
4315:FreeRTOS/Source/tasks.c **** 
4316:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4317:FreeRTOS/Source/tasks.c **** 
4318:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4319:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4320:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 4009              		.loc 1 4320 0
 4010 0032 012B     		cmp	r3, #1
 4011 0034 0CD0     		beq	.L479
 4012              	.LVL391:
 4013              	.L483:
4246:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4014              		.loc 1 4246 0
 4015 0036 0123     		movs	r3, #1
 4016              	.L478:
4321:FreeRTOS/Source/tasks.c **** 			{
4322:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4323:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4324:FreeRTOS/Source/tasks.c **** 
4325:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4326:FreeRTOS/Source/tasks.c **** 				{
4327:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
4328:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4329:FreeRTOS/Source/tasks.c **** 				}
4330:FreeRTOS/Source/tasks.c **** 				else
4331:FreeRTOS/Source/tasks.c **** 				{
4332:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4333:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4334:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4335:FreeRTOS/Source/tasks.c **** 				}
4336:FreeRTOS/Source/tasks.c **** 
4337:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4338:FreeRTOS/Source/tasks.c **** 				{
4339:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4340:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4341:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4342:FreeRTOS/Source/tasks.c **** 					{
4343:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4344:FreeRTOS/Source/tasks.c **** 					}
4345:FreeRTOS/Source/tasks.c **** 				}
4346:FreeRTOS/Source/tasks.c **** 				else
4347:FreeRTOS/Source/tasks.c **** 				{
4348:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4349:FreeRTOS/Source/tasks.c **** 				}
4350:FreeRTOS/Source/tasks.c **** 			}
4351:FreeRTOS/Source/tasks.c **** 		}
4352:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4017              		.loc 1 4352 0
 4018              	@ 4352 "FreeRTOS/Source/tasks.c" 1
 4019 0038 4FF00000 			mov r0, #0					
 4020 003c 80F31188 		msr basepri, r0				
 4021              	
 4022              	@ 0 "" 2
4353:FreeRTOS/Source/tasks.c **** 
4354:FreeRTOS/Source/tasks.c **** 		return xReturn;
4355:FreeRTOS/Source/tasks.c **** 	}
 4023              		.loc 1 4355 0
 4024              		.thumb
 4025 0040 1846     		mov	r0, r3
 4026 0042 38BD     		pop	{r3, r4, r5, pc}
 4027              	.LVL392:
 4028              	.L475:
4291:FreeRTOS/Source/tasks.c **** 					break;
 4029              		.loc 1 4291 0
 4030 0044 626D     		ldr	r2, [r4, #84]
4320:FreeRTOS/Source/tasks.c **** 			{
 4031              		.loc 1 4320 0
 4032 0046 012B     		cmp	r3, #1
4291:FreeRTOS/Source/tasks.c **** 					break;
 4033              		.loc 1 4291 0
 4034 0048 02F10102 		add	r2, r2, #1
 4035 004c 6265     		str	r2, [r4, #84]
4320:FreeRTOS/Source/tasks.c **** 			{
 4036              		.loc 1 4320 0
 4037 004e F2D1     		bne	.L483
 4038              	.LVL393:
 4039              	.L479:
4325:FreeRTOS/Source/tasks.c **** 				{
 4040              		.loc 1 4325 0
 4041 0050 164B     		ldr	r3, .L494
 4042              	.LVL394:
 4043 0052 1B68     		ldr	r3, [r3]
 4044 0054 ABB1     		cbz	r3, .L493
4334:FreeRTOS/Source/tasks.c **** 				}
 4045              		.loc 1 4334 0
 4046 0056 1648     		ldr	r0, .L494+4
 4047 0058 04F11801 		add	r1, r4, #24
 4048 005c FFF7FEFF 		bl	vListInsertEnd
 4049              	.LVL395:
 4050              	.L482:
4337:FreeRTOS/Source/tasks.c **** 				{
 4051              		.loc 1 4337 0
 4052 0060 144B     		ldr	r3, .L494+8
 4053 0062 E26A     		ldr	r2, [r4, #44]
 4054 0064 1B68     		ldr	r3, [r3]
 4055 0066 DB6A     		ldr	r3, [r3, #44]
 4056 0068 9A42     		cmp	r2, r3
 4057 006a E4D9     		bls	.L483
4341:FreeRTOS/Source/tasks.c **** 					{
 4058              		.loc 1 4341 0
 4059 006c 049B     		ldr	r3, [sp, #16]
 4060 006e 002B     		cmp	r3, #0
 4061 0070 E1D0     		beq	.L483
4343:FreeRTOS/Source/tasks.c **** 					}
 4062              		.loc 1 4343 0
 4063 0072 049A     		ldr	r2, [sp, #16]
 4064 0074 0123     		movs	r3, #1
 4065 0076 1360     		str	r3, [r2]
 4066 0078 DEE7     		b	.L478
 4067              	.LVL396:
 4068              	.L473:
4287:FreeRTOS/Source/tasks.c **** 					break;
 4069              		.loc 1 4287 0
 4070 007a 626D     		ldr	r2, [r4, #84]
 4071 007c 1143     		orrs	r1, r1, r2
 4072              	.LVL397:
 4073 007e 6165     		str	r1, [r4, #84]
4288:FreeRTOS/Source/tasks.c **** 
 4074              		.loc 1 4288 0
 4075 0080 D7E7     		b	.L472
 4076              	.LVL398:
 4077              	.L493:
4327:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4078              		.loc 1 4327 0
 4079 0082 251D     		adds	r5, r4, #4
 4080 0084 2846     		mov	r0, r5
 4081 0086 FFF7FEFF 		bl	uxListRemove
 4082              	.LVL399:
4328:FreeRTOS/Source/tasks.c **** 				}
 4083              		.loc 1 4328 0
 4084 008a 0B4A     		ldr	r2, .L494+12
 4085 008c E36A     		ldr	r3, [r4, #44]
 4086 008e 1168     		ldr	r1, [r2]
 4087 0090 0A48     		ldr	r0, .L494+16
 4088 0092 8B42     		cmp	r3, r1
 4089 0094 88BF     		it	hi
 4090 0096 1360     		strhi	r3, [r2]
 4091 0098 03EB8303 		add	r3, r3, r3, lsl #2
 4092 009c 2946     		mov	r1, r5
 4093 009e 00EB8300 		add	r0, r0, r3, lsl #2
 4094 00a2 FFF7FEFF 		bl	vListInsertEnd
 4095              	.LVL400:
 4096 00a6 DBE7     		b	.L482
 4097              	.LVL401:
 4098              	.L484:
4306:FreeRTOS/Source/tasks.c **** 					}
 4099              		.loc 1 4306 0
 4100 00a8 0023     		movs	r3, #0
 4101              	.LVL402:
 4102 00aa C5E7     		b	.L478
 4103              	.L495:
 4104              		.align	2
 4105              	.L494:
 4106 00ac 00000000 		.word	.LANCHOR19
 4107 00b0 00000000 		.word	.LANCHOR13
 4108 00b4 00000000 		.word	.LANCHOR2
 4109 00b8 00000000 		.word	.LANCHOR8
 4110 00bc 00000000 		.word	.LANCHOR9
 4111              		.cfi_endproc
 4112              	.LFE159:
 4114              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 4115              		.align	2
 4116              		.global	vTaskNotifyGiveFromISR
 4117              		.thumb
 4118              		.thumb_func
 4120              	vTaskNotifyGiveFromISR:
 4121              	.LFB160:
4356:FreeRTOS/Source/tasks.c **** 
4357:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4358:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4359:FreeRTOS/Source/tasks.c **** 
4360:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4361:FreeRTOS/Source/tasks.c **** 
4362:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4363:FreeRTOS/Source/tasks.c **** 	{
 4122              		.loc 1 4363 0
 4123              		.cfi_startproc
 4124              		@ args = 0, pretend = 0, frame = 0
 4125              		@ frame_needed = 0, uses_anonymous_args = 0
 4126              	.LVL403:
 4127 0000 0346     		mov	r3, r0
 4128              	.LVL404:
4364:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4365:FreeRTOS/Source/tasks.c **** 	eNotifyValue eOriginalNotifyState;
4366:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4367:FreeRTOS/Source/tasks.c **** 
4368:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4369:FreeRTOS/Source/tasks.c **** 
4370:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4371:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4372:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4373:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4374:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4375:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4376:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4377:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4378:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4379:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4380:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4381:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4382:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4383:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4384:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4385:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4386:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4387:FreeRTOS/Source/tasks.c **** 
4388:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
4389:FreeRTOS/Source/tasks.c **** 
4390:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4129              		.loc 1 4390 0
 4130              	@ 4390 "FreeRTOS/Source/tasks.c" 1
 4131 0002 4FF0BF00 			mov r0, #191								
 4132 0006 80F31188 		msr basepri, r0							
 4133              	
 4134              	@ 0 "" 2
 4135              	.LVL405:
4391:FreeRTOS/Source/tasks.c **** 		{
4392:FreeRTOS/Source/tasks.c **** 			eOriginalNotifyState = pxTCB->eNotifyState;
4393:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 4136              		.loc 1 4393 0
 4137              		.thumb
 4138 000a 0222     		movs	r2, #2
4392:FreeRTOS/Source/tasks.c **** 			pxTCB->eNotifyState = eNotified;
 4139              		.loc 1 4392 0
 4140 000c 93F85800 		ldrb	r0, [r3, #88]	@ zero_extendqisi2
 4141              	.LVL406:
 4142              		.loc 1 4393 0
 4143 0010 83F85820 		strb	r2, [r3, #88]
4394:FreeRTOS/Source/tasks.c **** 
4395:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4396:FreeRTOS/Source/tasks.c **** 			semaphore. */
4397:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 4144              		.loc 1 4397 0
 4145 0014 5A6D     		ldr	r2, [r3, #84]
4398:FreeRTOS/Source/tasks.c **** 
4399:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4400:FreeRTOS/Source/tasks.c **** 
4401:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4402:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4403:FreeRTOS/Source/tasks.c **** 			if( eOriginalNotifyState == eWaitingNotification )
 4146              		.loc 1 4403 0
 4147 0016 0128     		cmp	r0, #1
4397:FreeRTOS/Source/tasks.c **** 
 4148              		.loc 1 4397 0
 4149 0018 02F10102 		add	r2, r2, #1
 4150 001c 5A65     		str	r2, [r3, #84]
 4151              		.loc 1 4403 0
 4152 001e 04D0     		beq	.L508
4404:FreeRTOS/Source/tasks.c **** 			{
4405:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4406:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4407:FreeRTOS/Source/tasks.c **** 
4408:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4409:FreeRTOS/Source/tasks.c **** 				{
4410:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
4411:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4412:FreeRTOS/Source/tasks.c **** 				}
4413:FreeRTOS/Source/tasks.c **** 				else
4414:FreeRTOS/Source/tasks.c **** 				{
4415:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4416:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4417:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
4418:FreeRTOS/Source/tasks.c **** 				}
4419:FreeRTOS/Source/tasks.c **** 
4420:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4421:FreeRTOS/Source/tasks.c **** 				{
4422:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4423:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4424:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
4425:FreeRTOS/Source/tasks.c **** 					{
4426:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
4427:FreeRTOS/Source/tasks.c **** 					}
4428:FreeRTOS/Source/tasks.c **** 				}
4429:FreeRTOS/Source/tasks.c **** 				else
4430:FreeRTOS/Source/tasks.c **** 				{
4431:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4432:FreeRTOS/Source/tasks.c **** 				}
4433:FreeRTOS/Source/tasks.c **** 			}
4434:FreeRTOS/Source/tasks.c **** 		}
4435:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4153              		.loc 1 4435 0
 4154              	@ 4435 "FreeRTOS/Source/tasks.c" 1
 4155 0020 4FF00000 			mov r0, #0					
 4156 0024 80F31188 		msr basepri, r0				
 4157              	
 4158              	@ 0 "" 2
 4159              	.LVL407:
 4160              		.thumb
 4161 0028 7047     		bx	lr
 4162              	.LVL408:
 4163              	.L508:
4363:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
 4164              		.loc 1 4363 0
 4165 002a 70B5     		push	{r4, r5, r6, lr}
 4166              	.LCFI61:
 4167              		.cfi_def_cfa_offset 16
 4168              		.cfi_offset 4, -16
 4169              		.cfi_offset 5, -12
 4170              		.cfi_offset 6, -8
 4171              		.cfi_offset 14, -4
 4172 002c 1C46     		mov	r4, r3
4408:FreeRTOS/Source/tasks.c **** 				{
 4173              		.loc 1 4408 0
 4174 002e 154B     		ldr	r3, .L510
 4175              	.LVL409:
 4176 0030 1B68     		ldr	r3, [r3]
 4177 0032 0D46     		mov	r5, r1
 4178 0034 93B1     		cbz	r3, .L509
4417:FreeRTOS/Source/tasks.c **** 				}
 4179              		.loc 1 4417 0
 4180 0036 1448     		ldr	r0, .L510+4
 4181              	.LVL410:
 4182 0038 04F11801 		add	r1, r4, #24
 4183              	.LVL411:
 4184 003c FFF7FEFF 		bl	vListInsertEnd
 4185              	.LVL412:
 4186              	.L501:
4420:FreeRTOS/Source/tasks.c **** 				{
 4187              		.loc 1 4420 0
 4188 0040 124B     		ldr	r3, .L510+8
 4189 0042 E26A     		ldr	r2, [r4, #44]
 4190 0044 1B68     		ldr	r3, [r3]
 4191 0046 DB6A     		ldr	r3, [r3, #44]
 4192 0048 9A42     		cmp	r2, r3
 4193 004a 02D9     		bls	.L498
4424:FreeRTOS/Source/tasks.c **** 					{
 4194              		.loc 1 4424 0
 4195 004c 0DB1     		cbz	r5, .L498
4426:FreeRTOS/Source/tasks.c **** 					}
 4196              		.loc 1 4426 0
 4197 004e 0123     		movs	r3, #1
 4198 0050 2B60     		str	r3, [r5]
 4199              	.L498:
 4200              		.loc 1 4435 0
 4201              	@ 4435 "FreeRTOS/Source/tasks.c" 1
 4202 0052 4FF00000 			mov r0, #0					
 4203 0056 80F31188 		msr basepri, r0				
 4204              	
 4205              	@ 0 "" 2
 4206              		.thumb
 4207 005a 70BD     		pop	{r4, r5, r6, pc}
 4208              	.LVL413:
 4209              	.L509:
4410:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4210              		.loc 1 4410 0
 4211 005c 261D     		adds	r6, r4, #4
 4212 005e 3046     		mov	r0, r6
 4213              	.LVL414:
 4214 0060 FFF7FEFF 		bl	uxListRemove
 4215              	.LVL415:
4411:FreeRTOS/Source/tasks.c **** 				}
 4216              		.loc 1 4411 0
 4217 0064 0A4A     		ldr	r2, .L510+12
 4218 0066 E36A     		ldr	r3, [r4, #44]
 4219 0068 1168     		ldr	r1, [r2]
 4220 006a 0A48     		ldr	r0, .L510+16
 4221 006c 8B42     		cmp	r3, r1
 4222 006e 88BF     		it	hi
 4223 0070 1360     		strhi	r3, [r2]
 4224 0072 03EB8303 		add	r3, r3, r3, lsl #2
 4225 0076 3146     		mov	r1, r6
 4226 0078 00EB8300 		add	r0, r0, r3, lsl #2
 4227 007c FFF7FEFF 		bl	vListInsertEnd
 4228              	.LVL416:
 4229 0080 DEE7     		b	.L501
 4230              	.L511:
 4231 0082 00BF     		.align	2
 4232              	.L510:
 4233 0084 00000000 		.word	.LANCHOR19
 4234 0088 00000000 		.word	.LANCHOR13
 4235 008c 00000000 		.word	.LANCHOR2
 4236 0090 00000000 		.word	.LANCHOR8
 4237 0094 00000000 		.word	.LANCHOR9
 4238              		.cfi_endproc
 4239              	.LFE160:
 4241              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 4242              		.align	2
 4243              		.global	xTaskNotifyStateClear
 4244              		.thumb
 4245              		.thumb_func
 4247              	xTaskNotifyStateClear:
 4248              	.LFB161:
4436:FreeRTOS/Source/tasks.c **** 	}
4437:FreeRTOS/Source/tasks.c **** 
4438:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4439:FreeRTOS/Source/tasks.c **** 
4440:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4441:FreeRTOS/Source/tasks.c **** 
4442:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4443:FreeRTOS/Source/tasks.c **** 
4444:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4445:FreeRTOS/Source/tasks.c **** 	{
 4249              		.loc 1 4445 0
 4250              		.cfi_startproc
 4251              		@ args = 0, pretend = 0, frame = 0
 4252              		@ frame_needed = 0, uses_anonymous_args = 0
 4253              	.LVL417:
 4254 0000 10B5     		push	{r4, lr}
 4255              	.LCFI62:
 4256              		.cfi_def_cfa_offset 8
 4257              		.cfi_offset 4, -8
 4258              		.cfi_offset 14, -4
4446:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
4447:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4448:FreeRTOS/Source/tasks.c **** 
4449:FreeRTOS/Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTask;
4450:FreeRTOS/Source/tasks.c **** 
4451:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4452:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
4453:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( pxTCB );
 4259              		.loc 1 4453 0
 4260 0002 0446     		mov	r4, r0
 4261 0004 70B1     		cbz	r0, .L517
 4262              	.LVL418:
 4263              	.L513:
4454:FreeRTOS/Source/tasks.c **** 
4455:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 4264              		.loc 1 4455 0 discriminator 4
 4265 0006 FFF7FEFF 		bl	vPortEnterCritical
 4266              	.LVL419:
4456:FreeRTOS/Source/tasks.c **** 		{
4457:FreeRTOS/Source/tasks.c **** 			if( pxTCB->eNotifyState == eNotified )
 4267              		.loc 1 4457 0 discriminator 4
 4268 000a 94F85830 		ldrb	r3, [r4, #88]	@ zero_extendqisi2
 4269 000e 022B     		cmp	r3, #2
4458:FreeRTOS/Source/tasks.c **** 			{
4459:FreeRTOS/Source/tasks.c **** 				pxTCB->eNotifyState = eNotWaitingNotification;
 4270              		.loc 1 4459 0 discriminator 4
 4271 0010 05BF     		ittet	eq
 4272 0012 0023     		moveq	r3, #0
 4273 0014 84F85830 		strbeq	r3, [r4, #88]
 4274              	.LVL420:
4460:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
4461:FreeRTOS/Source/tasks.c **** 			}
4462:FreeRTOS/Source/tasks.c **** 			else
4463:FreeRTOS/Source/tasks.c **** 			{
4464:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
 4275              		.loc 1 4464 0 discriminator 4
 4276 0018 0024     		movne	r4, #0
 4277              	.LVL421:
4460:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 4278              		.loc 1 4460 0 discriminator 4
 4279 001a 0124     		moveq	r4, #1
 4280              	.LVL422:
4465:FreeRTOS/Source/tasks.c **** 			}
4466:FreeRTOS/Source/tasks.c **** 		}
4467:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 4281              		.loc 1 4467 0 discriminator 4
 4282 001c FFF7FEFF 		bl	vPortExitCritical
 4283              	.LVL423:
4468:FreeRTOS/Source/tasks.c **** 
4469:FreeRTOS/Source/tasks.c **** 		return xReturn;
4470:FreeRTOS/Source/tasks.c **** 	}
 4284              		.loc 1 4470 0 discriminator 4
 4285 0020 2046     		mov	r0, r4
 4286 0022 10BD     		pop	{r4, pc}
 4287              	.LVL424:
 4288              	.L517:
4453:FreeRTOS/Source/tasks.c **** 
 4289              		.loc 1 4453 0 discriminator 1
 4290 0024 014B     		ldr	r3, .L518
 4291 0026 1C68     		ldr	r4, [r3]
 4292              	.LVL425:
 4293 0028 EDE7     		b	.L513
 4294              	.L519:
 4295 002a 00BF     		.align	2
 4296              	.L518:
 4297 002c 00000000 		.word	.LANCHOR2
 4298              		.cfi_endproc
 4299              	.LFE161:
 4301              		.global	pxCurrentTCB
 4302              		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 4303              		.align	2
 4304              		.set	.LANCHOR7,. + 0
 4307              	ulTaskSwitchedInTime:
 4308 0000 00000000 		.space	4
 4309              		.section	.bss.xNumOfOverflows,"aw",%nobits
 4310              		.align	2
 4311              		.set	.LANCHOR21,. + 0
 4314              	xNumOfOverflows:
 4315 0000 00000000 		.space	4
 4316              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 4317              		.align	2
 4318              		.set	.LANCHOR0,. + 0
 4321              	pxDelayedTaskList:
 4322 0000 00000000 		.space	4
 4323              		.section	.rodata.str1.4,"aMS",%progbits,1
 4324              		.align	2
 4325              	.LC0:
 4326 0000 49444C45 		.ascii	"IDLE\000"
 4326      00
 4327 0005 000000   		.section	.bss.xSchedulerRunning,"aw",%nobits
 4328              		.align	2
 4329              		.set	.LANCHOR16,. + 0
 4332              	xSchedulerRunning:
 4333 0000 00000000 		.space	4
 4334              		.section	.bss.uxTasksDeleted,"aw",%nobits
 4335              		.align	2
 4336              		.set	.LANCHOR18,. + 0
 4339              	uxTasksDeleted:
 4340 0000 00000000 		.space	4
 4341              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 4342              		.align	2
 4343              		.set	.LANCHOR11,. + 0
 4346              	xDelayedTaskList1:
 4347 0000 00000000 		.space	20
 4347      00000000 
 4347      00000000 
 4347      00000000 
 4347      00000000 
 4348              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 4349              		.align	2
 4350              		.set	.LANCHOR15,. + 0
 4353              	xSuspendedTaskList:
 4354 0000 00000000 		.space	20
 4354      00000000 
 4354      00000000 
 4354      00000000 
 4354      00000000 
 4355              		.section	.bss.uxPendedTicks,"aw",%nobits
 4356              		.align	2
 4357              		.set	.LANCHOR22,. + 0
 4360              	uxPendedTicks:
 4361 0000 00000000 		.space	4
 4362              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 4363              		.align	2
 4364              		.set	.LANCHOR9,. + 0
 4367              	pxReadyTasksLists:
 4368 0000 00000000 		.space	100
 4368      00000000 
 4368      00000000 
 4368      00000000 
 4368      00000000 
 4369              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 4370              		.align	2
 4371              		.set	.LANCHOR14,. + 0
 4374              	xTasksWaitingTermination:
 4375 0000 00000000 		.space	20
 4375      00000000 
 4375      00000000 
 4375      00000000 
 4375      00000000 
 4376              		.section	.bss.pxCurrentTCB,"aw",%nobits
 4377              		.align	2
 4378              		.set	.LANCHOR2,. + 0
 4381              	pxCurrentTCB:
 4382 0000 00000000 		.space	4
 4383              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 4384              		.align	2
 4385              		.set	.LANCHOR1,. + 0
 4388              	xNextTaskUnblockTime:
 4389 0000 00000000 		.space	4
 4390              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 4391              		.align	2
 4392              		.set	.LANCHOR19,. + 0
 4395              	uxSchedulerSuspended:
 4396 0000 00000000 		.space	4
 4397              		.section	.bss.xTickCount,"aw",%nobits
 4398              		.align	2
 4399              		.set	.LANCHOR3,. + 0
 4402              	xTickCount:
 4403 0000 00000000 		.space	4
 4404              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 4405              		.align	2
 4406              		.set	.LANCHOR4,. + 0
 4409              	pxOverflowDelayedTaskList:
 4410 0000 00000000 		.space	4
 4411              		.section	.bss.xPendingReadyList,"aw",%nobits
 4412              		.align	2
 4413              		.set	.LANCHOR13,. + 0
 4416              	xPendingReadyList:
 4417 0000 00000000 		.space	20
 4417      00000000 
 4417      00000000 
 4417      00000000 
 4417      00000000 
 4418              		.section	.bss.uxTaskNumber,"aw",%nobits
 4419              		.align	2
 4420              		.set	.LANCHOR17,. + 0
 4423              	uxTaskNumber:
 4424 0000 00000000 		.space	4
 4425              		.section	.bss.ulTotalRunTime,"aw",%nobits
 4426              		.align	2
 4427              		.set	.LANCHOR6,. + 0
 4430              	ulTotalRunTime:
 4431 0000 00000000 		.space	4
 4432              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 4433              		.align	2
 4434              		.set	.LANCHOR12,. + 0
 4437              	xDelayedTaskList2:
 4438 0000 00000000 		.space	20
 4438      00000000 
 4438      00000000 
 4438      00000000 
 4438      00000000 
 4439              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 4440              		.align	2
 4441              		.set	.LANCHOR20,. + 0
 4444              	xIdleTaskHandle:
 4445 0000 00000000 		.space	4
 4446              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 4447              		.align	2
 4448              		.set	.LANCHOR10,. + 0
 4451              	uxCurrentNumberOfTasks:
 4452 0000 00000000 		.space	4
 4453              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 4454              		.align	2
 4455              		.set	.LANCHOR8,. + 0
 4458              	uxTopReadyPriority:
 4459 0000 00000000 		.space	4
 4460              		.section	.bss.xYieldPending,"aw",%nobits
 4461              		.align	2
 4462              		.set	.LANCHOR5,. + 0
 4465              	xYieldPending:
 4466 0000 00000000 		.space	4
 4467              		.text
 4468              	.Letext0:
 4469              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\lib\\gcc\\arm-none-eabi\\4.9
 4470              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\mach
 4471              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\stdi
 4472              		.file 5 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 4473              		.file 6 "FreeRTOS/Source/include/projdefs.h"
 4474              		.file 7 "FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 4475              		.file 8 "FreeRTOS/Source/include/list.h"
 4476              		.file 9 "FreeRTOS/Source/include/task.h"
 4477              		.file 10 "libs/CMSIS/Include/core_cm4.h"
 4478              		.file 11 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\std
 4479              		.file 12 "c:\\program files (x86)\\gnu tools arm embedded\\4.9 2014q4\\arm-none-eabi\\include\\str
 4480              		.file 13 "FreeRTOS/Source/include/portable.h"
 4481              		.file 14 "sys/ustime.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:20     .text.prvResetNextTaskUnblockTime:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:24     .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:63     .text.prvResetNextTaskUnblockTime:00000020 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:71     .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:75     .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:139    .text.prvAddCurrentTaskToDelayedList:00000038 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:150    .text.vTaskSwitchContext.part.4:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:154    .text.vTaskSwitchContext.part.4:00000000 vTaskSwitchContext.part.4
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:249    .text.vTaskSwitchContext.part.4:00000078 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:261    .text.xTaskGenericCreate:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:266    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:605    .text.xTaskGenericCreate:00000190 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:624    .text.vTaskDelete:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:629    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:744    .text.vTaskDelete:00000068 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:753    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:758    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:806    .text.uxTaskPriorityGet:00000024 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:811    .text.uxTaskPriorityGetFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:816    .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:859    .text.uxTaskPriorityGetFromISR:00000020 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:864    .text.vTaskPrioritySet:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:869    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1017   .text.vTaskPrioritySet:0000009c $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1024   .text.vTaskSuspend:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1029   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1191   .text.vTaskSuspend:00000080 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1201   .text.vTaskResume:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1206   .text.vTaskResume:00000000 vTaskResume
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1321   .text.vTaskResume:00000068 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1330   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1335   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1454   .text.xTaskResumeFromISR:00000074 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1464   .text.vTaskStartScheduler:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1469   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1555   .text.vTaskStartScheduler:00000050 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2320   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1565   .text.vTaskEndScheduler:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1570   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1594   .text.vTaskEndScheduler:00000014 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1599   .text.vTaskSuspendAll:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1604   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1620   .text.vTaskSuspendAll:0000000c $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1625   .text.xTaskGetTickCount:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1630   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1646   .text.xTaskGetTickCount:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1651   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1656   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1673   .text.xTaskGetTickCountFromISR:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1678   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1683   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1698   .text.uxTaskGetNumberOfTasks:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1703   .text.xTaskGetIdleTaskHandle:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1708   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1723   .text.xTaskGetIdleTaskHandle:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1728   .text.xTaskIncrementTick:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1733   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1924   .text.xTaskIncrementTick:000000fc $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1940   .text.xTaskResumeAll:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:1945   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2083   .text.xTaskResumeAll:000000b4 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2095   .text.vTaskDelayUntil:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2100   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2212   .text.vTaskDelayUntil:00000050 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2219   .text.vTaskDelay:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2224   .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2309   .text.vTaskDelay:00000038 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2316   .text.prvIdleTask:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2429   .text.prvIdleTask:00000074 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2443   .text.vTaskSetApplicationTaskTag:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2448   .text.vTaskSetApplicationTaskTag:00000000 vTaskSetApplicationTaskTag
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2513   .text.vTaskSetApplicationTaskTag:00000028 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2518   .text.xTaskGetApplicationTaskTag:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2523   .text.xTaskGetApplicationTaskTag:00000000 xTaskGetApplicationTaskTag
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2562   .text.xTaskGetApplicationTaskTag:0000001c $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2567   .text.xTaskCallApplicationTaskHook:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2572   .text.xTaskCallApplicationTaskHook:00000000 xTaskCallApplicationTaskHook
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2607   .text.xTaskCallApplicationTaskHook:00000014 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2612   .text.vTaskSwitchContext:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2617   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2639   .text.vTaskSwitchContext:00000014 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2645   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2650   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2724   .text.vTaskPlaceOnEventList:00000038 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2731   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2736   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2816   .text.vTaskPlaceOnUnorderedEventList:00000040 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2823   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2828   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2903   .text.xTaskRemoveFromEventList:0000005c $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2913   .text.xTaskRemoveFromUnorderedEventList:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2918   .text.xTaskRemoveFromUnorderedEventList:00000000 xTaskRemoveFromUnorderedEventList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2982   .text.xTaskRemoveFromUnorderedEventList:00000048 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2990   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:2995   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3016   .text.vTaskSetTimeOutState:00000010 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3022   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3027   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3138   .text.xTaskCheckForTimeOut:00000058 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3144   .text.vTaskMissedYield:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3149   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3164   .text.vTaskMissedYield:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3169   .text.uxTaskGetStackHighWaterMark:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3174   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3231   .text.uxTaskGetStackHighWaterMark:00000028 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3236   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3241   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3257   .text.xTaskGetCurrentTaskHandle:00000008 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3262   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3267   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3364   .text.vTaskPriorityInherit:00000068 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3371   .text.xTaskPriorityDisinherit:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3376   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3467   .text.xTaskPriorityDisinherit:00000050 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3473   .text.uxTaskResetEventItemValue:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3478   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3503   .text.uxTaskResetEventItemValue:00000014 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3508   .text.pvTaskIncrementMutexHeldCount:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3513   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3537   .text.pvTaskIncrementMutexHeldCount:00000014 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3542   .text.ulTaskNotifyTake:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3547   .text.ulTaskNotifyTake:00000000 ulTaskNotifyTake
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3653   .text.ulTaskNotifyTake:00000078 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3660   .text.xTaskNotifyWait:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3665   .text.xTaskNotifyWait:00000000 xTaskNotifyWait
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3787   .text.xTaskNotifyWait:00000098 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3794   .text.xTaskGenericNotify:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3799   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3846   .text.xTaskGenericNotify:0000002a $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3850   .text.xTaskGenericNotify:0000002e $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3934   .text.xTaskGenericNotify:00000090 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3941   .text.xTaskGenericNotifyFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3946   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3995   .text.xTaskGenericNotifyFromISR:00000028 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:3999   .text.xTaskGenericNotifyFromISR:0000002c $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4106   .text.xTaskGenericNotifyFromISR:000000ac $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4115   .text.vTaskNotifyGiveFromISR:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4120   .text.vTaskNotifyGiveFromISR:00000000 vTaskNotifyGiveFromISR
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4233   .text.vTaskNotifyGiveFromISR:00000084 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4242   .text.xTaskNotifyStateClear:00000000 $t
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4247   .text.xTaskNotifyStateClear:00000000 xTaskNotifyStateClear
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4297   .text.xTaskNotifyStateClear:0000002c $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4381   .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4303   .bss.ulTaskSwitchedInTime:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4307   .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4310   .bss.xNumOfOverflows:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4314   .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4317   .bss.pxDelayedTaskList:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4321   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4324   .rodata.str1.4:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4328   .bss.xSchedulerRunning:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4332   .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4335   .bss.uxTasksDeleted:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4339   .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4342   .bss.xDelayedTaskList1:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4346   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4349   .bss.xSuspendedTaskList:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4353   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4356   .bss.uxPendedTicks:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4360   .bss.uxPendedTicks:00000000 uxPendedTicks
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4363   .bss.pxReadyTasksLists:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4367   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4370   .bss.xTasksWaitingTermination:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4374   .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4377   .bss.pxCurrentTCB:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4384   .bss.xNextTaskUnblockTime:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4388   .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4391   .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4395   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4398   .bss.xTickCount:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4402   .bss.xTickCount:00000000 xTickCount
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4405   .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4409   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4412   .bss.xPendingReadyList:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4416   .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4419   .bss.uxTaskNumber:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4423   .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4426   .bss.ulTotalRunTime:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4430   .bss.ulTotalRunTime:00000000 ulTotalRunTime
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4433   .bss.xDelayedTaskList2:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4437   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4440   .bss.xIdleTaskHandle:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4444   .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4447   .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4451   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4454   .bss.uxTopReadyPriority:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4458   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4461   .bss.xYieldPending:00000000 $d
C:\Users\Student\AppData\Local\Temp\ccKR6jHo.s:4465   .bss.xYieldPending:00000000 xYieldPending
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vListInsert
get_us_time
malloc
memset
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
free
vListInitialise
uxListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
